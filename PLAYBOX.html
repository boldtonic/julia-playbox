<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Julia's Playbox</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽµ</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --pink: #FF6B9D;
            --purple: #9B59B6;
            --blue: #3498DB;
            --green: #2ECC71;
            --yellow: #F1C40F;
            --orange: #E67E22;
            --red: #E74C3C;
            --cyan: #1ABC9C;
            --bg-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --card-bg: rgba(255, 255, 255, 0.95);
            --shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            --radius: 24px;
        }

        body {
            font-family: 'Comic Sans MS', 'Chalkboard', 'Comic Neue', cursive, sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .bubbles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 0;
        }

        .bubble {
            position: absolute;
            bottom: -100px;
            border-radius: 50%;
            opacity: 0.6;
            animation: float-up linear infinite;
        }

        @keyframes float-up {
            0% { transform: translateY(0) rotate(0deg); opacity: 0.6; }
            100% { transform: translateY(-110vh) rotate(720deg); opacity: 0; }
        }

        /* HEADER */
        .top-header {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 15px 20px;
            position: sticky;
            top: 0;
            z-index: 100;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* MAIN TABS */
        .main-tabs {
            display: flex;
            gap: 8px;
            margin-left: 20px;
        }

        .main-tab {
            padding: 10px 24px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.15);
            color: white;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .main-tab:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
        }

        .main-tab.active {
            background: white;
            color: var(--purple);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .main-tab .tab-icon {
            font-size: 1.3rem;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* PAINT TAB STYLES */
        .paint-container {
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        .paint-toolbar {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 15px 20px;
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow);
            position: relative;
            z-index: 2;
        }

        .paint-colors {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .color-btn {
            width: 44px;
            height: 44px;
            border: 3px solid transparent;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.2);
        }

        @media (max-width: 600px) {
            .paint-container { padding: 10px; }
            .paint-toolbar { padding: 12px; gap: 10px; border-radius: 16px; }
            .color-btn { width: 36px; height: 36px; }
            .brush-size-control { padding: 6px 10px; }
            .brush-size-control label { display: none; }
            .brush-slider { width: 80px; }
            .brush-preview { width: 40px; height: 40px; }
            .paint-btn { padding: 10px 14px; font-size: 0.9rem; }
            .paint-btn span:last-child { display: none; }
            .canvas-wrapper { padding: 10px; border-radius: 16px; }
            #paintCanvas { min-height: 200px; max-height: 400px; height: calc(100vh - 320px); }
        }

        .color-btn:hover {
            transform: scale(1.15);
        }

        .color-btn.active {
            border-color: white;
            box-shadow: 0 0 0 3px var(--purple), 0 4px 12px rgba(0, 0, 0, 0.3);
            transform: scale(1.1);
        }

        .brush-size-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.05);
            padding: 8px 15px;
            border-radius: 25px;
        }

        .brush-size-control label {
            font-weight: bold;
            color: #666;
            font-size: 0.9rem;
        }

        .brush-slider {
            width: 120px;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, var(--purple), var(--pink));
            border-radius: 4px;
        }

        .brush-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .brush-preview {
            width: 50px;
            height: 50px;
            background: #f0f0f0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .brush-dot {
            border-radius: 50%;
            background: #333;
            transition: all 0.15s ease;
        }

        .paint-actions {
            display: flex;
            gap: 10px;
        }

        .paint-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 16px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.15);
        }

        .paint-btn:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.15);
        }

        .paint-btn.clear { background: var(--red); color: white; }
        .paint-btn.undo { background: var(--orange); color: white; }
        .paint-btn.save { background: var(--green); color: white; }
        .paint-btn.eraser { background: #f0f0f0; color: #666; }
        .paint-btn.eraser.active { background: var(--purple); color: white; }

        .canvas-wrapper {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 15px;
            box-shadow: var(--shadow);
            touch-action: none;
            position: relative;
            z-index: 2;
        }

        #paintCanvas {
            display: block;
            width: 100%;
            height: calc(100vh - 380px);
            min-height: 250px;
            max-height: 500px;
            position: relative;
            z-index: 3;
            background: white;
            border-radius: 16px;
            cursor: crosshair;
            touch-action: none;
        }

        /* PAINT SUB-TABS */
        .paint-sub-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 10px;
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        .paint-sub-tab {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            background: white;
            color: #666;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
            font-family: 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
        }

        .paint-sub-tab:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }

        .paint-sub-tab.active {
            background: linear-gradient(135deg, var(--pink), var(--purple));
            color: white;
            box-shadow: 0 4px 20px rgba(255, 107, 157, 0.5);
            transform: scale(1.05);
        }

        .paint-sub-tab .sub-tab-icon { font-size: 1.3rem; }

        .paint-mode { display: none; }
        .paint-mode.active { display: block; }

        /* COLOR A PHOTO */
        .photo-upload-area {
            background: var(--card-bg);
            border-radius: var(--radius);
            padding: 60px 20px;
            box-shadow: var(--shadow);
            text-align: center;
            border: 4px dashed #d0d0d0;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .photo-upload-area:hover,
        .photo-upload-area.dragover {
            border-color: var(--purple);
            background: rgba(155, 89, 182, 0.05);
            transform: scale(1.01);
        }

        .upload-content .upload-icon { font-size: 4rem; margin-bottom: 15px; }
        .upload-content h3 { font-size: 1.4rem; color: var(--purple); margin-bottom: 8px; }
        .upload-content p { color: #888; font-size: 1rem; }
        .upload-hint { color: var(--pink) !important; font-weight: bold; margin-top: 10px !important; }

        .sensitivity-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 0, 0, 0.05);
            padding: 8px 15px;
            border-radius: 25px;
        }

        .sensitivity-control label {
            font-weight: bold;
            color: #666;
            font-size: 0.9rem;
            white-space: nowrap;
        }

        /* Floating Reference Thumbnail */
        .reference-thumbnail {
            position: absolute;
            bottom: 15px;
            right: 15px;
            width: 150px;
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
            overflow: hidden;
            z-index: 10;
            transition: opacity 0.3s ease;
        }

        .reference-thumbnail canvas {
            width: 100%;
            display: block;
            border-radius: 0 0 12px 12px;
        }

        .ref-thumb-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 10px;
            background: linear-gradient(135deg, var(--pink), var(--purple));
            color: white;
            font-size: 0.75rem;
            font-weight: bold;
        }

        .ref-thumb-close {
            background: rgba(255,255,255,0.3);
            border: none;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ref-toggle-btn {
            display: block;
            margin: 10px auto;
            padding: 10px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, var(--pink), var(--purple));
            color: white;
            font-weight: bold;
            font-size: 0.9rem;
            cursor: pointer;
            font-family: 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
            transition: all 0.2s ease;
        }

        .ref-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        /* COLORING BOOK GALLERY */
        .coloring-category-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
            justify-content: center;
            padding: 10px;
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        .coloring-category-tab {
            padding: 8px 14px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            background: white;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: bold;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
        }

        .coloring-category-tab:hover { border-color: var(--purple); transform: translateY(-2px); }
        .coloring-category-tab.active { background: var(--purple); color: white; border-color: var(--purple); }

        .coloring-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            padding: 10px;
        }

        .coloring-card {
            background: var(--card-bg);
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
        }

        .coloring-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .coloring-card canvas {
            width: 100%;
            aspect-ratio: 1;
            display: block;
            background: white;
        }

        .coloring-card-label {
            padding: 8px;
            font-weight: bold;
            font-size: 0.85rem;
            color: #555;
        }

        @media (max-width: 600px) {
            .paint-sub-tabs { gap: 6px; padding: 8px; }
            .paint-sub-tab { padding: 8px 12px; font-size: 0.85rem; gap: 5px; }
            .paint-sub-tab .sub-tab-icon { font-size: 1.1rem; }
            .photo-upload-area { padding: 30px 15px; }
            .upload-content .upload-icon { font-size: 3rem; }
            .upload-content h3 { font-size: 1.1rem; }
            .reference-thumbnail { width: 100px; }
            .sensitivity-control label { display: none; }
            .coloring-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px; }
            .coloring-category-tabs { gap: 6px; padding: 8px; }
            .coloring-category-tab { padding: 6px 10px; font-size: 0.8rem; }
        }

        @media (max-width: 400px) {
            .paint-sub-tab { padding: 10px; font-size: 0; }
            .paint-sub-tab .sub-tab-icon { font-size: 1.3rem; }
        }

        @media (min-width: 900px) {
            .coloring-grid { grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); }
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
            flex-wrap: wrap;
        }

        .logo-section h1 {
            font-size: clamp(1.2rem, 4vw, 2rem);
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            animation: bounce 2s ease-in-out infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        /* MOBILE RESPONSIVE - Global */
        @media (max-width: 768px) {
            .top-header { padding: 10px 15px; }
            .header-content {
                gap: 10px;
                justify-content: center;
            }
            .logo-section {
                width: 100%;
                text-align: center;
                order: 1;
            }
            .main-tabs {
                margin-left: 0;
                order: 2;
                justify-content: center;
                width: 100%;
            }
            .main-tab {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
            .main-tab span:not(.tab-icon) { display: none; }
            .main-tab .tab-icon { font-size: 1.4rem; }
            .header-controls {
                order: 3;
                width: 100%;
                justify-content: center;
            }
            .volume-control { display: none; }
            .settings-toggle span:last-child { display: none; }
        }

        @media (max-width: 480px) {
            .logo-section h1 { font-size: 1.1rem; }
            .main-tab { padding: 10px 14px; }
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.15);
            padding: 8px 15px;
            border-radius: 25px;
        }

        .volume-control span { font-size: 1.2rem; }

        .volume-slider {
            width: 120px;
            height: 12px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 32px;
            height: 32px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .settings-toggle {
            background: rgba(255, 255, 255, 0.15);
            border: none;
            padding: 10px 15px;
            border-radius: 25px;
            color: white;
            font-size: 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
        }

        .settings-toggle:hover { background: rgba(255, 255, 255, 0.25); }
        .settings-toggle.active { background: var(--purple); }

        /* VISUALIZER */
        .visualizer-section {
            background: linear-gradient(180deg, rgba(0,0,0,0.3) 0%, transparent 100%);
            padding: 20px 20px 20px;
            margin-top: 10px;
            position: relative;
            z-index: 1;
        }

        .visualizer-container { max-width: 1400px; margin: 0 auto; }

        .visualizer-canvas {
            width: 100%;
            height: 100px;
            border-radius: 16px;
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 600px) {
            .visualizer-section { padding: 15px 15px 15px; margin-top: 5px; }
            .visualizer-canvas { height: 60px; border-radius: 12px; }
        }

        /* SETTINGS PANEL */
        .settings-panel {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease, padding 0.3s ease;
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .settings-panel.show {
            max-height: 200px;
            padding: 15px 20px;
        }

        .settings-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .setting-item {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px 18px;
            border-radius: 25px;
            color: white;
        }

        .setting-item span { font-size: 0.9rem; font-weight: bold; }

        .toggle {
            width: 44px;
            height: 24px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 24px;
            cursor: pointer;
            position: relative;
            transition: background 0.3s;
        }

        .toggle.on { background: var(--green); }

        .toggle::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .toggle.on::after { transform: translateX(20px); }

        /* MAIN CONTENT */
        .main-content {
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        .bento-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            max-width: 1400px;
            margin: 0 auto;
        }

        @media (min-width: 768px) {
            .bento-grid { grid-template-columns: repeat(2, 1fr); gap: 20px; }
        }

        @media (min-width: 1024px) {
            .bento-grid { grid-template-columns: repeat(3, 1fr); }
        }

        .bento-card {
            background: var(--card-bg);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 20px;
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .bento-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
        }

        .bento-card.large { grid-column: span 2; }
        .bento-card.full { grid-column: 1 / -1; }

        @media (min-width: 1024px) {
            .bento-card.large { grid-column: span 2; }
            .bento-card.full { grid-column: 1 / -1; }
        }

        @media (max-width: 767px) {
            .main-content { padding: 15px 10px; }
            .bento-grid { grid-template-columns: 1fr; gap: 12px; }
            .bento-card { padding: 15px; border-radius: 18px; }
            .bento-card.large, .bento-card.full { grid-column: 1; }
            .bento-card:hover { transform: none; }
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }

        .card-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-icon { font-size: 1.8rem; }
        .card-name { font-size: 1.1rem; font-weight: bold; color: #333; }

        @media (max-width: 480px) {
            .card-icon { font-size: 1.5rem; }
            .card-name { font-size: 1rem; }
        }

        .more-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            background: #f0f0f0;
            color: #666;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .more-btn:hover { background: #e0e0e0; transform: scale(1.1); }
        .more-btn.active { background: var(--purple); color: white; transform: rotate(45deg); }

        .card-content { flex: 1; display: flex; flex-direction: column; }
        .card-actions { display: flex; flex-wrap: wrap; gap: 8px; }

        .card-more {
            display: none;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 2px dashed #eee;
            animation: slideDown 0.3s ease;
        }

        .card-more.show { display: block; }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .action-btn {
            padding: 12px 18px;
            border: none;
            border-radius: 16px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.15);
        }

        .action-btn:active { transform: translateY(3px); box-shadow: 0 1px 0 rgba(0, 0, 0, 0.15); }
        .action-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .action-btn.primary { background: var(--purple); color: white; }
        .action-btn.green { background: var(--green); color: white; }
        .action-btn.red { background: var(--red); color: white; }
        .action-btn.blue { background: var(--blue); color: white; }
        .action-btn.orange { background: var(--orange); color: white; }
        .action-btn.pink { background: var(--pink); color: white; }
        .action-btn.cyan { background: var(--cyan); color: white; }

        /* INSTRUMENTS */
        .instrument-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            justify-content: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 16px;
        }

        .instrument-chip {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            background: white;
            color: #666;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .instrument-chip:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
        }

        .instrument-chip.active {
            background: linear-gradient(135deg, var(--pink), var(--purple));
            color: white;
            box-shadow: 0 4px 20px rgba(255, 107, 157, 0.5);
            transform: scale(1.05);
        }

        .instrument-chip .chip-icon {
            font-size: 1.3rem;
        }

        @media (max-width: 600px) {
            .instrument-selector {
                gap: 6px;
                padding: 8px;
            }
            .instrument-chip {
                padding: 8px 12px;
                font-size: 0.85rem;
                gap: 5px;
            }
            .instrument-chip .chip-icon { font-size: 1.1rem; }
            /* Hide text on very small screens, show only icons */
        }

        @media (max-width: 400px) {
            .instrument-chip {
                padding: 10px;
                font-size: 0;
            }
            .instrument-chip .chip-icon { font-size: 1.3rem; }
        }

        .piano-container { overflow-x: auto; padding: 15px 0; -webkit-overflow-scrolling: touch; }
        .piano { display: flex; justify-content: center; gap: 3px; min-width: fit-content; }

        .piano-key {
            width: 50px;
            height: 140px;
            border: none;
            border-radius: 0 0 8px 8px;
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
            font-size: 0.7rem;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 8px;
            color: #999;
        }

        .piano-key.white { background: linear-gradient(180deg, #fff 0%, #e8e8e8 100%); box-shadow: 0 6px 0 #bbb; }
        .piano-key.black { background: linear-gradient(180deg, #333 0%, #111 100%); width: 35px; height: 90px; margin: 0 -17px; z-index: 2; box-shadow: 0 6px 0 #000; color: #666; }
        .piano-key:active, .piano-key.active { transform: translateY(4px); box-shadow: none; }

        /* Mobile-friendly sizes */
        @media (max-width: 480px) {
            .piano-key { width: 36px; height: 100px; font-size: 0.6rem; }
            .piano-key.black { width: 26px; height: 65px; margin: 0 -13px; }
            .piano-container { padding: 10px 0; }
        }

        /* Tablet-friendly sizes */
        @media (min-width: 600px) {
            .piano-key { width: 60px; height: 160px; }
            .piano-key.black { width: 40px; height: 100px; margin: 0 -20px; }
        }

        @media (min-width: 900px) {
            .piano-key { width: 70px; height: 180px; }
            .piano-key.black { width: 45px; height: 110px; margin: 0 -22px; }
        }

        /* ==========================================
           REALISTIC INSTRUMENT STYLES
           ========================================== */

        /* DRUMS - Realistic drum heads with rim */
        .drum-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            max-width: 500px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #2c2c2c 0%, #1a1a1a 100%);
            border-radius: 20px;
        }

        @media (min-width: 768px) {
            .drum-grid { grid-template-columns: repeat(4, 1fr); max-width: 450px; }
        }

        .drum-pad {
            aspect-ratio: 1;
            border: 6px solid #444;
            border-radius: 50%;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.05s ease;
            min-height: 80px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1) 0%, transparent 50%);
            box-shadow:
                inset 0 0 30px rgba(0,0,0,0.5),
                0 4px 8px rgba(0,0,0,0.5),
                0 0 0 3px #222;
        }

        .drum-pad .pad-label {
            font-size: 0.6rem;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
        }

        .drum-pad:active, .drum-pad.active {
            transform: scale(0.95);
            box-shadow: inset 0 0 40px rgba(0,0,0,0.7), 0 2px 4px rgba(0,0,0,0.5);
        }

        /* XYLOPHONE - Wooden/metal bars with mallets */
        .xylo-grid {
            display: flex;
            gap: 6px;
            justify-content: center;
            align-items: flex-end;
            padding: 20px;
            background: linear-gradient(180deg, #8B4513 0%, #5D3A1A 100%);
            border-radius: 15px;
            box-shadow: inset 0 -5px 15px rgba(0,0,0,0.3);
        }

        .xylo-btn {
            width: 50px;
            min-height: 90px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.08s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            padding-bottom: 8px;
            position: relative;
            box-shadow:
                0 4px 0 rgba(0,0,0,0.4),
                inset 0 2px 10px rgba(255,255,255,0.3),
                inset 0 -2px 10px rgba(0,0,0,0.2);
        }

        .xylo-btn::after {
            content: '';
            position: absolute;
            bottom: -15px;
            width: 8px;
            height: 15px;
            background: #654321;
            border-radius: 0 0 3px 3px;
        }

        .xylo-btn .note-label {
            font-size: 0.7rem;
            font-weight: bold;
            color: rgba(0, 0, 0, 0.7);
            text-shadow: 0 1px 0 rgba(255,255,255,0.3);
        }

        .xylo-btn:active {
            transform: translateY(3px) rotateX(10deg);
            box-shadow: 0 1px 0 rgba(0,0,0,0.4);
        }

        /* GUITAR - Horizontal strings on fretboard */
        .guitar-grid {
            display: flex;
            flex-direction: column;
            gap: 0;
            padding: 15px 30px;
            background: linear-gradient(90deg, #2C1810 0%, #4A3728 50%, #2C1810 100%);
            border-radius: 10px;
            position: relative;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }

        .guitar-grid::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 4px;
            background: #888;
            transform: translateX(-50%);
        }

        .string-btn {
            width: 100%;
            height: 40px;
            border: none;
            background: transparent;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 10px;
        }

        .string-btn::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            height: 3px;
            background: linear-gradient(90deg, #DAA520, #FFD700, #DAA520);
            box-shadow: 0 1px 2px rgba(0,0,0,0.5);
            transform: translateY(-50%);
            transition: all 0.1s;
        }

        .string-btn:active::before {
            height: 5px;
            filter: brightness(1.3);
            animation: stringVibrate 0.1s ease-in-out;
        }

        @keyframes stringVibrate {
            0%, 100% { transform: translateY(-50%); }
            25% { transform: translateY(-55%); }
            75% { transform: translateY(-45%); }
        }

        .string-btn .note-label {
            font-size: 0.7rem;
            color: #FFD700;
            z-index: 1;
            background: #2C1810;
            padding: 2px 6px;
            border-radius: 3px;
        }

        /* BELLS - Actual bell shapes */
        .bells-grid {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            padding: 20px;
        }

        .bell-btn {
            width: 65px;
            height: 75px;
            border: none;
            background: linear-gradient(180deg, #FFD700 0%, #B8860B 50%, #8B6914 100%);
            cursor: pointer;
            position: relative;
            clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);
            box-shadow: 2px 4px 8px rgba(0,0,0,0.3);
            transition: all 0.1s;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 8px;
        }

        .bell-btn::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 12px;
            height: 12px;
            background: #8B6914;
            border-radius: 50%;
        }

        .bell-btn::after {
            content: '';
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 8px;
            height: 8px;
            background: #654321;
            border-radius: 50%;
        }

        .bell-btn:active {
            transform: rotate(-10deg);
        }

        .bell-btn .note-label {
            font-size: 0.6rem;
            color: #4A3000;
            font-weight: bold;
            z-index: 1;
        }

        /* BASS - Thick horizontal strings */
        .bass-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 20px 40px;
            background: linear-gradient(90deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 15px;
            border: 3px solid #333;
        }

        .bass-btn {
            width: 100%;
            height: 40px;
            border: none;
            background: transparent;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
        }

        .bass-btn::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            top: 50%;
            background: linear-gradient(90deg, #8B8B8B, #C0C0C0, #8B8B8B);
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            transform: translateY(-50%);
            transition: all 0.1s;
            border-radius: 3px;
        }

        .bass-btn:nth-child(1)::before { height: 8px; }
        .bass-btn:nth-child(2)::before { height: 7px; }
        .bass-btn:nth-child(3)::before { height: 6px; }
        .bass-btn:nth-child(4)::before { height: 5px; }
        .bass-btn:nth-child(5)::before { height: 4px; }
        .bass-btn:nth-child(6)::before { height: 3px; }

        .bass-btn:active::before {
            filter: brightness(1.4);
            animation: stringVibrate 0.15s ease-in-out;
        }

        .bass-btn .note-label {
            font-size: 0.7rem;
            color: #00ff88;
            z-index: 1;
            background: #1a1a2e;
            padding: 2px 8px;
            border-radius: 3px;
            margin-left: 10px;
        }

        /* SYNTH - Modular synth knobs */
        .synth-grid {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            padding: 25px;
            background: linear-gradient(180deg, #2d2d2d 0%, #1a1a1a 100%);
            border-radius: 15px;
            border: 2px solid #444;
        }

        .synth-btn {
            width: 70px;
            height: 80px;
            border: none;
            background: #333;
            border-radius: 12px;
            cursor: pointer;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            box-shadow: 0 3px 6px rgba(0,0,0,0.4);
        }

        .synth-btn::before {
            content: '';
            width: 35px;
            height: 35px;
            background: linear-gradient(135deg, #666 0%, #333 100%);
            border-radius: 50%;
            border: 3px solid #222;
            box-shadow: inset 0 2px 5px rgba(255,255,255,0.1);
        }

        .synth-btn::after {
            content: '';
            position: absolute;
            top: 18px;
            width: 3px;
            height: 12px;
            background: #00ffff;
            border-radius: 2px;
            box-shadow: 0 0 8px #00ffff;
        }

        .synth-btn:active::after {
            background: #ff00ff;
            box-shadow: 0 0 15px #ff00ff;
        }

        .synth-btn .note-label {
            font-size: 0.65rem;
            color: #00ffff;
        }

        /* HARP - Elegant vertical strings on golden frame */
        .harp-grid {
            display: flex;
            gap: 0;
            justify-content: center;
            align-items: flex-end;
            padding: 20px 30px;
            background: linear-gradient(180deg, transparent 0%, rgba(218,165,32,0.1) 100%);
            border-left: 15px solid;
            border-image: linear-gradient(180deg, #DAA520, #B8860B) 1;
            border-radius: 0 30px 0 0;
            position: relative;
        }

        .harp-grid::before {
            content: '';
            position: absolute;
            top: 0;
            left: -15px;
            right: 50%;
            height: 20px;
            background: linear-gradient(90deg, #DAA520, transparent);
            border-radius: 0 20px 0 0;
        }

        .harp-btn {
            width: 25px;
            min-height: 100px;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: all 0.05s ease;
            position: relative;
        }

        .harp-btn::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 3px;
            transform: translateX(-50%);
            background: linear-gradient(180deg, #FFD700 0%, #DAA520 50%, #B8860B 100%);
            box-shadow: 0 0 3px rgba(255,215,0,0.5);
            border-radius: 1px;
            transition: all 0.05s ease;
        }

        .harp-btn:hover::before {
            background: #FFF8DC;
            box-shadow: 0 0 10px rgba(255,215,0,0.8);
        }

        .harp-btn:active::before {
            width: 6px;
            background: #FFFACD;
            box-shadow: 0 0 15px rgba(255,215,0,1);
        }

        /* KALIMBA - Metal tines on wooden body */
        .kalimba-grid {
            display: flex;
            gap: 6px;
            justify-content: center;
            align-items: flex-end;
            padding: 30px 25px 20px;
            background: linear-gradient(180deg, #DEB887 0%, #8B4513 100%);
            border-radius: 60px 60px 30px 30px;
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.2), 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
        }

        .kalimba-grid::before {
            content: '';
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: #2C1810;
            border-radius: 50%;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.5);
        }

        .kalimba-btn {
            width: 32px;
            min-height: 80px;
            border: none;
            background: linear-gradient(180deg, #E8E8E8 0%, #C0C0C0 50%, #A0A0A0 100%);
            cursor: pointer;
            transition: all 0.05s ease;
            border-radius: 5px 5px 20px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            position: relative;
        }

        .kalimba-btn::after {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 10px;
            height: 10px;
            background: #666;
            border-radius: 50%;
        }

        .kalimba-btn:active {
            transform: translateY(3px) rotateX(15deg);
            filter: brightness(1.2);
        }

        /* STEEL DRUMS - Caribbean pan sections */
        .steeldrums-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            max-width: 360px;
            margin: 0 auto;
            padding: 25px;
            background: radial-gradient(circle, #444 0%, #222 100%);
            border-radius: 50%;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5), inset 0 -5px 20px rgba(0,0,0,0.5);
        }

        .steeldrum-btn {
            width: 75px;
            height: 65px;
            border: 2px solid #333;
            border-radius: 30% 70% 70% 30% / 60% 40% 60% 40%;
            font-size: 0;
            cursor: pointer;
            transition: all 0.05s ease;
            box-shadow: inset 0 -5px 15px rgba(0,0,0,0.4), inset 0 5px 10px rgba(255,255,255,0.1);
        }

        .steeldrum-btn:active {
            transform: scale(0.95);
            box-shadow: inset 0 0px 20px rgba(0,0,0,0.6);
        }

        /* ORGAN - Church pipe organ */
        .organ-grid {
            display: flex;
            gap: 6px;
            justify-content: center;
            align-items: flex-end;
            padding: 35px 25px 15px;
            background: linear-gradient(180deg, #4A3728 0%, #2C1810 100%);
            border-radius: 10px;
            position: relative;
        }

        .organ-grid::before {
            content: 'â™±';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1.4rem;
            color: #DAA520;
        }

        .organ-btn {
            width: 45px;
            min-height: 80px;
            border: none;
            background: linear-gradient(90deg, #C0C0C0 0%, #E8E8E8 50%, #C0C0C0 100%);
            cursor: pointer;
            transition: all 0.08s ease;
            border-radius: 50% 50% 0 0;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 -10px 20px rgba(0,0,0,0.1);
            position: relative;
        }

        .organ-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 4px;
            background: #8B4513;
        }

        .organ-btn:active {
            transform: translateY(3px);
            filter: brightness(0.9);
        }

        /* MARIMBA - Wooden bars with resonators */
        .marimba-grid {
            display: flex;
            gap: 8px;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            background: linear-gradient(180deg, #2C2C2C 0%, #1a1a1a 100%);
            border-radius: 10px;
        }

        .marimba-btn {
            width: 55px;
            min-height: 70px;
            border: none;
            background: linear-gradient(180deg, #DEB887 0%, #D2691E 30%, #8B4513 100%);
            cursor: pointer;
            transition: all 0.08s ease;
            border-radius: 5px;
            box-shadow: 0 4px 0 #5D3A1A, 0 8px 15px rgba(0,0,0,0.4);
            position: relative;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            padding-bottom: 8px;
        }

        .marimba-btn::after {
            content: '';
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            width: 25px;
            height: 20px;
            background: linear-gradient(180deg, #B8860B 0%, #8B6914 100%);
            border-radius: 0 0 50% 50%;
            box-shadow: inset 0 -5px 10px rgba(0,0,0,0.3);
        }

        .marimba-btn:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 #5D3A1A;
        }

        /* FLUTE - Silver tube with keys */
        .flute-grid {
            display: flex;
            gap: 5px;
            justify-content: center;
            align-items: center;
            padding: 25px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(192,192,192,0.1) 10%,
                rgba(192,192,192,0.2) 50%,
                rgba(192,192,192,0.1) 90%,
                transparent 100%);
            position: relative;
        }

        .flute-grid::before {
            content: '';
            position: absolute;
            left: 10%;
            right: 10%;
            height: 50px;
            background: linear-gradient(180deg, #E8E8E8 0%, #C0C0C0 50%, #A0A0A0 100%);
            border-radius: 25px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3), inset 0 2px 5px rgba(255,255,255,0.5);
            z-index: 0;
        }

        .flute-btn {
            width: 50px;
            height: 50px;
            border: 3px solid #888;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #E8E8E8, #A0A0A0);
            cursor: pointer;
            transition: all 0.1s ease;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1;
            font-size: 0;
            position: relative;
        }

        .flute-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 22px;
            height: 22px;
            background: #333;
            border-radius: 50%;
        }

        .flute-btn:active {
            transform: scale(0.9);
            background: radial-gradient(circle at 30% 30%, #C0C0C0, #808080);
        }

        /* MUSIC BOX - Delicate cylinder with pins */
        .chimes-grid {
            display: flex;
            gap: 6px;
            justify-content: center;
            padding: 20px;
            background: linear-gradient(180deg, #FFF8DC 0%, #FFE4B5 100%);
            border: 8px solid #DEB887;
            border-radius: 15px;
            box-shadow: inset 0 0 20px rgba(139,69,19,0.2);
        }

        .chimes-btn {
            width: 28px;
            height: 70px;
            border: none;
            background: linear-gradient(90deg, #FFD700 0%, #FFF8DC 50%, #FFD700 100%);
            cursor: pointer;
            transition: all 0.08s ease;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .chimes-btn:active {
            transform: translateY(-5px);
            box-shadow: 0 7px 10px rgba(0,0,0,0.2);
        }

        .chimes-btn::after {
            content: 'âœ¦';
            font-size: 0.7rem;
            color: #DAA520;
        }

        /* TRUMPET - Brass valves */
        .trumpet-grid {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: flex-end;
            padding: 25px 30px;
            background: linear-gradient(90deg, #B8860B 0%, #DAA520 20%, #FFD700 50%, #DAA520 80%, #B8860B 100%);
            border-radius: 0 100px 100px 0;
            box-shadow: inset 0 5px 15px rgba(255,255,255,0.3), inset 0 -5px 15px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.3);
            position: relative;
        }

        .trumpet-grid::before {
            content: '';
            position: absolute;
            left: -30px;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 25px;
            background: linear-gradient(180deg, #DAA520, #B8860B);
            border-radius: 10px 0 0 10px;
        }

        .trumpet-btn {
            width: 55px;
            height: 70px;
            border: none;
            background: linear-gradient(180deg, #E8E8E8 0%, #C0C0C0 30%, #A0A0A0 100%);
            cursor: pointer;
            transition: all 0.05s ease;
            border-radius: 10px;
            box-shadow: 0 4px 0 #666, inset 0 2px 5px rgba(255,255,255,0.5);
            position: relative;
        }

        .trumpet-btn::before {
            content: '';
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 32px;
            height: 32px;
            background: radial-gradient(circle, #888 0%, #666 100%);
            border-radius: 50%;
            border: 2px solid #555;
        }

        .trumpet-btn:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 #666;
        }

        /* Mobile responsive for realistic instruments */
        @media (max-width: 600px) {
            .drum-grid { max-width: 320px; gap: 10px; padding: 15px; }
            .drum-pad { min-height: 60px; font-size: 1.4rem; border-width: 4px; }
            .xylo-grid { padding: 15px 10px; gap: 4px; }
            .xylo-btn { width: 40px; min-height: 70px; }
            .guitar-grid { padding: 10px 20px; }
            .string-btn { height: 32px; }
            .bells-grid { gap: 8px; }
            .bell-btn { width: 55px; height: 65px; }
            .bass-grid { padding: 15px 25px; }
            .bass-btn { height: 32px; }
            .synth-grid { padding: 15px; gap: 10px; }
            .synth-btn { width: 60px; height: 70px; }
            .harp-grid { padding: 15px 20px; }
            .harp-btn { width: 20px; min-height: 80px; }
            .kalimba-grid { padding: 20px 15px 12px; gap: 3px; }
            .kalimba-btn { width: 26px; min-height: 65px; }
            .steeldrums-grid { max-width: 280px; padding: 15px; }
            .steeldrum-btn { width: 60px; height: 50px; }
            .organ-grid { padding: 25px 15px 12px; gap: 3px; }
            .organ-btn { width: 35px; min-height: 65px; }
            .marimba-grid { padding: 15px; gap: 5px; }
            .marimba-btn { width: 45px; min-height: 55px; }
            .flute-grid { padding: 15px; }
            .flute-btn { width: 42px; height: 42px; }
            .chimes-grid { padding: 15px; border-width: 5px; gap: 5px; }
            .chimes-btn { width: 24px; height: 55px; }
            .trumpet-grid { padding: 20px; gap: 10px; }
            .trumpet-btn { width: 48px; height: 60px; }
        }

        /* SOUND GRID */
        .sound-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            max-height: 280px;
            overflow-y: auto;
            padding: 5px;
        }

        @media (max-width: 600px) {
            .sound-grid { grid-template-columns: repeat(4, 1fr); }
        }

        .sound-btn {
            aspect-ratio: 1;
            border: none;
            border-radius: 16px;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 0 rgba(0, 0, 0, 0.2);
            position: relative;
            min-height: 60px;
        }

        @media (min-width: 600px) {
            .sound-btn { font-size: 2.5rem; min-height: 70px; }
        }

        .sound-btn:hover { transform: translateY(-2px); }
        .sound-btn:active, .sound-btn.active { transform: translateY(3px); box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2); }
        .sound-btn.playing { animation: pulse 0.3s ease; }
        .sound-btn.looping {
            box-shadow: 0 0 0 3px var(--green), 0 4px 0 rgba(0, 0, 0, 0.2);
            animation: loopPulse 1s infinite;
        }

        @keyframes pulse { 50% { transform: scale(1.15); } }
        @keyframes loopPulse {
            0%, 100% { box-shadow: 0 0 0 3px var(--green), 0 4px 0 rgba(0, 0, 0, 0.2); }
            50% { box-shadow: 0 0 0 5px var(--green), 0 4px 0 rgba(0, 0, 0, 0.2); }
        }

        /* SOUND CONTROLS */
        .sound-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .sound-control-btn {
            padding: 8px 14px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: bold;
            cursor: pointer;
            background: white;
            color: #666;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .sound-control-btn:hover { border-color: var(--purple); color: var(--purple); }
        .sound-control-btn.active { background: var(--green); border-color: var(--green); color: white; }

        /* SOUND MIXER */
        .sound-mixer {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 16px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .mixer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .mixer-title {
            font-weight: bold;
            font-size: 0.95rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mixer-tracks {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .mixer-track {
            display: flex;
            align-items: center;
            gap: 10px;
            background: white;
            padding: 8px 12px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .mixer-track-emoji {
            font-size: 1.5rem;
            width: 35px;
            text-align: center;
        }

        .mixer-track-name {
            flex: 1;
            font-size: 0.85rem;
            font-weight: bold;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .mixer-track-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .mixer-volume {
            width: 100px;
            height: 12px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 6px;
            outline: none;
        }

        .mixer-volume::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 28px;
            height: 28px;
            background: var(--purple);
            border-radius: 50%;
            cursor: pointer;
        }

        .mixer-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mixer-btn.play { background: var(--green); color: white; }
        .mixer-btn.stop { background: var(--red); color: white; }
        .mixer-btn.remove { background: #ddd; color: #666; }

        .mixer-empty {
            text-align: center;
            padding: 20px;
            color: #999;
            font-size: 0.9rem;
        }

        /* LOOP SETTINGS MODAL */
        .loop-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .loop-modal.show { display: flex; }

        .loop-modal-content {
            background: white;
            border-radius: 20px;
            padding: 25px;
            max-width: 350px;
            width: 100%;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        .loop-modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .loop-modal-title {
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .loop-modal-close {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: #f0f0f0;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .loop-setting {
            margin-bottom: 18px;
        }

        .loop-setting-label {
            display: block;
            font-size: 0.9rem;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
        }

        .loop-setting-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .loop-option {
            padding: 8px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            background: white;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: bold;
            transition: all 0.2s;
        }

        .loop-option:hover { border-color: var(--purple); }
        .loop-option.selected { background: var(--purple); color: white; border-color: var(--purple); }

        .loop-slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .loop-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, var(--blue), var(--purple));
            border-radius: 4px;
            outline: none;
        }

        .loop-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border: 3px solid var(--purple);
            border-radius: 50%;
            cursor: pointer;
        }

        .loop-slider-value {
            min-width: 50px;
            text-align: center;
            font-weight: bold;
            color: var(--purple);
        }

        .loop-modal-actions {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .loop-modal-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
        }

        .loop-modal-btn.primary { background: var(--green); color: white; }
        .loop-modal-btn.secondary { background: #f0f0f0; color: #333; }

        /* LOADING INDICATOR */
        .sound-btn.loading {
            position: relative;
            pointer-events: none;
        }

        .sound-btn.loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 3px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .sound-btn.playing {
            animation: pulse 0.5s ease;
            box-shadow: 0 0 0 4px rgba(46, 204, 113, 0.4), 0 6px 0 rgba(0,0,0,0.2);
        }

        /* CATEGORY TABS */
        .category-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .category-tab {
            padding: 8px 14px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            background: white;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: bold;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .category-tab:hover { border-color: var(--purple); }
        .category-tab.active { background: var(--purple); color: white; border-color: var(--purple); }

        /* SOUND CATEGORIES */
        .sound-category {
            margin-bottom: 15px;
            border-radius: 16px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.03);
        }

        .category-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 15px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15), rgba(118, 75, 162, 0.15));
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }

        .category-header:hover {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.25), rgba(118, 75, 162, 0.25));
        }

        .category-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            font-size: 1rem;
            color: #333;
        }

        .category-icon {
            font-size: 1.3rem;
        }

        .category-count {
            background: rgba(0, 0, 0, 0.1);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            color: #666;
        }

        .category-toggle {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .category-toggle.open {
            transform: rotate(180deg);
        }

        .category-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, padding 0.3s ease;
            padding: 0 10px;
        }

        .category-content.open {
            max-height: 500px;
            padding: 12px 10px;
        }

        .category-sounds {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
        }

        @media (max-width: 600px) {
            .category-sounds { grid-template-columns: repeat(4, 1fr); }
        }

        @media (min-width: 900px) {
            .category-sounds { grid-template-columns: repeat(6, 1fr); }
        }

        /* TRACKS */
        .track-grid { display: flex; flex-direction: column; gap: 8px; }

        .track-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: #f8f9fa;
            border-radius: 12px;
            transition: all 0.2s ease;
        }

        .track-row.playing { background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); }

        .track-play-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            font-size: 1.1rem;
            cursor: pointer;
            background: var(--green);
            color: white;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .track-play-btn:hover { transform: scale(1.1); }
        .track-play-btn.stop { background: var(--red); }

        .track-name { flex: 1; font-weight: bold; font-size: 0.95rem; }

        /* MIC */
        .mic-status-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 12px;
            margin-bottom: 12px;
        }

        .mic-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #ccc;
            flex-shrink: 0;
        }

        .mic-dot.ready { background: var(--green); }
        .mic-dot.recording { background: var(--red); animation: mic-pulse 1s infinite; }
        .mic-dot.monitoring { background: var(--blue); animation: mic-pulse 1.5s infinite; }

        @keyframes mic-pulse { 50% { opacity: 0.5; transform: scale(1.2); } }

        .mic-level {
            flex: 1;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            overflow: hidden;
        }

        .mic-level-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--green), var(--yellow), var(--red));
            transition: width 0.05s;
        }

        .voice-effects { margin-top: 12px; }

        .effect-label {
            font-size: 0.85rem;
            font-weight: bold;
            color: #666;
            margin-bottom: 8px;
            display: block;
        }

        .effect-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
        }

        .effect-chip {
            padding: 8px 14px;
            border: 2px solid #e0e0e0;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: bold;
            cursor: pointer;
            background: white;
            color: #666;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .effect-chip:hover { border-color: var(--purple); color: var(--purple); }
        .effect-chip.active { background: var(--purple); border-color: var(--purple); color: white; }

        .effect-slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 8px;
        }

        .effect-slider-label {
            font-size: 0.85rem;
            font-weight: bold;
            min-width: 70px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .effect-slider {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
            border-radius: 3px;
        }

        .effect-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--purple);
            border-radius: 50%;
            cursor: pointer;
        }

        .effect-slider-value {
            font-size: 0.8rem;
            font-weight: bold;
            min-width: 40px;
            text-align: right;
            color: var(--purple);
        }

        .mic-recording-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-top: 10px;
        }

        .mic-recording-item audio { flex: 1; height: 36px; }

        .mic-recording-item .delete-btn {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            background: var(--red);
            color: white;
            cursor: pointer;
        }

        .monitor-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: #f0f8ff;
            border-radius: 10px;
            margin-bottom: 12px;
            border: 2px solid var(--blue);
        }

        .tempo-row {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 12px;
        }

        .tempo-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: linear-gradient(90deg, var(--blue), var(--purple));
            border-radius: 4px;
        }

        .tempo-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .tempo-value { font-weight: bold; min-width: 70px; text-align: right; }

        .recording-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            background: #f8f9fa;
            border-radius: 12px;
            margin-bottom: 12px;
            font-size: 0.9rem;
        }

        .recording-status.active { background: #ffe0e0; color: var(--red); }

        .rec-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ccc;
        }

        .recording-status.active .rec-dot {
            background: var(--red);
            animation: rec-blink 1s infinite;
        }

        @keyframes rec-blink { 50% { opacity: 0.3; } }

        .saved-recordings { margin-top: 12px; }

        .saved-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: #f8f9fa;
            border-radius: 10px;
            margin-bottom: 6px;
            font-size: 0.9rem;
        }

        .saved-item button {
            width: 32px;
            height: 32px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .saved-item .play { background: var(--green); color: white; }
        .saved-item .delete { background: var(--red); color: white; }

        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
        }

        .confetti {
            position: absolute;
            animation: confetti-fall 3s ease-out forwards;
        }

        @keyframes confetti-fall {
            0% { transform: translateY(-10px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        .status-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 14px 28px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 50px;
            font-size: 1rem;
            z-index: 1000;
            transition: transform 0.3s ease;
            pointer-events: none;
        }

        .status-toast.show { transform: translateX(-50%) translateY(0); }

        .footer {
            text-align: center;
            padding: 30px 20px;
            color: white;
            opacity: 0.8;
            font-size: 0.95rem;
            position: relative;
            z-index: 1;
        }

        @media (max-width: 600px) {
            .header-content { flex-direction: column; gap: 12px; }
            .header-controls { width: 100%; justify-content: space-between; }
            .volume-control { flex: 1; }
            .visualizer-canvas { height: 70px; }
            .bento-card.large { grid-column: span 2; }
        }

        /* SOUND EFFECTS PANEL - For editing individual sounds */
        .sound-fx-panel {
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(102, 126, 234, 0.98) 0%, rgba(118, 75, 162, 0.98) 100%);
            backdrop-filter: blur(20px);
            border-radius: 24px 24px 0 0;
            padding: 20px;
            z-index: 500;
            box-shadow: 0 -10px 40px rgba(0,0,0,0.3);
            animation: slideUp 0.3s ease;
            max-height: 70vh;
            overflow-y: auto;
        }

        .sound-fx-panel.show { display: block; }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .fx-panel-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255,255,255,0.2);
        }

        .fx-panel-title {
            display: flex;
            align-items: center;
            gap: 12px;
            color: white;
            font-size: 1.3rem;
            font-weight: bold;
        }

        .fx-panel-title .sound-emoji {
            font-size: 2.5rem;
            background: rgba(255,255,255,0.2);
            padding: 10px;
            border-radius: 16px;
        }

        .fx-panel-close {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .fx-controls {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        @media (min-width: 600px) {
            .fx-controls { grid-template-columns: repeat(4, 1fr); }
        }

        .fx-control-item {
            background: rgba(255,255,255,0.15);
            border-radius: 16px;
            padding: 15px;
            text-align: center;
        }

        .fx-control-label {
            display: block;
            color: rgba(255,255,255,0.8);
            font-size: 0.85rem;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .fx-control-emoji {
            font-size: 1.8rem;
            display: block;
            margin-bottom: 8px;
        }

        .fx-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.3);
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .fx-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .fx-value {
            color: white;
            font-weight: bold;
            font-size: 1.1rem;
        }

        .fx-quick-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 20px;
        }

        .fx-quick-btn {
            padding: 14px 20px;
            border: none;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }

        .fx-quick-btn:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 rgba(0,0,0,0.2);
        }

        .fx-quick-btn.reverse { background: #FF6B9D; color: white; }
        .fx-quick-btn.echo { background: #9B59B6; color: white; }
        .fx-quick-btn.underwater { background: #3498DB; color: white; }
        .fx-quick-btn.space { background: #1a1a2e; color: white; }
        .fx-quick-btn.chipmunk { background: #F1C40F; color: #333; }
        .fx-quick-btn.monster { background: #2ECC71; color: white; }
        .fx-quick-btn.robot { background: #7F8C8D; color: white; }
        .fx-quick-btn.favorite { background: #E74C3C; color: white; }
        .fx-quick-btn.favorite.active { background: #FFD700; }

        .fx-action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 15px;
        }

        .fx-action-btn {
            flex: 1;
            padding: 16px;
            border: none;
            border-radius: 16px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }

        .fx-action-btn:active {
            transform: translateY(3px);
            box-shadow: 0 1px 0 rgba(0,0,0,0.2);
        }

        .fx-action-btn.play { background: var(--green); color: white; }
        .fx-action-btn.add-mixer { background: var(--purple); color: white; }
        .fx-action-btn.stop { background: var(--red); color: white; }

        /* FAVORITES SECTION */
        .favorites-section {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 107, 157, 0.15));
            border-radius: 16px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .favorites-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .favorites-title {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .favorites-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .favorite-sound {
            width: 50px;
            height: 50px;
            border: none;
            border-radius: 12px;
            font-size: 1.5rem;
            cursor: pointer;
            position: relative;
            box-shadow: 0 3px 0 rgba(0,0,0,0.2);
        }

        .favorite-sound:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 rgba(0,0,0,0.2);
        }

        .favorite-sound .remove-fav {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--red);
            color: white;
            border: none;
            font-size: 0.7rem;
            cursor: pointer;
            display: none;
        }

        .favorite-sound:hover .remove-fav { display: block; }

        .favorites-empty {
            color: #999;
            font-size: 0.85rem;
            padding: 10px;
        }

        /* SCENE MODES */
        .scene-modes {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 15px;
        }

        .scene-mode-btn {
            padding: 10px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            background: white;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .scene-mode-btn:hover { border-color: var(--purple); }
        .scene-mode-btn.active {
            background: var(--purple);
            color: white;
            border-color: var(--purple);
            box-shadow: 0 4px 15px rgba(155, 89, 182, 0.4);
        }

        /* SEQUENCER */
        .mini-sequencer {
            background: linear-gradient(135deg, rgba(26, 188, 156, 0.1), rgba(52, 152, 219, 0.1));
            border-radius: 16px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .sequencer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 12px;
        }

        .sequencer-title {
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .sequencer-controls {
            display: flex;
            gap: 8px;
        }

        .seq-btn {
            width: 36px;
            height: 36px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1rem;
        }

        .seq-btn.play { background: var(--green); color: white; }
        .seq-btn.stop { background: var(--red); color: white; }
        .seq-btn.clear { background: #ddd; color: #666; }

        .sequencer-grid {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            padding: 10px 0;
        }

        .seq-step {
            width: 40px;
            height: 50px;
            border: 2px dashed #ccc;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
            cursor: pointer;
            background: white;
            flex-shrink: 0;
            transition: all 0.2s ease;
        }

        .seq-step.filled {
            border-style: solid;
            border-color: var(--purple);
            background: linear-gradient(135deg, rgba(155, 89, 182, 0.1), rgba(102, 126, 234, 0.1));
        }

        .seq-step.playing {
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--purple);
        }

        .seq-step.empty::after {
            content: '+';
            color: #ccc;
            font-size: 1.5rem;
        }

        .seq-step.drag-over {
            border-color: var(--green);
            border-style: solid;
            background: rgba(46, 204, 113, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 15px var(--green);
        }

        .sound-btn.dragging {
            opacity: 0.5;
            transform: scale(0.9);
        }

        .sound-btn[draggable="true"] {
            cursor: grab;
        }

        .sound-btn[draggable="true"]:active {
            cursor: grabbing;
        }

        /* Sound button with edit indicator */
        .sound-btn.has-fx::before {
            content: 'âš¡';
            position: absolute;
            top: -5px;
            right: -5px;
            font-size: 0.8rem;
            background: var(--purple);
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    </style>
</head>
<body>
    <div class="bubbles" id="bubbles"></div>
    <div class="confetti-container" id="confetti"></div>
    <div class="status-toast" id="statusToast"></div>

    <header class="top-header">
        <div class="header-content">
            <div class="logo-section">
                <h1>Julia's Playbox</h1>
            </div>
            <div class="main-tabs">
                <button class="main-tab active" onclick="switchMainTab('music', this)">
                    <span class="tab-icon">ðŸŽµ</span>
                    <span>Music</span>
                </button>
                <button class="main-tab" onclick="switchMainTab('paint', this)">
                    <span class="tab-icon">ðŸŽ¨</span>
                    <span>Paint</span>
                </button>
            </div>
            <div class="header-controls">
                <div class="volume-control" id="musicControls">
                    <span>ðŸ”Š</span>
                    <input type="range" class="volume-slider" id="volumeSlider" min="0" max="100" value="80">
                </div>
                <button class="settings-toggle" id="settingsToggle" onclick="toggleSettingsPanel()">
                    <span>âš™ï¸</span>
                    <span>Settings</span>
                </button>
            </div>
        </div>
    </header>

    <!-- MUSIC TAB -->
    <div class="tab-content active" id="musicTab">
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-content">
                <div class="setting-item">
                    <span>ðŸŽ† Effects</span>
                    <div class="toggle on" id="toggleEffects" onclick="toggleSetting('effects', this)"></div>
                </div>
                <div class="setting-item">
                    <span>ðŸ«§ Bubbles</span>
                    <div class="toggle on" id="toggleBubbles" onclick="toggleSetting('bubbles', this)"></div>
                </div>
                <div class="setting-item">
                    <span>ðŸŽ‰ Confetti</span>
                    <div class="toggle on" id="toggleConfetti" onclick="toggleSetting('confetti', this)"></div>
                </div>
            </div>
        </div>

        <section class="visualizer-section">
        <div class="visualizer-container">
            <canvas class="visualizer-canvas" id="visualizer"></canvas>
        </div>
    </section>

    <main class="main-content">
        <div class="bento-grid">
            <!-- Music Instruments Card - Full Width -->
            <div class="bento-card full">
                <div class="card-header">
                    <div class="card-title">
                        <span class="card-icon">ðŸŽ¼</span>
                        <span class="card-name">Music Instruments</span>
                    </div>
                    <button class="more-btn" onclick="toggleMore(this)">+</button>
                </div>
                <div class="card-content">
                    <div class="instrument-selector">
                        <button class="instrument-chip active" onclick="switchInstrument('piano', this)">
                            <span class="chip-icon">ðŸŽ¹</span> Piano
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('drums', this)">
                            <span class="chip-icon">ðŸ¥</span> Drums
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('xylophone', this)">
                            <span class="chip-icon">ðŸŽµ</span> Xylophone
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('guitar', this)">
                            <span class="chip-icon">ðŸŽ¸</span> Guitar
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('harp', this)">
                            <span class="chip-icon">ðŸª•</span> Harp
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('kalimba', this)">
                            <span class="chip-icon">ðŸª˜</span> Kalimba
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('steeldrums', this)">
                            <span class="chip-icon">ðŸª©</span> Steel Drums
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('organ', this)">
                            <span class="chip-icon">â›ª</span> Organ
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('marimba', this)">
                            <span class="chip-icon">ðŸŽ¶</span> Marimba
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('flute', this)">
                            <span class="chip-icon">ðŸŽ</span> Flute
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('bells', this)">
                            <span class="chip-icon">ðŸ””</span> Bells
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('bass', this)">
                            <span class="chip-icon">ðŸŽ»</span> Bass
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('synth', this)">
                            <span class="chip-icon">ðŸŽ›ï¸</span> Synth
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('chimes', this)">
                            <span class="chip-icon">ðŸŽ</span> Music Box
                        </button>
                        <button class="instrument-chip" onclick="switchInstrument('trumpet', this)">
                            <span class="chip-icon">ðŸŽº</span> Trumpet
                        </button>
                    </div>
                    <div id="instrument-piano" class="instrument-area">
                        <div class="piano-container">
                            <div class="piano" id="piano"></div>
                        </div>
                    </div>
                    <div id="instrument-drums" class="instrument-area" style="display:none;">
                        <div class="drum-grid" id="drumPads"></div>
                    </div>
                    <div id="instrument-xylophone" class="instrument-area" style="display:none;">
                        <div class="xylo-grid" id="xylophone"></div>
                    </div>
                    <div id="instrument-guitar" class="instrument-area" style="display:none;">
                        <div class="guitar-grid" id="guitarStrings"></div>
                    </div>
                    <div id="instrument-harp" class="instrument-area" style="display:none;">
                        <div class="harp-grid" id="harpStrings"></div>
                    </div>
                    <div id="instrument-kalimba" class="instrument-area" style="display:none;">
                        <div class="kalimba-grid" id="kalimbaKeys"></div>
                    </div>
                    <div id="instrument-steeldrums" class="instrument-area" style="display:none;">
                        <div class="steeldrums-grid" id="steelDrums"></div>
                    </div>
                    <div id="instrument-organ" class="instrument-area" style="display:none;">
                        <div class="organ-grid" id="organKeys"></div>
                    </div>
                    <div id="instrument-marimba" class="instrument-area" style="display:none;">
                        <div class="marimba-grid" id="marimbaKeys"></div>
                    </div>
                    <div id="instrument-flute" class="instrument-area" style="display:none;">
                        <div class="flute-grid" id="fluteNotes"></div>
                    </div>
                    <div id="instrument-bells" class="instrument-area" style="display:none;">
                        <div class="bells-grid" id="bellsGrid"></div>
                    </div>
                    <div id="instrument-bass" class="instrument-area" style="display:none;">
                        <div class="bass-grid" id="bassGrid"></div>
                    </div>
                    <div id="instrument-synth" class="instrument-area" style="display:none;">
                        <div class="synth-grid" id="synthGrid"></div>
                    </div>
                    <div id="instrument-chimes" class="instrument-area" style="display:none;">
                        <div class="chimes-grid" id="chimesKeys"></div>
                    </div>
                    <div id="instrument-trumpet" class="instrument-area" style="display:none;">
                        <div class="trumpet-grid" id="trumpetNotes"></div>
                    </div>
                </div>
                <div class="card-more">
                    <p style="font-size: 0.85rem; color: #666; margin-bottom: 10px;">Keyboard shortcuts (Piano):</p>
                    <p style="font-size: 0.8rem; color: #888;">White keys: A S D F G H J K | Black keys: W E T Y U</p>
                    <p style="font-size: 0.85rem; color: #666; margin: 10px 0 5px;">15 instruments to explore!</p>
                    <p style="font-size: 0.8rem; color: #888;">Piano, Drums, Xylophone, Guitar, Harp, Kalimba, Steel Drums, Organ, Marimba, Flute, Bells, Bass, Synth, Music Box & Trumpet</p>
                </div>
            </div>

            <!-- Fun Sounds Card -->
            <div class="bento-card large">
                <div class="card-header">
                    <div class="card-title">
                        <span class="card-icon">ðŸŽ‰</span>
                        <span class="card-name">Fun Sounds</span>
                        <span id="soundLoadingIndicator" style="font-size: 0.7rem; color: #999; display: none;">Loading...</span>
                    </div>
                    <button class="more-btn" onclick="toggleMore(this)">+</button>
                </div>
                <div class="card-content">
                    <!-- Scene Modes - Fun effect presets -->
                    <div class="scene-modes">
                        <button class="scene-mode-btn active" onclick="setSceneMode('normal', this)">ðŸŽµ Normal</button>
                        <button class="scene-mode-btn" onclick="setSceneMode('underwater', this)">ðŸŒŠ Underwater</button>
                        <button class="scene-mode-btn" onclick="setSceneMode('space', this)">ðŸš€ Space</button>
                        <button class="scene-mode-btn" onclick="setSceneMode('cave', this)">ðŸ¦‡ Cave</button>
                        <button class="scene-mode-btn" onclick="setSceneMode('fairy', this)">ðŸ§š Fairy</button>
                    </div>

                    <div class="sound-controls">
                        <button class="sound-control-btn" id="loopModeBtn" onclick="toggleLoopMode()">ðŸ” Loop</button>
                        <button class="sound-control-btn" onclick="openLoopSettings()">âš™ï¸ Settings</button>
                        <button class="sound-control-btn" onclick="stopAllSounds()">â¹ï¸ Stop All</button>
                        <button class="sound-control-btn" id="mixerToggleBtn" onclick="toggleMixer()">ðŸŽšï¸ Mixer</button>
                        <button class="sound-control-btn" id="editModeBtn" onclick="toggleEditMode()">âœï¸ Edit</button>
                    </div>

                    <!-- Favorites Section -->
                    <div class="favorites-section" id="favoritesSection">
                        <div class="favorites-header">
                            <span class="favorites-title">â­ Julia's Favorites</span>
                        </div>
                        <div class="favorites-grid" id="favoritesGrid">
                            <span class="favorites-empty">Long-press any sound to add to favorites!</span>
                        </div>
                    </div>

                    <!-- Mini Sequencer -->
                    <div class="mini-sequencer">
                        <div class="sequencer-header">
                            <span class="sequencer-title">ðŸŽ¼ Beat Maker</span>
                            <div class="sequencer-controls">
                                <button class="seq-btn play" onclick="playSequence()">â–¶ï¸</button>
                                <button class="seq-btn stop" onclick="stopSequence()">â¹ï¸</button>
                                <button class="seq-btn clear" onclick="clearSequence()">ðŸ—‘ï¸</button>
                            </div>
                        </div>
                        <div class="sequencer-grid" id="sequencerGrid">
                            <!-- Steps will be generated by JS -->
                        </div>
                    </div>

                    <!-- Sound Mixer -->
                    <div class="sound-mixer" id="soundMixer" style="display: none;">
                        <div class="mixer-header">
                            <div class="mixer-title">ðŸŽšï¸ Sound Mixer</div>
                            <button class="sound-control-btn" onclick="playAllMixer()" style="padding: 6px 12px; font-size: 0.8rem;">â–¶ï¸ Play All</button>
                        </div>
                        <div class="mixer-tracks" id="mixerTracks">
                            <div class="mixer-empty">Tap âž• on any sound to add it here!</div>
                        </div>
                    </div>

                    <!-- Category Tabs -->
                    <div class="category-tabs" id="categoryTabs"></div>

                    <!-- Sound Grid -->
                    <div id="soundGrid" class="category-sounds"></div>
                </div>
                <div class="card-more">
                    <p style="font-size: 0.85rem; color: #666; margin-bottom: 10px;">ðŸŽµ Real Sounds from Freesound.org!</p>
                    <p style="font-size: 0.8rem; color: #888;">â€¢ Tap a sound to play it</p>
                    <p style="font-size: 0.8rem; color: #888;">â€¢ Long-press or right-click to add to mixer</p>
                    <p style="font-size: 0.8rem; color: #888;">â€¢ Enable Loop Mode for repeating sounds</p>
                    <p style="font-size: 0.8rem; color: #888;">â€¢ Use Mixer to combine multiple sounds!</p>
                </div>
            </div>

            <!-- Loop Settings Modal -->
            <div class="loop-modal" id="loopModal">
                <div class="loop-modal-content">
                    <div class="loop-modal-header">
                        <div class="loop-modal-title">âš™ï¸ Loop Settings</div>
                        <button class="loop-modal-close" onclick="closeLoopSettings()">âœ•</button>
                    </div>

                    <div class="loop-setting">
                        <label class="loop-setting-label">ðŸ”„ Loop Count</label>
                        <div class="loop-setting-options">
                            <button class="loop-option" onclick="setLoopCount(1, this)">1Ã—</button>
                            <button class="loop-option" onclick="setLoopCount(2, this)">2Ã—</button>
                            <button class="loop-option" onclick="setLoopCount(3, this)">3Ã—</button>
                            <button class="loop-option" onclick="setLoopCount(5, this)">5Ã—</button>
                            <button class="loop-option selected" onclick="setLoopCount(-1, this)">âˆž</button>
                        </div>
                    </div>

                    <div class="loop-setting">
                        <label class="loop-setting-label">â±ï¸ Loop Interval (ms)</label>
                        <div class="loop-slider-container">
                            <input type="range" class="loop-slider" id="loopIntervalSlider" min="200" max="2000" value="500" oninput="updateLoopInterval(this.value)">
                            <span class="loop-slider-value" id="loopIntervalValue">500ms</span>
                        </div>
                    </div>

                    <div class="loop-setting">
                        <label class="loop-setting-label">ðŸŽµ Playback Speed</label>
                        <div class="loop-slider-container">
                            <input type="range" class="loop-slider" id="playbackSpeedSlider" min="50" max="200" value="100" oninput="updatePlaybackSpeed(this.value)">
                            <span class="loop-slider-value" id="playbackSpeedValue">1.0Ã—</span>
                        </div>
                    </div>

                    <div class="loop-modal-actions">
                        <button class="loop-modal-btn secondary" onclick="closeLoopSettings()">Cancel</button>
                        <button class="loop-modal-btn primary" onclick="saveLoopSettings()">Save</button>
                    </div>
                </div>
            </div>

            <!-- Music Tracks Card -->
            <div class="bento-card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="card-icon">ðŸŽ¸</span>
                        <span class="card-name">Music Tracks</span>
                    </div>
                    <button class="more-btn" onclick="toggleMore(this)">+</button>
                </div>
                <div class="card-content">
                    <div class="track-grid" id="trackList"></div>
                </div>
                <div class="card-more">
                    <div class="tempo-row">
                        <span>ðŸŽµ</span>
                        <input type="range" class="tempo-slider" id="tempoSlider" min="60" max="180" value="120">
                        <span class="tempo-value" id="tempoValue">120 BPM</span>
                    </div>
                </div>
            </div>

            <!-- Voice Changer Card -->
            <div class="bento-card large">
                <div class="card-header">
                    <div class="card-title">
                        <span class="card-icon">ðŸŽ¤</span>
                        <span class="card-name">Voice Changer</span>
                    </div>
                    <button class="more-btn" onclick="toggleMore(this)">+</button>
                </div>
                <div class="card-content">
                    <div class="mic-status-bar">
                        <div class="mic-dot" id="micDot"></div>
                        <span id="micStatus" style="font-size: 0.85rem; flex-shrink: 0;">Not connected</span>
                        <div class="mic-level">
                            <div class="mic-level-fill" id="micLevel"></div>
                        </div>
                    </div>
                    <div class="card-actions" style="margin-bottom: 12px;">
                        <button class="action-btn green" id="micConnectBtn" onclick="connectMicrophone()">ðŸŽ¤ Connect</button>
                        <button class="action-btn red" id="micRecordBtn" onclick="toggleMicRecording()" disabled>âºï¸ Record</button>
                        <button class="action-btn orange" id="micStopBtn" onclick="disconnectMicrophone()" disabled>â¹ï¸ Stop</button>
                    </div>
                    <div class="monitor-toggle" id="monitorToggle">
                        <span style="font-size: 1.2rem;">ðŸŽ§</span>
                        <div style="flex: 1;">
                            <label style="display: block;">Hear yourself (with effects!)</label>
                            <span style="font-size: 0.75rem; color: #666;">Use headphones to avoid feedback</span>
                        </div>
                        <div class="toggle" id="monitorSwitch" onclick="toggleMonitor()"></div>
                    </div>
                    <div class="voice-effects">
                        <span class="effect-label">ðŸŽ­ Voice Effects:</span>
                        <div class="effect-chips">
                            <button class="effect-chip active" onclick="setVoiceEffect('normal', this)">ðŸ˜Š Normal</button>
                            <button class="effect-chip" onclick="setVoiceEffect('robot', this)">ðŸ¤– Robot</button>
                            <button class="effect-chip" onclick="setVoiceEffect('chipmunk', this)">ðŸ¿ï¸ Chipmunk</button>
                            <button class="effect-chip" onclick="setVoiceEffect('monster', this)">ðŸ‘¹ Monster</button>
                            <button class="effect-chip" onclick="setVoiceEffect('echo', this)">ðŸ”Š Echo</button>
                            <button class="effect-chip" onclick="setVoiceEffect('alien', this)">ðŸ‘½ Alien</button>
                        </div>
                    </div>
                </div>
                <div class="card-more">
                    <div class="effect-slider-row">
                        <span class="effect-slider-label">ðŸŽšï¸ Pitch</span>
                        <input type="range" class="effect-slider" id="pitchSlider" min="-12" max="12" value="0" oninput="updatePitch(this.value)">
                        <span class="effect-slider-value" id="pitchValue">0</span>
                    </div>
                    <div class="effect-slider-row">
                        <span class="effect-slider-label">ðŸ” Echo</span>
                        <input type="range" class="effect-slider" id="echoSlider" min="0" max="100" value="0" oninput="updateEcho(this.value)">
                        <span class="effect-slider-value" id="echoValue">0%</span>
                    </div>
                    <div class="effect-slider-row">
                        <span class="effect-slider-label">â±ï¸ Delay</span>
                        <input type="range" class="effect-slider" id="delaySlider" min="0" max="500" value="0" oninput="updateDelay(this.value)">
                        <span class="effect-slider-value" id="delayValue">0ms</span>
                    </div>
                    <div class="effect-slider-row">
                        <span class="effect-slider-label">ðŸŒŠ Reverb</span>
                        <input type="range" class="effect-slider" id="reverbSlider" min="0" max="100" value="0" oninput="updateReverb(this.value)">
                        <span class="effect-slider-value" id="reverbValue">0%</span>
                    </div>
                    <div class="effect-slider-row">
                        <span class="effect-slider-label">ðŸ“¢ Gain</span>
                        <input type="range" class="effect-slider" id="gainSlider" min="0" max="200" value="100" oninput="updateGain(this.value)">
                        <span class="effect-slider-value" id="gainValue">100%</span>
                    </div>
                    <p style="font-size: 0.85rem; font-weight: bold; color: #666; margin: 15px 0 10px;">ðŸŽ™ï¸ Recordings:</p>
                    <div id="micRecordings"></div>
                </div>
            </div>

            <!-- Record Notes Card -->
            <div class="bento-card">
                <div class="card-header">
                    <div class="card-title">
                        <span class="card-icon">ðŸŽ™ï¸</span>
                        <span class="card-name">Record Notes</span>
                    </div>
                    <button class="more-btn" onclick="toggleMore(this)">+</button>
                </div>
                <div class="card-content">
                    <div class="recording-status" id="recStatus">
                        <div class="rec-dot"></div>
                        <span>Ready to record your music</span>
                    </div>
                    <div class="card-actions">
                        <button class="action-btn red" id="recBtn" onclick="toggleRecording()">âºï¸ Record</button>
                        <button class="action-btn green" onclick="playRecording()">â–¶ï¸ Play</button>
                        <button class="action-btn orange" onclick="clearRecording()">ðŸ—‘ï¸</button>
                    </div>
                </div>
                <div class="card-more">
                    <p style="font-size: 0.85rem; color: #666; margin-bottom: 10px;">Saved recordings:</p>
                    <div class="saved-recordings" id="savedRecordings"></div>
                </div>
            </div>
        </div>
    </main>

    <!-- Sound Effects Panel - Opens when editing a sound -->
    <div class="sound-fx-panel" id="soundFxPanel">
        <div class="fx-panel-header">
            <div class="fx-panel-title">
                <span class="sound-emoji" id="fxPanelEmoji">ðŸ±</span>
                <div>
                    <span id="fxPanelName">Cat</span>
                    <div style="font-size: 0.8rem; opacity: 0.8;">Edit this sound!</div>
                </div>
            </div>
            <button class="fx-panel-close" onclick="closeFxPanel()">âœ•</button>
        </div>

        <!-- Quick Effect Buttons -->
        <div class="fx-quick-buttons">
            <button class="fx-quick-btn reverse" onclick="applyQuickFx('reverse')">âª Reverse</button>
            <button class="fx-quick-btn echo" onclick="applyQuickFx('echo')">ðŸ”Š Echo</button>
            <button class="fx-quick-btn underwater" onclick="applyQuickFx('underwater')">ðŸŒŠ Underwater</button>
            <button class="fx-quick-btn space" onclick="applyQuickFx('space')">ðŸš€ Space</button>
            <button class="fx-quick-btn chipmunk" onclick="applyQuickFx('chipmunk')">ðŸ¿ï¸ Chipmunk</button>
            <button class="fx-quick-btn monster" onclick="applyQuickFx('monster')">ðŸ‘¹ Monster</button>
            <button class="fx-quick-btn robot" onclick="applyQuickFx('robot')">ðŸ¤– Robot</button>
            <button class="fx-quick-btn favorite" id="fxFavoriteBtn" onclick="toggleFavorite()">â­ Favorite</button>
        </div>

        <!-- Detailed Controls -->
        <div class="fx-controls">
            <div class="fx-control-item">
                <span class="fx-control-emoji">ðŸŽµ</span>
                <label class="fx-control-label">Pitch</label>
                <input type="range" class="fx-slider" id="fxPitchSlider" min="-12" max="12" value="0" oninput="updateFxPitch(this.value)">
                <span class="fx-value" id="fxPitchValue">0</span>
            </div>
            <div class="fx-control-item">
                <span class="fx-control-emoji">ðŸƒ</span>
                <label class="fx-control-label">Speed</label>
                <input type="range" class="fx-slider" id="fxSpeedSlider" min="25" max="200" value="100" oninput="updateFxSpeed(this.value)">
                <span class="fx-value" id="fxSpeedValue">1.0x</span>
            </div>
            <div class="fx-control-item">
                <span class="fx-control-emoji">ðŸ”Š</span>
                <label class="fx-control-label">Echo</label>
                <input type="range" class="fx-slider" id="fxEchoSlider" min="0" max="100" value="0" oninput="updateFxEcho(this.value)">
                <span class="fx-value" id="fxEchoValue">0%</span>
            </div>
            <div class="fx-control-item">
                <span class="fx-control-emoji">ðŸ”‰</span>
                <label class="fx-control-label">Volume</label>
                <input type="range" class="fx-slider" id="fxVolumeSlider" min="0" max="150" value="100" oninput="updateFxVolume(this.value)">
                <span class="fx-value" id="fxVolumeValue">100%</span>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="fx-action-buttons">
            <button class="fx-action-btn play" onclick="playWithFx()">â–¶ï¸ Play</button>
            <button class="fx-action-btn add-mixer" onclick="addToMixerWithFx()">ðŸŽšï¸ Add to Mixer</button>
            <button class="fx-action-btn stop" onclick="stopCurrentFx()">â¹ï¸ Stop</button>
        </div>
    </div>
    </div><!-- END MUSIC TAB -->

    <!-- PAINT TAB -->
    <div class="tab-content" id="paintTab">
        <div class="paint-container">
            <!-- Paint Sub-Tabs -->
            <div class="paint-sub-tabs">
                <button class="paint-sub-tab active" onclick="switchPaintMode('freedraw', this)">
                    <span class="sub-tab-icon">ðŸ–Œï¸</span> Free Draw
                </button>
                <button class="paint-sub-tab" onclick="switchPaintMode('colorphoto', this)">
                    <span class="sub-tab-icon">ðŸ“¸</span> Color a Photo
                </button>
                <button class="paint-sub-tab" onclick="switchPaintMode('coloringbook', this)">
                    <span class="sub-tab-icon">ðŸ“–</span> Coloring Book
                </button>
            </div>

            <!-- MODE 1: Free Draw -->
            <div class="paint-mode active" id="paintMode-freedraw">
                <div class="paint-toolbar">
                    <div class="paint-colors" id="paintColors"></div>
                    <div class="brush-size-control">
                        <label>Brush:</label>
                        <input type="range" class="brush-slider" id="brushSize" min="2" max="80" value="15">
                        <div class="brush-preview">
                            <div class="brush-dot" id="brushPreview"></div>
                        </div>
                    </div>
                    <div class="paint-actions">
                        <button class="paint-btn eraser" id="eraserBtn" onclick="toggleEraser()">ðŸ§¹ Eraser</button>
                        <button class="paint-btn undo" onclick="undoPaint()">â†©ï¸ Undo</button>
                        <button class="paint-btn clear" onclick="clearCanvas()">ðŸ—‘ï¸ Clear</button>
                        <button class="paint-btn save" onclick="saveCanvas()">ðŸ’¾ Save</button>
                    </div>
                </div>
                <div class="canvas-wrapper">
                    <canvas id="paintCanvas"></canvas>
                </div>
            </div>

            <!-- MODE 2: Color a Photo -->
            <div class="paint-mode" id="paintMode-colorphoto">
                <div id="photoUploadArea" class="photo-upload-area">
                    <div class="upload-content">
                        <div class="upload-icon">ðŸ“¸</div>
                        <h3>Upload a Photo!</h3>
                        <p>Drag & drop a photo here or click to choose one</p>
                        <p class="upload-hint">It will turn into a coloring page! âœ¨</p>
                        <input type="file" id="photoFileInput" accept="image/*" style="display:none">
                    </div>
                </div>
                <div id="photoEditorArea" style="display:none;">
                    <div class="paint-toolbar">
                        <div class="paint-colors" id="photoPaintColors"></div>
                        <div class="brush-size-control">
                            <label>Brush:</label>
                            <input type="range" class="brush-slider" id="photoBrushSize" min="2" max="80" value="15">
                            <div class="brush-preview">
                                <div class="brush-dot" id="photoBrushPreview"></div>
                            </div>
                        </div>
                        <div class="sensitivity-control">
                            <label>âœï¸ Detail:</label>
                            <input type="range" class="brush-slider" id="sensitivitySlider" min="10" max="200" value="80">
                        </div>
                        <div class="paint-actions">
                            <button class="paint-btn eraser" id="photoEraserBtn" onclick="togglePhotoEraser()">ðŸ§¹ Eraser</button>
                            <button class="paint-btn undo" onclick="undoPhotoCanvas()">â†©ï¸ Undo</button>
                            <button class="paint-btn" style="background:var(--cyan);color:white;" onclick="reprocessPhoto()">ðŸ”„ Re-trace</button>
                            <button class="paint-btn save" onclick="savePhotoCanvas()">ðŸ’¾ Save</button>
                            <button class="paint-btn" style="background:var(--blue);color:white;" onclick="showPhotoUpload()">ðŸ“¸ New</button>
                        </div>
                    </div>
                    <div class="canvas-wrapper" style="position:relative;">
                        <canvas id="photoCanvas"></canvas>
                        <div class="reference-thumbnail" id="photoRefThumb">
                            <div class="ref-thumb-header">
                                <span>ðŸ–¼ï¸ Original</span>
                                <button class="ref-thumb-close" onclick="togglePhotoRef()">âœ•</button>
                            </div>
                            <canvas id="photoRefCanvas"></canvas>
                        </div>
                    </div>
                    <button class="ref-toggle-btn" id="photoRefToggle" onclick="togglePhotoRef()">ðŸ‘ï¸ Hide Original</button>
                </div>
            </div>

            <!-- MODE 3: Coloring Book Gallery -->
            <div class="paint-mode" id="paintMode-coloringbook">
                <div id="coloringGallery">
                    <div class="coloring-category-tabs" id="coloringCategoryTabs"></div>
                    <div class="coloring-grid" id="coloringGrid"></div>
                </div>
                <div id="coloringEditorArea" style="display:none;">
                    <div class="paint-toolbar">
                        <div class="paint-colors" id="coloringPaintColors"></div>
                        <div class="brush-size-control">
                            <label>Brush:</label>
                            <input type="range" class="brush-slider" id="coloringBrushSize" min="2" max="80" value="15">
                            <div class="brush-preview">
                                <div class="brush-dot" id="coloringBrushPreview"></div>
                            </div>
                        </div>
                        <div class="paint-actions">
                            <button class="paint-btn eraser" id="coloringEraserBtn" onclick="toggleColoringEraser()">ðŸ§¹ Eraser</button>
                            <button class="paint-btn undo" onclick="undoColoringCanvas()">â†©ï¸ Undo</button>
                            <button class="paint-btn" style="background:var(--cyan);color:white;" onclick="reloadColoringOutline()">ðŸ”„ Start Over</button>
                            <button class="paint-btn save" onclick="saveColoringCanvas()">ðŸ’¾ Save</button>
                            <button class="paint-btn" style="background:var(--blue);color:white;" onclick="backToColoringGallery()">ðŸ“– Gallery</button>
                        </div>
                    </div>
                    <div class="canvas-wrapper" style="position:relative;">
                        <canvas id="coloringCanvas"></canvas>
                        <div class="reference-thumbnail" id="coloringRefThumb" style="display:none;">
                            <div class="ref-thumb-header">
                                <span>ðŸŽ¨ Reference</span>
                                <button class="ref-thumb-close" onclick="toggleColoringRef()">âœ•</button>
                            </div>
                            <canvas id="coloringRefCanvas"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div><!-- END PAINT TAB -->

    <footer class="footer">Made with love for Julia</footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <script>
        // ============================================
        // FREESOUND API CONFIGURATION
        // ============================================
        const FREESOUND_API_KEY = '8DEc3afcbTYBx00oJ908Ix1NIXIuRnzA2lEWldBA';
        const FREESOUND_API_URL = 'https://freesound.org/apiv2';

        // Sound categories with search queries and emojis
        const soundCategories = {
            animals: {
                name: 'ðŸ¾ Animals',
                icon: 'ðŸ¾',
                color: '#FF6B9D',
                sounds: [
                    { emoji: 'ðŸ±', name: 'Cat', query: 'cat meow', color: '#FF6B9D' },
                    { emoji: 'ðŸ¶', name: 'Dog', query: 'dog bark', color: '#9B59B6' },
                    { emoji: 'ðŸ¦', name: 'Bird', query: 'bird chirp', color: '#3498DB' },
                    { emoji: 'ðŸ¸', name: 'Frog', query: 'frog croak', color: '#2ECC71' },
                    { emoji: 'ðŸ¦', name: 'Lion', query: 'lion roar', color: '#F1C40F' },
                    { emoji: 'ðŸ„', name: 'Cow', query: 'cow moo', color: '#E67E22' },
                    { emoji: 'ðŸ·', name: 'Pig', query: 'pig squeal', color: '#FFB6C1' },
                    { emoji: 'ðŸ´', name: 'Horse', query: 'horse neigh', color: '#8B4513' },
                    { emoji: 'ðŸ¦†', name: 'Duck', query: 'duck quack', color: '#FFD700' },
                    { emoji: 'ðŸ', name: 'Bee', query: 'bee buzzing', color: '#F4D03F' },
                    { emoji: 'ðŸ¦‰', name: 'Owl', query: 'owl hoot', color: '#6C3483' },
                    { emoji: 'ðŸº', name: 'Wolf', query: 'wolf howl', color: '#5D6D7E' },
                    { emoji: 'ðŸ˜', name: 'Elephant', query: 'elephant', color: '#95A5A6' },
                    { emoji: 'ðŸ’', name: 'Monkey', query: 'monkey', color: '#D35400' },
                    { emoji: 'ðŸ”', name: 'Chicken', query: 'chicken', color: '#E74C3C' },
                    { emoji: 'ðŸ‘', name: 'Sheep', query: 'sheep', color: '#ECF0F1' },
                    { emoji: 'ðŸ', name: 'Goat', query: 'goat', color: '#BDC3C7' },
                    { emoji: 'ðŸ¦ƒ', name: 'Turkey', query: 'turkey', color: '#C0392B' }
                ]
            },
            nature: {
                name: 'ðŸŒ¿ Nature',
                icon: 'ðŸŒ¿',
                color: '#2ECC71',
                sounds: [
                    { emoji: 'ðŸŒ§ï¸', name: 'Rain', query: 'rain', color: '#3498DB' },
                    { emoji: 'â›ˆï¸', name: 'Thunder', query: 'thunder', color: '#9B59B6' },
                    { emoji: 'ðŸ’¨', name: 'Wind', query: 'wind', color: '#85C1E9' },
                    { emoji: 'ðŸŒŠ', name: 'Ocean', query: 'ocean waves', color: '#1ABC9C' },
                    { emoji: 'ðŸžï¸', name: 'River', query: 'river', color: '#3498DB' },
                    { emoji: 'ðŸ”¥', name: 'Fire', query: 'fire crackling', color: '#E74C3C' },
                    { emoji: 'ðŸŒ²', name: 'Forest', query: 'forest', color: '#27AE60' },
                    { emoji: 'ðŸ¦—', name: 'Crickets', query: 'crickets', color: '#1E8449' },
                    { emoji: 'âš¡', name: 'Lightning', query: 'lightning', color: '#F7DC6F' },
                    { emoji: 'â„ï¸', name: 'Snow', query: 'blizzard', color: '#AED6F1' },
                    { emoji: 'ðŸŒ´', name: 'Jungle', query: 'jungle', color: '#28B463' },
                    { emoji: 'ðŸœï¸', name: 'Desert', query: 'desert wind', color: '#F5B041' }
                ]
            },
            instruments: {
                name: 'ðŸŽµ Instruments',
                icon: 'ðŸŽµ',
                color: '#9B59B6',
                sounds: [
                    { emoji: 'ðŸŽº', name: 'Trumpet', query: 'trumpet', color: '#E74C3C' },
                    { emoji: 'ðŸ””', name: 'Bell', query: 'bell', color: '#1ABC9C' },
                    { emoji: 'ðŸŽ·', name: 'Saxophone', query: 'saxophone', color: '#F39C12' },
                    { emoji: 'ðŸŽ»', name: 'Violin', query: 'violin', color: '#8E44AD' },
                    { emoji: 'ðŸŽ¸', name: 'Guitar', query: 'guitar', color: '#C0392B' },
                    { emoji: 'ðŸªˆ', name: 'Flute', query: 'flute', color: '#5DADE2' },
                    { emoji: 'ðŸŽ¹', name: 'Piano', query: 'piano', color: '#2C3E50' },
                    { emoji: 'ðŸ¥', name: 'Drums', query: 'drum', color: '#E74C3C' },
                    { emoji: 'ðŸª—', name: 'Accordion', query: 'accordion', color: '#E91E63' },
                    { emoji: 'ðŸŽ¤', name: 'Vocal', query: 'choir', color: '#9C27B0' },
                    { emoji: 'ðŸª˜', name: 'Bongo', query: 'bongo', color: '#795548' },
                    { emoji: 'ðŸŽ¶', name: 'Harp', query: 'harp', color: '#FFD700' }
                ]
            },
            effects: {
                name: 'âœ¨ Effects',
                icon: 'âœ¨',
                color: '#F39C12',
                sounds: [
                    { emoji: 'ðŸ’¥', name: 'Explosion', query: 'explosion', color: '#E74C3C' },
                    { emoji: 'âœ¨', name: 'Magic', query: 'magic spell', color: '#F39C12' },
                    { emoji: 'ðŸš€', name: 'Rocket', query: 'rocket', color: '#C0392B' },
                    { emoji: 'ðŸ‘»', name: 'Ghost', query: 'ghost', color: '#BDC3C7' },
                    { emoji: 'ðŸ¤–', name: 'Robot', query: 'robot', color: '#7F8C8D' },
                    { emoji: 'ðŸ‘¾', name: 'Alien', query: 'alien', color: '#9B59B6' },
                    { emoji: 'âš”ï¸', name: 'Sword', query: 'sword', color: '#95A5A6' },
                    { emoji: 'ðŸŽƒ', name: 'Spooky', query: 'halloween', color: '#E67E22' },
                    { emoji: 'ðŸ’«', name: 'Twinkle', query: 'sparkle', color: '#F4D03F' },
                    { emoji: 'ðŸŽˆ', name: 'Pop', query: 'pop', color: '#E74C3C' },
                    { emoji: 'ðŸª„', name: 'Wand', query: 'magic wand', color: '#8E44AD' },
                    { emoji: 'ðŸ’Ž', name: 'Crystal', query: 'crystal', color: '#00BCD4' }
                ]
            },
            transport: {
                name: 'ðŸš— Transport',
                icon: 'ðŸš—',
                color: '#3498DB',
                sounds: [
                    { emoji: 'ðŸš—', name: 'Car', query: 'car engine', color: '#2980B9' },
                    { emoji: 'ðŸš‚', name: 'Train', query: 'train whistle', color: '#7F8C8D' },
                    { emoji: 'âœˆï¸', name: 'Airplane', query: 'airplane', color: '#5DADE2' },
                    { emoji: 'ðŸš', name: 'Helicopter', query: 'helicopter', color: '#1ABC9C' },
                    { emoji: 'ðŸš¢', name: 'Ship', query: 'ship horn', color: '#34495E' },
                    { emoji: 'ðŸŽï¸', name: 'Race Car', query: 'racing car', color: '#E74C3C' },
                    { emoji: 'ðŸš‘', name: 'Ambulance', query: 'ambulance', color: '#E74C3C' },
                    { emoji: 'ðŸš’', name: 'Fire Truck', query: 'fire truck', color: '#C0392B' },
                    { emoji: 'ðŸš“', name: 'Police', query: 'police siren', color: '#3498DB' },
                    { emoji: 'ðŸ›µ', name: 'Motorcycle', query: 'motorcycle', color: '#E67E22' },
                    { emoji: 'ðŸš²', name: 'Bicycle', query: 'bike bell', color: '#27AE60' },
                    { emoji: 'ðŸ›¸', name: 'UFO', query: 'ufo', color: '#9B59B6' }
                ]
            },
            fun: {
                name: 'ðŸŽ‰ Fun',
                icon: 'ðŸŽ‰',
                color: '#E91E63',
                sounds: [
                    { emoji: 'ðŸ˜‚', name: 'Laugh', query: 'laugh', color: '#F1C40F' },
                    { emoji: 'ðŸ‘', name: 'Applause', query: 'applause', color: '#E74C3C' },
                    { emoji: 'ðŸŽŠ', name: 'Party', query: 'party horn', color: '#E91E63' },
                    { emoji: 'ðŸ“¯', name: 'Fanfare', query: 'fanfare', color: '#F1C40F' },
                    { emoji: 'ðŸ¥³', name: 'Cheer', query: 'crowd cheer', color: '#9B59B6' },
                    { emoji: 'ðŸ¤£', name: 'Giggle', query: 'giggle', color: '#FF6B9D' },
                    { emoji: 'ðŸ˜®', name: 'Gasp', query: 'gasp', color: '#3498DB' },
                    { emoji: 'ðŸ¥', name: 'Rimshot', query: 'rimshot', color: '#E67E22' },
                    { emoji: 'ðŸ“¢', name: 'Airhorn', query: 'air horn', color: '#E74C3C' },
                    { emoji: 'ðŸŽµ', name: 'Whistle', query: 'whistle', color: '#2ECC71' },
                    { emoji: 'ðŸ””', name: 'Ding', query: 'ding', color: '#1ABC9C' }
                ]
            },
            household: {
                name: 'ðŸ  Household',
                icon: 'ðŸ ',
                color: '#795548',
                sounds: [
                    { emoji: 'ðŸšª', name: 'Door', query: 'door creak', color: '#8D6E63' },
                    { emoji: 'ðŸ”‘', name: 'Keys', query: 'keys', color: '#FFD700' },
                    { emoji: 'ðŸ“ž', name: 'Phone', query: 'phone ring', color: '#4CAF50' },
                    { emoji: 'â°', name: 'Alarm', query: 'alarm clock', color: '#F44336' },
                    { emoji: 'ðŸš¿', name: 'Shower', query: 'shower', color: '#2196F3' },
                    { emoji: 'ðŸ³', name: 'Cooking', query: 'frying', color: '#FF9800' },
                    { emoji: 'â˜•', name: 'Coffee', query: 'coffee', color: '#795548' },
                    { emoji: 'ðŸ’¡', name: 'Switch', query: 'switch click', color: '#FFC107' },
                    { emoji: 'ðŸ§¹', name: 'Vacuum', query: 'vacuum', color: '#607D8B' },
                    { emoji: 'ðŸ“º', name: 'TV', query: 'static', color: '#9E9E9E' },
                    { emoji: 'âŒ¨ï¸', name: 'Typing', query: 'typing', color: '#455A64' },
                    { emoji: 'ðŸ–¨ï¸', name: 'Printer', query: 'printer', color: '#78909C' }
                ]
            },
            games: {
                name: 'ðŸŽ® Games',
                icon: 'ðŸŽ®',
                color: '#00BCD4',
                sounds: [
                    { emoji: 'ðŸ†', name: 'Win', query: 'victory', color: '#FFD700' },
                    { emoji: 'ðŸ’”', name: 'Lose', query: 'game over', color: '#E74C3C' },
                    { emoji: 'â¬†ï¸', name: 'Level Up', query: 'level up', color: '#2ECC71' },
                    { emoji: 'ðŸ’°', name: 'Coin', query: 'coin', color: '#F1C40F' },
                    { emoji: 'â¤ï¸', name: 'Life', query: 'power up', color: '#E91E63' },
                    { emoji: 'ðŸ’¨', name: 'Jump', query: 'jump', color: '#3498DB' },
                    { emoji: 'ðŸ”«', name: 'Laser', query: 'laser', color: '#E74C3C' },
                    { emoji: 'ðŸ’£', name: 'Bomb', query: 'bomb', color: '#34495E' },
                    { emoji: 'ðŸŒŸ', name: 'Star', query: 'collect', color: '#F39C12' },
                    { emoji: 'ðŸŽ¯', name: 'Hit', query: 'hit', color: '#9C27B0' },
                    { emoji: 'ðŸ›¡ï¸', name: 'Shield', query: 'shield', color: '#607D8B' },
                    { emoji: 'âš¡', name: 'Power', query: 'power', color: '#FFEB3B' }
                ]
            },
            dinosaurs: {
                name: 'ðŸ¦– Dinosaurs',
                icon: 'ðŸ¦–',
                color: '#4CAF50',
                sounds: [
                    { emoji: 'ðŸ¦–', name: 'T-Rex Roar', query: 'dinosaur roar', color: '#4CAF50' },
                    { emoji: 'ðŸ¦•', name: 'Dino Call', query: 'creature call', color: '#8BC34A' },
                    { emoji: 'ðŸŠ', name: 'Raptor', query: 'raptor screech', color: '#FF5722' },
                    { emoji: 'ðŸ¦Ž', name: 'Dino Growl', query: 'monster growl', color: '#795548' },
                    { emoji: 'ðŸ‰', name: 'Dragon Roar', query: 'dragon roar', color: '#F44336' },
                    { emoji: 'ðŸ¦´', name: 'Bone Crunch', query: 'bone crack', color: '#ECEFF1' },
                    { emoji: 'ðŸ‘£', name: 'Dino Steps', query: 'heavy footsteps', color: '#6D4C41' },
                    { emoji: 'ðŸŒ‹', name: 'Volcano', query: 'volcano rumble', color: '#FF5722' },
                    { emoji: 'ðŸ¦·', name: 'Dino Bite', query: 'bite chomp', color: '#FFEB3B' },
                    { emoji: 'ðŸ¥š', name: 'Egg Crack', query: 'egg crack', color: '#FFF9C4' },
                    { emoji: 'ðŸŒ¿', name: 'Jungle Stomp', query: 'stomp impact', color: '#2E7D32' },
                    { emoji: 'ðŸ’¨', name: 'Dino Breath', query: 'monster breath', color: '#78909C' }
                ]
            }
        };

        // Sound cache and state
        const soundCache = {};
        const loadedSounds = {};
        let currentCategory = 'animals';
        let loopSettings = {
            count: -1, // -1 = infinite
            interval: 500,
            speed: 1.0
        };
        let activeSounds = {};
        let mixerSounds = [];

        // ============================================
        // FREESOUND API FUNCTIONS
        // ============================================
        async function searchFreesound(query) {
            const cacheKey = query.toLowerCase().replace(/\s+/g, '_');
            if (soundCache[cacheKey]) {
                return soundCache[cacheKey];
            }

            try {
                const response = await fetch(
                    `${FREESOUND_API_URL}/search/text/?query=${encodeURIComponent(query)}&token=${FREESOUND_API_KEY}&fields=id,name,previews&page_size=5&filter=duration:[0.1 TO 10]`
                );
                const data = await response.json();

                if (data.results && data.results.length > 0) {
                    const sound = data.results[0];
                    soundCache[cacheKey] = {
                        id: sound.id,
                        name: sound.name,
                        url: sound.previews['preview-hq-mp3']
                    };
                    return soundCache[cacheKey];
                }
            } catch (error) {
                console.error('Freesound API error:', error);
            }
            return null;
        }

        async function loadSound(soundInfo) {
            const cacheKey = soundInfo.query.toLowerCase().replace(/\s+/g, '_');

            if (loadedSounds[cacheKey]) {
                return loadedSounds[cacheKey];
            }

            const freesoundData = await searchFreesound(soundInfo.query);
            if (!freesoundData) return null;

            return new Promise((resolve) => {
                const howl = new Howl({
                    src: [freesoundData.url],
                    html5: false,
                    format: ['mp3'],
                    volume: 0.8,
                    rate: loopSettings.speed,
                    onload: () => {
                        loadedSounds[cacheKey] = howl;
                        resolve(howl);
                    },
                    onloaderror: (id, err) => {
                        console.error('Failed to load sound:', soundInfo.name, err);
                        resolve(null);
                    }
                });
            });
        }

        async function playSound(soundInfo, btn) {
            btn.classList.add('loading');

            try {
                let howl = await loadSound(soundInfo);
                if (!howl) {
                    showStatus('Sound not available');
                    btn.classList.remove('loading');
                    return;
                }

                btn.classList.remove('loading');
                btn.classList.add('playing');
                setTimeout(() => btn.classList.remove('playing'), 500);

                const cacheKey = soundInfo.query.toLowerCase().replace(/\s+/g, '_');

                // Stop existing sound if playing
                if (activeSounds[cacheKey]) {
                    clearInterval(activeSounds[cacheKey].interval);
                    activeSounds[cacheKey].howl.stop();
                    delete activeSounds[cacheKey];
                    btn.classList.remove('looping');
                    showStatus(`Stopped: ${soundInfo.name}`);
                    return;
                }

                howl.rate(loopSettings.speed);
                howl.play();

                if (loopMode) {
                    let playCount = 1;
                    const maxCount = loopSettings.count;

                    const intervalId = setInterval(() => {
                        if (maxCount !== -1 && playCount >= maxCount) {
                            clearInterval(intervalId);
                            delete activeSounds[cacheKey];
                            btn.classList.remove('looping');
                            showStatus(`Finished: ${soundInfo.name}`);
                            return;
                        }
                        howl.play();
                        playCount++;
                    }, loopSettings.interval);

                    activeSounds[cacheKey] = { howl, interval: intervalId, info: soundInfo };
                    btn.classList.add('looping');
                    showStatus(`Looping: ${soundInfo.name}`);
                } else {
                    showStatus(`Playing: ${soundInfo.name}`);
                }

                if (state.settings.confetti) spawnConfetti(3);

            } catch (error) {
                console.error('Error playing sound:', error);
                btn.classList.remove('loading');
                showStatus('Error playing sound');
            }
        }

        function stopAllSounds() {
            Object.keys(activeSounds).forEach(key => {
                clearInterval(activeSounds[key].interval);
                activeSounds[key].howl.stop();
            });
            activeSounds = {};
            document.querySelectorAll('.sound-btn.looping').forEach(btn => btn.classList.remove('looping'));

            // Stop mixer sounds too
            mixerSounds.forEach(ms => {
                if (ms.howl) ms.howl.stop();
            });

            showStatus('All sounds stopped');
        }

        // ============================================
        // LOOP SETTINGS
        // ============================================
        function openLoopSettings() {
            document.getElementById('loopModal').classList.add('show');
        }

        function closeLoopSettings() {
            document.getElementById('loopModal').classList.remove('show');
        }

        function setLoopCount(count, btn) {
            document.querySelectorAll('.loop-setting-options .loop-option').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            loopSettings.count = count;
        }

        function updateLoopInterval(value) {
            loopSettings.interval = parseInt(value);
            document.getElementById('loopIntervalValue').textContent = value + 'ms';
        }

        function updatePlaybackSpeed(value) {
            const speed = parseInt(value) / 100;
            loopSettings.speed = speed;
            document.getElementById('playbackSpeedValue').textContent = speed.toFixed(1) + 'Ã—';

            // Update all active sounds
            Object.values(loadedSounds).forEach(howl => {
                if (howl) howl.rate(speed);
            });
        }

        function saveLoopSettings() {
            closeLoopSettings();
            showStatus(`Loop: ${loopSettings.count === -1 ? 'âˆž' : loopSettings.count + 'Ã—'} @ ${loopSettings.interval}ms`);
        }

        // ============================================
        // MIXER FUNCTIONS
        // ============================================
        function toggleMixer() {
            const mixer = document.getElementById('soundMixer');
            const btn = document.getElementById('mixerToggleBtn');
            const isVisible = mixer.style.display !== 'none';
            mixer.style.display = isVisible ? 'none' : 'block';
            btn.classList.toggle('active', !isVisible);
        }

        function addToMixer(soundInfo) {
            // Check if already in mixer
            if (mixerSounds.find(s => s.query === soundInfo.query)) {
                showStatus(`${soundInfo.name} already in mixer`);
                return;
            }

            mixerSounds.push({
                ...soundInfo,
                volume: 0.8,
                howl: null
            });

            renderMixer();
            showStatus(`Added ${soundInfo.name} to mixer`);

            // Show mixer if hidden
            document.getElementById('soundMixer').style.display = 'block';
            document.getElementById('mixerToggleBtn').classList.add('active');
        }

        function removeFromMixer(index) {
            if (mixerSounds[index].howl) {
                mixerSounds[index].howl.stop();
            }
            mixerSounds.splice(index, 1);
            renderMixer();
        }

        function updateMixerVolume(index, value) {
            mixerSounds[index].volume = parseFloat(value);
            if (mixerSounds[index].howl) {
                mixerSounds[index].howl.volume(mixerSounds[index].volume);
            }
        }

        async function playMixerSound(index) {
            const ms = mixerSounds[index];
            if (!ms.howl) {
                ms.howl = await loadSound(ms);
            }
            if (ms.howl) {
                ms.howl.volume(ms.volume);
                ms.howl.play();
            }
        }

        function stopMixerSound(index) {
            if (mixerSounds[index].howl) {
                mixerSounds[index].howl.stop();
            }
        }

        async function playAllMixer() {
            for (let i = 0; i < mixerSounds.length; i++) {
                await playMixerSound(i);
            }
            showStatus('Playing mixer sounds!');
        }

        function renderMixer() {
            const container = document.getElementById('mixerTracks');

            if (mixerSounds.length === 0) {
                container.innerHTML = '<div class="mixer-empty">Tap âž• on any sound to add it here!</div>';
                return;
            }

            container.innerHTML = mixerSounds.map((ms, i) => `
                <div class="mixer-track">
                    <span class="mixer-track-emoji">${ms.emoji}</span>
                    <span class="mixer-track-name">${ms.name}</span>
                    <div class="mixer-track-controls">
                        <input type="range" class="mixer-volume" min="0" max="1" step="0.1" value="${ms.volume}" onchange="updateMixerVolume(${i}, this.value)">
                        <button class="mixer-btn play" onclick="playMixerSound(${i})">â–¶</button>
                        <button class="mixer-btn stop" onclick="stopMixerSound(${i})">â¹</button>
                        <button class="mixer-btn remove" onclick="removeFromMixer(${i})">âœ•</button>
                    </div>
                </div>
            `).join('');
        }

        // ============================================
        // SCENE MODES - Fun effect presets for all sounds
        // ============================================
        let currentSceneMode = 'normal';
        const sceneModes = {
            normal: { speed: 1.0, pitch: 0, echo: 0, filter: 20000 },
            underwater: { speed: 0.7, pitch: -3, echo: 60, filter: 800 },
            space: { speed: 0.5, pitch: 5, echo: 80, filter: 2000 },
            cave: { speed: 0.9, pitch: -2, echo: 90, filter: 1500 },
            fairy: { speed: 1.3, pitch: 7, echo: 30, filter: 10000 }
        };

        function setSceneMode(mode, btn) {
            currentSceneMode = mode;
            document.querySelectorAll('.scene-mode-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            const settings = sceneModes[mode];
            loopSettings.speed = settings.speed;

            // Update all loaded sounds
            Object.values(loadedSounds).forEach(howl => {
                if (howl) howl.rate(settings.speed);
            });

            showStatus(`Scene: ${mode.charAt(0).toUpperCase() + mode.slice(1)} mode!`);
            if (state.settings.confetti) spawnConfetti(5);
        }

        // ============================================
        // EDIT MODE & SOUND FX PANEL
        // ============================================
        let editMode = false;
        let currentEditSound = null;
        let currentEditHowl = null;
        let soundFxSettings = { pitch: 0, speed: 100, echo: 0, volume: 100 };

        function toggleEditMode() {
            editMode = !editMode;
            document.getElementById('editModeBtn').classList.toggle('active', editMode);
            showStatus(editMode ? 'âœï¸ Edit Mode ON - Tap any sound to edit!' : 'âœï¸ Edit Mode OFF');
        }

        function openFxPanel(soundInfo) {
            currentEditSound = soundInfo;
            document.getElementById('fxPanelEmoji').textContent = soundInfo.emoji;
            document.getElementById('fxPanelName').textContent = soundInfo.name;

            // Reset sliders
            soundFxSettings = { pitch: 0, speed: 100, echo: 0, volume: 100 };
            document.getElementById('fxPitchSlider').value = 0;
            document.getElementById('fxSpeedSlider').value = 100;
            document.getElementById('fxEchoSlider').value = 0;
            document.getElementById('fxVolumeSlider').value = 100;
            document.getElementById('fxPitchValue').textContent = '0';
            document.getElementById('fxSpeedValue').textContent = '1.0x';
            document.getElementById('fxEchoValue').textContent = '0%';
            document.getElementById('fxVolumeValue').textContent = '100%';

            // Check if favorite
            const isFav = favorites.some(f => f.query === soundInfo.query);
            document.getElementById('fxFavoriteBtn').classList.toggle('active', isFav);

            document.getElementById('soundFxPanel').classList.add('show');
        }

        function closeFxPanel() {
            document.getElementById('soundFxPanel').classList.remove('show');
            if (currentEditHowl) {
                currentEditHowl.stop();
                currentEditHowl = null;
            }
        }

        function updateFxPitch(value) {
            soundFxSettings.pitch = parseInt(value);
            document.getElementById('fxPitchValue').textContent = value > 0 ? `+${value}` : value;
        }

        function updateFxSpeed(value) {
            soundFxSettings.speed = parseInt(value);
            document.getElementById('fxSpeedValue').textContent = (value / 100).toFixed(1) + 'x';
            if (currentEditHowl) currentEditHowl.rate(value / 100);
        }

        function updateFxEcho(value) {
            soundFxSettings.echo = parseInt(value);
            document.getElementById('fxEchoValue').textContent = value + '%';
        }

        function updateFxVolume(value) {
            soundFxSettings.volume = parseInt(value);
            document.getElementById('fxVolumeValue').textContent = value + '%';
            if (currentEditHowl) currentEditHowl.volume(value / 100);
        }

        function applyQuickFx(effect) {
            const presets = {
                reverse: { pitch: 0, speed: 100, echo: 0, volume: 100, reverse: true },
                echo: { pitch: 0, speed: 100, echo: 80, volume: 100 },
                underwater: { pitch: -5, speed: 70, echo: 60, volume: 80 },
                space: { pitch: 8, speed: 50, echo: 90, volume: 100 },
                chipmunk: { pitch: 12, speed: 150, echo: 0, volume: 100 },
                monster: { pitch: -12, speed: 70, echo: 30, volume: 120 },
                robot: { pitch: -3, speed: 90, echo: 50, volume: 100 }
            };

            const preset = presets[effect];
            if (preset) {
                soundFxSettings = { ...preset };
                document.getElementById('fxPitchSlider').value = preset.pitch;
                document.getElementById('fxSpeedSlider').value = preset.speed;
                document.getElementById('fxEchoSlider').value = preset.echo;
                document.getElementById('fxVolumeSlider').value = preset.volume;
                updateFxPitch(preset.pitch);
                updateFxSpeed(preset.speed);
                updateFxEcho(preset.echo);
                updateFxVolume(preset.volume);
                showStatus(`Applied: ${effect}!`);
                playWithFx();
            }
        }

        async function playWithFx() {
            if (!currentEditSound) return;

            if (currentEditHowl) currentEditHowl.stop();

            currentEditHowl = await loadSound(currentEditSound);
            if (currentEditHowl) {
                // Apply pitch through rate (approximation)
                const pitchRate = Math.pow(2, soundFxSettings.pitch / 12);
                const speedRate = soundFxSettings.speed / 100;
                currentEditHowl.rate(pitchRate * speedRate);
                currentEditHowl.volume(soundFxSettings.volume / 100);
                currentEditHowl.play();
                showStatus(`Playing: ${currentEditSound.name}`);
            }
        }

        function stopCurrentFx() {
            if (currentEditHowl) {
                currentEditHowl.stop();
                showStatus('Stopped');
            }
        }

        function addToMixerWithFx() {
            if (!currentEditSound) return;

            const modifiedSound = {
                ...currentEditSound,
                name: `${currentEditSound.name} (edited)`,
                fx: { ...soundFxSettings }
            };

            mixerSounds.push({
                ...modifiedSound,
                volume: soundFxSettings.volume / 100,
                howl: null
            });

            renderMixer();
            showStatus(`Added edited ${currentEditSound.name} to mixer!`);
            document.getElementById('soundMixer').style.display = 'block';
            document.getElementById('mixerToggleBtn').classList.add('active');
            closeFxPanel();
        }

        // ============================================
        // FAVORITES SYSTEM
        // ============================================
        let favorites = JSON.parse(localStorage.getItem('juliaFavorites') || '[]');

        function toggleFavorite() {
            if (!currentEditSound) return;

            const idx = favorites.findIndex(f => f.query === currentEditSound.query);
            if (idx >= 0) {
                favorites.splice(idx, 1);
                document.getElementById('fxFavoriteBtn').classList.remove('active');
                showStatus('Removed from favorites');
            } else {
                favorites.push(currentEditSound);
                document.getElementById('fxFavoriteBtn').classList.add('active');
                showStatus('Added to favorites!');
                spawnConfetti(10);
            }

            localStorage.setItem('juliaFavorites', JSON.stringify(favorites));
            renderFavorites();
        }

        function addToFavorites(soundInfo) {
            if (favorites.some(f => f.query === soundInfo.query)) {
                showStatus('Already a favorite!');
                return;
            }
            favorites.push(soundInfo);
            localStorage.setItem('juliaFavorites', JSON.stringify(favorites));
            renderFavorites();
            showStatus('Added to favorites!');
            spawnConfetti(5);
        }

        function removeFromFavorites(index) {
            favorites.splice(index, 1);
            localStorage.setItem('juliaFavorites', JSON.stringify(favorites));
            renderFavorites();
            showStatus('Removed from favorites');
        }

        function renderFavorites() {
            const container = document.getElementById('favoritesGrid');
            if (favorites.length === 0) {
                container.innerHTML = '<span class="favorites-empty">Long-press any sound to add to favorites!</span>';
                return;
            }

            container.innerHTML = favorites.map((fav, i) => `
                <button class="favorite-sound" style="background: ${fav.color}"
                    onclick="playSound(favorites[${i}], this)"
                    title="${fav.name}">
                    ${fav.emoji}
                    <button class="remove-fav" onclick="event.stopPropagation(); removeFromFavorites(${i})">âœ•</button>
                </button>
            `).join('');
        }

        // ============================================
        // MINI SEQUENCER / BEAT MAKER
        // ============================================
        const SEQUENCER_STEPS = 8;
        let sequencerPattern = new Array(SEQUENCER_STEPS).fill(null);
        let sequencerPlaying = false;
        let sequencerInterval = null;
        let sequencerStep = 0;

        function initSequencer() {
            const container = document.getElementById('sequencerGrid');
            container.innerHTML = '';
            for (let i = 0; i < SEQUENCER_STEPS; i++) {
                const step = document.createElement('div');
                step.className = 'seq-step empty';
                step.dataset.step = i;
                step.onclick = () => selectSequencerStep(i);

                // Drop zone handling
                step.ondragover = (e) => {
                    e.preventDefault();
                    step.classList.add('drag-over');
                };
                step.ondragleave = () => {
                    step.classList.remove('drag-over');
                };
                step.ondrop = (e) => {
                    e.preventDefault();
                    step.classList.remove('drag-over');
                    const soundData = e.dataTransfer.getData('application/json');
                    if (soundData) {
                        const sound = JSON.parse(soundData);
                        sequencerPattern[i] = sound;
                        updateSequencerUI();
                        showStatus(`${sound.emoji} added to step ${i + 1}!`);
                    }
                };

                container.appendChild(step);
            }
        }

        // Drag & Drop handlers for sound buttons
        let draggedSound = null;
        let lastSelectedSound = null; // For tablet tap-to-add support

        function handleDragStart(e, soundIndex) {
            const sound = soundCategories[currentCategory].sounds[soundIndex];
            draggedSound = sound;
            lastSelectedSound = sound;
            e.target.classList.add('dragging');
            e.dataTransfer.setData('application/json', JSON.stringify(sound));
            e.dataTransfer.effectAllowed = 'copy';
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedSound = null;
            // Remove drag-over from all steps
            document.querySelectorAll('.seq-step').forEach(s => s.classList.remove('drag-over'));
        }

        function selectSequencerStep(stepIndex) {
            if (sequencerPattern[stepIndex]) {
                // Clear this step
                sequencerPattern[stepIndex] = null;
                updateSequencerUI();
                showStatus(`Step ${stepIndex + 1} cleared`);
                return;
            }

            // Use last selected/played sound if available, otherwise use random
            let soundToAdd = lastSelectedSound;

            if (!soundToAdd) {
                const category = soundCategories[currentCategory];
                if (!category || !category.sounds.length) return;
                const sounds = category.sounds;
                soundToAdd = sounds[Math.floor(Math.random() * sounds.length)];
            }

            sequencerPattern[stepIndex] = soundToAdd;
            updateSequencerUI();
            showStatus(`${soundToAdd.emoji} added to step ${stepIndex + 1}!`);
        }

        function updateSequencerUI() {
            const steps = document.querySelectorAll('.seq-step');
            steps.forEach((step, i) => {
                if (sequencerPattern[i]) {
                    step.classList.remove('empty');
                    step.classList.add('filled');
                    step.textContent = sequencerPattern[i].emoji;
                } else {
                    step.classList.add('empty');
                    step.classList.remove('filled');
                    step.textContent = '';
                }
            });
        }

        async function playSequence() {
            if (sequencerPlaying) return;

            const hasSound = sequencerPattern.some(s => s !== null);
            if (!hasSound) {
                showStatus('Add some sounds first!');
                return;
            }

            sequencerPlaying = true;
            sequencerStep = 0;
            showStatus('Playing sequence!');

            const steps = document.querySelectorAll('.seq-step');
            const tempo = 300; // ms per step

            sequencerInterval = setInterval(async () => {
                // Remove playing class from all
                steps.forEach(s => s.classList.remove('playing'));

                // Highlight current step
                steps[sequencerStep].classList.add('playing');

                // Play sound if exists
                const sound = sequencerPattern[sequencerStep];
                if (sound) {
                    const howl = await loadSound(sound);
                    if (howl) {
                        howl.rate(sceneModes[currentSceneMode].speed);
                        howl.play();
                    }
                }

                sequencerStep = (sequencerStep + 1) % SEQUENCER_STEPS;
            }, tempo);
        }

        function stopSequence() {
            sequencerPlaying = false;
            if (sequencerInterval) {
                clearInterval(sequencerInterval);
                sequencerInterval = null;
            }
            document.querySelectorAll('.seq-step').forEach(s => s.classList.remove('playing'));
            showStatus('Sequence stopped');
        }

        function clearSequence() {
            stopSequence();
            sequencerPattern = new Array(SEQUENCER_STEPS).fill(null);
            updateSequencerUI();
            showStatus('Sequence cleared');
        }

        // ============================================
        // UI RENDERING
        // ============================================
        function renderCategoryTabs() {
            const container = document.getElementById('categoryTabs');
            container.innerHTML = Object.keys(soundCategories).map(key => {
                const cat = soundCategories[key];
                return `<button class="category-tab ${key === currentCategory ? 'active' : ''}" onclick="switchCategory('${key}')">${cat.icon} ${cat.name.split(' ')[1]}</button>`;
            }).join('');
        }

        function switchCategory(categoryKey) {
            currentCategory = categoryKey;
            document.querySelectorAll('.category-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.category-tab[onclick="switchCategory('${categoryKey}')"]`).classList.add('active');
            renderSoundGrid();
        }

        // Detect touch-only devices (no mouse)
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        function renderSoundGrid() {
            const container = document.getElementById('soundGrid');
            const category = soundCategories[currentCategory];

            container.innerHTML = category.sounds.map((sound, i) => `
                <button class="sound-btn" style="background: ${sound.color}" title="${sound.name}${!isTouchDevice ? ' (drag to Beat Maker!)' : ''}"
                    ${!isTouchDevice ? 'draggable="true"' : ''}
                    onclick="handleSoundClick(${i}, this)"
                    oncontextmenu="event.preventDefault(); openFxPanel(soundCategories['${currentCategory}'].sounds[${i}])"
                    ${!isTouchDevice ? `ondragstart="handleDragStart(event, ${i})" ondragend="handleDragEnd(event)"` : ''}
                    ontouchstart="handleTouchStart(event, ${i})"
                    ontouchend="handleTouchEnd(event, ${i})">
                    ${sound.emoji}
                </button>
            `).join('');
        }

        // Handle sound button click - play or edit depending on mode
        function handleSoundClick(index, btn) {
            // Skip if already handled by touch event (prevents double-fire on mobile)
            if (touchHandled) return;
            const soundInfo = soundCategories[currentCategory].sounds[index];
            lastSelectedSound = soundInfo; // Track for Beat Maker tap-to-add
            if (editMode) {
                openFxPanel(soundInfo);
            } else {
                playSound(soundInfo, btn);
            }
        }

        // Long press for touch devices - opens FX panel for editing
        let touchTimer = null;
        let touchStartTime = 0;
        let touchHandled = false; // Prevents onclick from double-firing after touch

        function handleTouchStart(event, index) {
            // Unlock audio on iOS/tablets immediately on touch
            initAudio();
            if (Howler.ctx && Howler.ctx.state === 'suspended') {
                Howler.ctx.resume();
            }
            touchStartTime = Date.now();
            touchTimer = setTimeout(() => {
                // Long press - open FX panel or add to favorites
                const soundInfo = soundCategories[currentCategory].sounds[index];
                openFxPanel(soundInfo);
                touchTimer = null;
                touchHandled = true;
                setTimeout(() => { touchHandled = false; }, 400);
            }, 500);
            // Prevent click from firing after touch on mobile
            event.preventDefault();
        }

        function handleTouchEnd(event, index) {
            if (touchTimer) {
                clearTimeout(touchTimer);
                touchTimer = null;
                // Short tap - play the sound
                // Unlock audio on iOS/tablets
                initAudio();
                if (Howler.ctx && Howler.ctx.state === 'suspended') {
                    Howler.ctx.resume();
                }
                const soundInfo = soundCategories[currentCategory].sounds[index];
                const btn = event.target.closest('.sound-btn');
                lastSelectedSound = soundInfo;
                if (editMode) {
                    openFxPanel(soundInfo);
                } else {
                    playSound(soundInfo, btn);
                }
            }
            touchHandled = true;
            setTimeout(() => { touchHandled = false; }, 400);
            event.preventDefault();
        }

        // State
        let audioContext = null;
        let analyser = null;
        let isAudioInitialized = false;
        let loopMode = false;
        let activeLoops = {};

        // Mic state
        let micStream = null;
        let micSource = null;
        let micContext = null;
        let micAnalyser = null;
        let mediaRecorder = null;
        let micChunks = [];
        let isMicRecording = false;
        let isMonitoring = false;
        let micAnimationFrame = null;

        // Audio nodes
        let micGainNode = null;
        let delayNode = null;
        let feedbackNode = null;
        let wetGainNode = null;
        let dryGainNode = null;
        let outputGainNode = null;
        let lowpassFilter = null;
        let highpassFilter = null;
        let distortionNode = null;
        let convolverNode = null;
        let oscillatorLFO = null;
        let lfoGain = null;
        let compressorNode = null;

        const micEffects = { pitch: 0, echo: 0, delay: 0, reverb: 0, gain: 1, currentEffect: 'normal' };

        const state = {
            instrument: 'piano',
            isRecording: false,
            recording: [],
            recordingStart: 0,
            currentTrack: null,
            settings: { volume: 80, effects: true, bubbles: true, confetti: true }
        };

        // NOTE: soundCategories is defined above (lines ~1533) with Freesound API queries
        // Do not redefine it here - that would overwrite the Freesound-enabled version!

        const drumPads = [
            { emoji: 'ðŸ¦¶', name: 'Kick', color: '#E74C3C' },
            { emoji: 'ðŸ¥¢', name: 'Snare', color: '#3498DB' },
            { emoji: 'ðŸŽ©', name: 'Hi-Hat', color: '#F1C40F' },
            { emoji: 'ðŸ’¥', name: 'Crash', color: '#9B59B6' },
            { emoji: 'ðŸ”ˆ', name: 'Tom 1', color: '#2ECC71' },
            { emoji: 'ðŸ”‰', name: 'Tom 2', color: '#E67E22' },
            { emoji: 'ðŸ‘', name: 'Clap', color: '#1ABC9C' },
            { emoji: 'ðŸ”Š', name: 'Tom 3', color: '#FF6B9D' }
        ];

        // New instrument configurations
        const guitarNotes = ['E2', 'A2', 'D3', 'G3', 'B3', 'E4'];
        const guitarColors = ['#8B4513', '#A0522D', '#CD853F', '#DEB887', '#D2B48C', '#F5DEB3'];

        const bellNotes = ['C5', 'D5', 'E5', 'F5', 'G5', 'A5', 'B5', 'C6'];
        const bellColors = ['#FFD700', '#FFC107', '#FFB300', '#FFA000', '#FF8F00', '#FF6F00', '#F57C00', '#EF6C00'];

        const bassNotes = ['E1', 'A1', 'D2', 'G2', 'C2', 'F2'];
        const bassColors = ['#1a237e', '#283593', '#303f9f', '#3949ab', '#3f51b5', '#5c6bc0'];

        const synthNotes = ['C3', 'E3', 'G3', 'C4', 'E4', 'G4', 'C5', 'E5'];
        const synthColors = ['#00BCD4', '#00ACC1', '#0097A7', '#00838F', '#006064', '#004D40', '#00695C', '#00796B'];

        // Harp - 12 strings with golden gradient
        const harpNotes = ['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4', 'D4', 'E4', 'F4', 'G4'];
        const harpColors = ['#DAA520', '#D4AF37', '#CFB53B', '#C9A227', '#B8860B', '#CD853F', '#DAA520', '#D4AF37', '#CFB53B', '#C9A227', '#B8860B', '#CD853F'];

        // Kalimba - African thumb piano, 9 tines
        const kalimbaNotes = ['C4', 'D4', 'E4', 'G4', 'A4', 'C5', 'D5', 'E5', 'G5'];
        const kalimbaHeights = [90, 100, 110, 120, 130, 120, 110, 100, 90];
        const kalimbaColors = ['#8B4513', '#A0522D', '#8B4513', '#A0522D', '#8B4513', '#A0522D', '#8B4513', '#A0522D', '#8B4513'];

        // Steel Drums - Caribbean vibes, 8 sections
        const steelDrumNotes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];
        const steelDrumColors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F'];

        // Organ - church/cathedral organ
        const organNotes = ['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4', 'D4', 'E4'];
        const organColors = ['#4A4A4A', '#5A5A5A', '#4A4A4A', '#5A5A5A', '#4A4A4A', '#5A5A5A', '#4A4A4A', '#5A5A5A', '#4A4A4A', '#5A5A5A'];

        // Marimba - deeper wooden xylophone
        const marimbaNotes = ['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4'];
        const marimbaHeights = [140, 130, 120, 115, 110, 105, 100, 95];
        const marimbaColors = ['#D2691E', '#CD853F', '#DEB887', '#F4A460', '#D2691E', '#CD853F', '#DEB887', '#F4A460'];

        // Flute - breathy wind instrument
        const fluteNotes = ['D4', 'E4', 'F#4', 'G4', 'A4', 'B4', 'C#5', 'D5'];
        const fluteColors = ['#C0C0C0', '#D3D3D3', '#C0C0C0', '#D3D3D3', '#C0C0C0', '#D3D3D3', '#C0C0C0', '#D3D3D3'];

        // Music Box - delicate mechanical sound
        const chimesNotes = ['E5', 'G5', 'A5', 'B5', 'C6', 'D6', 'E6', 'G6'];
        const chimesColors = ['#FFB6C1', '#FFC0CB', '#FFD1DC', '#FFE4E1', '#FFF0F5', '#FFE4E1', '#FFD1DC', '#FFC0CB'];

        // Trumpet - brass, bold
        const trumpetNotes = ['C4', 'E4', 'G4', 'C5', 'E5', 'G5'];
        const trumpetColors = ['#FFD700', '#FFC107', '#FFB300', '#FFA000', '#FF8F00', '#FF6F00'];

        const tracks = [
            // Classic Kids Songs
            { name: 'â­ Twinkle Twinkle', tempo: 90, pattern: 'twinkle' },
            { name: 'ðŸ‘ Mary Had a Lamb', tempo: 100, pattern: 'mary' },
            { name: 'ðŸŽ‚ Happy Birthday', tempo: 110, pattern: 'birthday' },
            { name: 'ðŸ”” Jingle Bells', tempo: 120, pattern: 'jingle' },
            { name: 'ðŸŽµ Ode to Joy', tempo: 100, pattern: 'odeToJoy' },
            { name: 'ðŸ¥– Hot Cross Buns', tempo: 90, pattern: 'hotCross' },
            { name: 'ðŸŒ‰ London Bridge', tempo: 110, pattern: 'london' },
            { name: 'ðŸš£ Row Your Boat', tempo: 80, pattern: 'rowBoat' },
            { name: 'ðŸ¸ Baby Shark', tempo: 115, pattern: 'babyShark' },
            { name: 'ðŸŒˆ Somewhere Rainbow', tempo: 75, pattern: 'rainbow' },
            { name: 'ðŸŽ¹ FÃ¼r Elise', tempo: 85, pattern: 'furElise' },
            { name: 'ðŸ´â€â˜ ï¸ Pirates Theme', tempo: 130, pattern: 'pirates' },
            // Beat Tracks
            { name: 'ðŸŽ¸ Rock Beat', tempo: 120, pattern: 'rock' },
            { name: 'ðŸŽ¹ Jazz', tempo: 90, pattern: 'jazz' },
            { name: 'ðŸŽ‰ Party', tempo: 140, pattern: 'party' },
            { name: 'ðŸŒ™ Lullaby', tempo: 70, pattern: 'lullaby' }
        ];

        const pianoNotes = ['C4', 'C#4', 'D4', 'D#4', 'E4', 'F4', 'F#4', 'G4', 'G#4', 'A4', 'A#4', 'B4', 'C5'];
        const pianoKeys = ['a', 'w', 's', 'e', 'd', 'f', 't', 'g', 'y', 'h', 'u', 'j', 'k'];
        const xyloNotes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5'];
        const xyloColors = ['#E74C3C', '#E67E22', '#F1C40F', '#2ECC71', '#1ABC9C', '#3498DB', '#9B59B6', '#FF6B9D'];

        // Audio Init
        async function initAudio() {
            // Create synths synchronously on first user gesture (before any await)
            // This ensures synths are available immediately for play functions
            initSynths();
            if (isAudioInitialized) return;
            try {
                await Tone.start();
                audioContext = Tone.context.rawContext;
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                Tone.getDestination().connect(analyser);
                isAudioInitialized = true;
                // Also unlock Howler audio context for Freesound playback
                if (Howler.ctx && Howler.ctx.state === 'suspended') {
                    Howler.ctx.resume();
                }
            } catch (e) { console.error('Audio init failed:', e); }
        }

        document.addEventListener('click', initAudio, { once: true });
        document.addEventListener('touchstart', initAudio, { once: true });

        // Synths - lazy initialized on first user interaction to avoid AudioContext warnings
        let synths = null;
        function initSynths() {
            if (synths) return;
            synths = {
                piano: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.02, decay: 0.3, sustain: 0.2, release: 1 } }).toDestination(),
                xylophone: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 0.5, sustain: 0, release: 0.5 } }).toDestination(),
                guitar: new Tone.PluckSynth({ attackNoise: 1, dampening: 4000, resonance: 0.98 }).toDestination(),
                bells: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 1.5, sustain: 0, release: 1.5 } }).toDestination(),
                bass: new Tone.MonoSynth({ oscillator: { type: 'sawtooth' }, envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 0.8 }, filterEnvelope: { attack: 0.05, decay: 0.2, sustain: 0.5, release: 0.8, baseFrequency: 200, octaves: 2.5 } }).toDestination(),
                synthPad: new Tone.PolySynth(Tone.FMSynth, { harmonicity: 3, modulationIndex: 10, envelope: { attack: 0.2, decay: 0.3, sustain: 0.8, release: 1.5 } }).toDestination(),
                harp: new Tone.PluckSynth({ attackNoise: 0.5, dampening: 2000, resonance: 0.99 }).toDestination(),
                kalimba: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 2, sustain: 0, release: 2 } }).toDestination(),
                steelDrum: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.8, sustain: 0.1, release: 1 } }).toDestination(),
                organ: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'square' }, envelope: { attack: 0.05, decay: 0.1, sustain: 0.9, release: 0.5 } }).toDestination(),
                marimba: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 1, sustain: 0, release: 1 } }).toDestination(),
                flute: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.1, sustain: 0.8, release: 0.3 } }).toDestination(),
                chimes: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sine' }, envelope: { attack: 0.001, decay: 3, sustain: 0, release: 3 } }).toDestination(),
                trumpet: new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'sawtooth' }, envelope: { attack: 0.05, decay: 0.2, sustain: 0.8, release: 0.3 } }).toDestination(),
                drums: {
                    kick: new Tone.MembraneSynth().toDestination(),
                    snare: new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.2, sustain: 0 } }).toDestination(),
                    hihat: new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.1, release: 0.01 }, harmonicity: 5.1, modulationIndex: 32, resonance: 4000, octaves: 1.5 }).toDestination(),
                    tom: new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 4 }).toDestination(),
                    clap: new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0 } }).toDestination()
                },
                fx: {
                    sine: new Tone.Synth({ oscillator: { type: 'sine' } }).toDestination(),
                    saw: new Tone.Synth({ oscillator: { type: 'sawtooth' } }).toDestination(),
                    square: new Tone.Synth({ oscillator: { type: 'square' } }).toDestination(),
                    noise: new Tone.NoiseSynth({ noise: { type: 'brown' } }).toDestination(),
                    whiteNoise: new Tone.NoiseSynth({ noise: { type: 'white' } }).toDestination(),
                    metal: new Tone.MetalSynth().toDestination(),
                    membrane: new Tone.MembraneSynth().toDestination(),
                    poly: new Tone.PolySynth().toDestination(),
                    pluck: new Tone.PluckSynth().toDestination(),
                    fm: new Tone.FMSynth().toDestination()
                }
            };
        }

        // Sound effect functions - SYNTHESIZED sounds (not recordings!)
        const effectFns = {
            // Animals - these are synth approximations, not real recordings
            cat: () => {
                // Meow: descending pitch
                synths.fx.saw.triggerAttackRelease('A5', '0.25');
                setTimeout(() => synths.fx.saw.triggerAttackRelease('F5', '0.2'), 120);
                setTimeout(() => synths.fx.saw.triggerAttackRelease('D5', '0.3'), 220);
            },
            dog: () => {
                // Bark: short bursts
                synths.fx.square.triggerAttackRelease('G3', '0.1');
                setTimeout(() => synths.fx.square.triggerAttackRelease('B3', '0.15'), 80);
            },
            frog: () => {
                // Ribbit: two low tones
                synths.fx.sine.triggerAttackRelease('G2', '0.15');
                setTimeout(() => synths.fx.sine.triggerAttackRelease('G2', '0.2'), 150);
            },
            lion: () => {
                // Roar: loud noise burst + low rumble
                synths.fx.noise.triggerAttackRelease('0.8');
                synths.fx.membrane.triggerAttackRelease('E1', '0.8');
            },
            bird: () => {
                // Chirp: high ascending notes
                synths.fx.sine.triggerAttackRelease('E6', '0.08');
                setTimeout(() => synths.fx.sine.triggerAttackRelease('G6', '0.08'), 80);
                setTimeout(() => synths.fx.sine.triggerAttackRelease('B6', '0.1'), 160);
                setTimeout(() => synths.fx.sine.triggerAttackRelease('E7', '0.12'), 240);
            },
            cow: () => {
                // Moo: long low tone
                synths.fx.saw.triggerAttackRelease('G2', '1.0');
                setTimeout(() => synths.fx.saw.triggerAttackRelease('E2', '0.8'), 400);
            },
            pig: () => {
                // Oink: nasal sound
                synths.fx.square.triggerAttackRelease('E4', '0.1');
                setTimeout(() => synths.fx.square.triggerAttackRelease('G4', '0.15'), 80);
                setTimeout(() => synths.fx.square.triggerAttackRelease('E4', '0.1'), 180);
            },
            horse: () => {
                // Neigh: rising then falling
                synths.fx.saw.triggerAttackRelease('E4', '0.2');
                setTimeout(() => synths.fx.saw.triggerAttackRelease('A4', '0.25'), 150);
                setTimeout(() => synths.fx.saw.triggerAttackRelease('E5', '0.3'), 300);
                setTimeout(() => synths.fx.saw.triggerAttackRelease('A4', '0.4'), 500);
            },
            duck: () => {
                // Quack: nasal honk
                synths.fx.square.triggerAttackRelease('D4', '0.12');
                setTimeout(() => synths.fx.square.triggerAttackRelease('F4', '0.15'), 100);
            },
            bee: () => {
                // Buzz: continuous buzzing
                synths.fx.saw.triggerAttackRelease('A3', '0.5');
                synths.fx.saw.triggerAttackRelease('A#3', '0.5');
            },
            owl: () => {
                // Hoot: two low tones
                synths.fx.sine.triggerAttackRelease('E3', '0.5');
                setTimeout(() => synths.fx.sine.triggerAttackRelease('C3', '0.6'), 500);
            },
            wolf: () => {
                // Howl: rising tone
                synths.fx.saw.triggerAttackRelease('D3', '0.4');
                setTimeout(() => synths.fx.saw.triggerAttackRelease('G3', '0.5'), 300);
                setTimeout(() => synths.fx.saw.triggerAttackRelease('D4', '0.7'), 600);
            },
            fox: () => {
                // Yip: short high bark
                synths.fx.square.triggerAttackRelease('A4', '0.1');
                setTimeout(() => synths.fx.square.triggerAttackRelease('E5', '0.12'), 80);
            },
            elephant: () => {
                // Trumpet: loud brass-like
                synths.fx.membrane.triggerAttackRelease('C2', '0.8');
                synths.fx.fm.triggerAttackRelease('C3', '0.6');
            },
            monkey: () => {
                // Screech: fast high notes
                synths.fx.sine.triggerAttackRelease('C5', '0.08');
                setTimeout(() => synths.fx.sine.triggerAttackRelease('G5', '0.08'), 60);
                setTimeout(() => synths.fx.sine.triggerAttackRelease('E6', '0.1'), 120);
                setTimeout(() => synths.fx.sine.triggerAttackRelease('G5', '0.08'), 180);
                setTimeout(() => synths.fx.sine.triggerAttackRelease('C6', '0.12'), 240);
            },
            trumpet: () => synths.fx.square.triggerAttackRelease('C4', '0.5'),
            bell: () => synths.fx.metal.triggerAttackRelease('C5', '0.5'),
            sax: () => synths.fx.fm.triggerAttackRelease('G3', '0.4'),
            violin: () => { synths.fx.saw.triggerAttackRelease('A4', '0.3'); setTimeout(() => synths.fx.saw.triggerAttackRelease('E5', '0.3'), 150); },
            banjo: () => synths.fx.pluck.triggerAttack('G3'),
            guitar: () => synths.fx.pluck.triggerAttack('E3'),
            flute: () => synths.fx.sine.triggerAttackRelease('C5', '0.4'),
            fanfare: () => { synths.fx.square.triggerAttackRelease('C4', '0.2'); setTimeout(() => synths.fx.square.triggerAttackRelease('E4', '0.2'), 150); setTimeout(() => synths.fx.square.triggerAttackRelease('G4', '0.3'), 300); },
            boom: () => synths.fx.membrane.triggerAttackRelease('C1', '0.5'),
            magic: () => synths.fx.poly.triggerAttackRelease(['C5', 'E5', 'G5', 'B5'], '0.5'),
            car: () => { synths.fx.saw.triggerAttackRelease('E2', '0.3'); setTimeout(() => synths.fx.saw.triggerAttackRelease('G2', '0.3'), 200); },
            rocket: () => synths.fx.whiteNoise.triggerAttackRelease('0.8'),
            zap: () => { synths.fx.fm.triggerAttackRelease('C6', '0.1'); setTimeout(() => synths.fx.fm.triggerAttackRelease('G5', '0.15'), 50); },
            wind: () => synths.fx.noise.triggerAttackRelease('0.6'),
            wave: () => { synths.fx.sine.triggerAttackRelease('C3', '0.4'); setTimeout(() => synths.fx.sine.triggerAttackRelease('E3', '0.4'), 200); },
            fire: () => synths.fx.whiteNoise.triggerAttackRelease('0.4'),
            ghost: () => { synths.fx.sine.triggerAttackRelease('E3', '0.5'); setTimeout(() => synths.fx.sine.triggerAttackRelease('G3', '0.4'), 250); },
            robot: () => { synths.fx.square.triggerAttackRelease('C3', '0.1'); setTimeout(() => synths.fx.square.triggerAttackRelease('G3', '0.1'), 100); setTimeout(() => synths.fx.square.triggerAttackRelease('C4', '0.15'), 200); },
            alien: () => { synths.fx.fm.triggerAttackRelease('G4', '0.3'); setTimeout(() => synths.fx.fm.triggerAttackRelease('C5', '0.2'), 150); },
            pumpkin: () => { synths.fx.sine.triggerAttackRelease('D3', '0.4'); setTimeout(() => synths.fx.sine.triggerAttackRelease('F3', '0.4'), 200); },
            pop: () => synths.fx.membrane.triggerAttackRelease('G4', '0.1'),
            twinkle: () => { synths.fx.sine.triggerAttackRelease('C6', '0.15'); setTimeout(() => synths.fx.sine.triggerAttackRelease('E6', '0.1'), 100); },
            shine: () => synths.fx.poly.triggerAttackRelease(['C5', 'G5', 'C6'], '0.3'),
            ice: () => synths.fx.metal.triggerAttackRelease('E6', '0.3'),
            ding: () => synths.fx.sine.triggerAttackRelease('C5', '0.2'),
            jingle: () => { synths.fx.sine.triggerAttackRelease('C5', '0.15'); setTimeout(() => synths.fx.sine.triggerAttackRelease('E5', '0.15'), 100); setTimeout(() => synths.fx.sine.triggerAttackRelease('G5', '0.15'), 200); },
            drumroll: () => { for(let i = 0; i < 8; i++) { setTimeout(() => synths.drums.snare.triggerAttackRelease('16n'), i * 60); } }
        };

        // Loop mode (updated for Freesound)
        function toggleLoopMode() {
            loopMode = !loopMode;
            document.getElementById('loopModeBtn').classList.toggle('active', loopMode);
            showStatus(loopMode ? 'ðŸ” Loop Mode ON' : 'ðŸ” Loop Mode OFF');
        }

        // Legacy playEffect for fallback (uses Tone.js synths)
        function playEffect(name, btn) {
            initAudio();

            if (loopMode) {
                if (activeLoops[name]) {
                    clearInterval(activeLoops[name]);
                    delete activeLoops[name];
                    btn.classList.remove('looping');
                    showStatus(`Stopped: ${name}`);
                } else {
                    if (effectFns[name]) effectFns[name]();
                    activeLoops[name] = setInterval(() => { if (effectFns[name]) effectFns[name](); }, 500);
                    btn.classList.add('looping');
                    showStatus(`Looping: ${name}`);
                }
            } else {
                if (effectFns[name]) effectFns[name]();
                animateBtn(btn);
                if (state.settings.confetti) spawnConfetti(3);
            }
            recordEvent('effect', name);
        }

        let currentLoop = null;

        function createLoop(pattern, tempo) {
            Tone.Transport.bpm.value = tempo;
            if (currentLoop) { currentLoop.stop(); currentLoop.dispose(); }

            const patterns = {
                // Classic Kids Songs
                twinkle: () => new Tone.Sequence((t, n) => synths.xylophone.triggerAttackRelease(n, '4n', t),
                    ['C4', 'C4', 'G4', 'G4', 'A4', 'A4', 'G4', null, 'F4', 'F4', 'E4', 'E4', 'D4', 'D4', 'C4', null], '4n'),
                mary: () => new Tone.Sequence((t, n) => synths.xylophone.triggerAttackRelease(n, '4n', t),
                    ['E4', 'D4', 'C4', 'D4', 'E4', 'E4', 'E4', null, 'D4', 'D4', 'D4', null, 'E4', 'G4', 'G4', null], '4n'),
                birthday: () => new Tone.Sequence((t, n) => synths.piano.triggerAttackRelease(n, '4n', t),
                    ['C4', 'C4', 'D4', 'C4', 'F4', 'E4', null, 'C4', 'C4', 'D4', 'C4', 'G4', 'F4', null, null, null], '4n'),
                jingle: () => new Tone.Sequence((t, n) => synths.bells.triggerAttackRelease(n, '4n', t),
                    ['E4', 'E4', 'E4', null, 'E4', 'E4', 'E4', null, 'E4', 'G4', 'C4', 'D4', 'E4', null, null, null], '4n'),
                odeToJoy: () => new Tone.Sequence((t, n) => synths.piano.triggerAttackRelease(n, '4n', t),
                    ['E4', 'E4', 'F4', 'G4', 'G4', 'F4', 'E4', 'D4', 'C4', 'C4', 'D4', 'E4', 'E4', 'D4', 'D4', null], '4n'),
                hotCross: () => new Tone.Sequence((t, n) => synths.xylophone.triggerAttackRelease(n, '4n', t),
                    ['E4', 'D4', 'C4', null, 'E4', 'D4', 'C4', null, 'C4', 'C4', 'C4', 'C4', 'D4', 'D4', 'D4', 'D4', 'E4', 'D4', 'C4', null], '4n'),
                london: () => new Tone.Sequence((t, n) => synths.xylophone.triggerAttackRelease(n, '4n', t),
                    ['G4', 'A4', 'G4', 'F4', 'E4', 'F4', 'G4', null, 'D4', 'E4', 'F4', null, 'E4', 'F4', 'G4', null], '4n'),
                rowBoat: () => new Tone.Sequence((t, n) => synths.piano.triggerAttackRelease(n, '4n', t, 0.6),
                    ['C4', 'C4', 'C4', 'D4', 'E4', null, 'E4', 'D4', 'E4', 'F4', 'G4', null, null, null, null, null], '4n'),
                babyShark: () => new Tone.Sequence((t, n) => synths.xylophone.triggerAttackRelease(n, '8n', t),
                    ['C4', 'D4', 'F4', 'F4', 'F4', 'F4', 'F4', 'F4', 'C4', 'D4', 'F4', 'F4', 'F4', 'F4', 'F4', 'F4'], '8n'),
                rainbow: () => new Tone.Sequence((t, n) => synths.piano.triggerAttackRelease(n, '2n', t, 0.5),
                    ['C4', 'C5', 'B4', 'G4', 'A4', 'B4', 'C5', null], '2n'),
                furElise: () => new Tone.Sequence((t, n) => synths.piano.triggerAttackRelease(n, '8n', t, 0.6),
                    ['E5', 'D#5', 'E5', 'D#5', 'E5', 'B4', 'D5', 'C5', 'A4', null, 'C4', 'E4', 'A4', 'B4', null, 'E4', 'G#4', 'B4', 'C5', null, null, null, null, null], '8n'),
                pirates: () => new Tone.Sequence((t, n) => synths.organ.triggerAttackRelease(n, '8n', t, 0.7),
                    ['D4', 'D4', 'D4', 'D4', 'D4', 'D4', 'D4', 'D4', 'A#3', 'A#3', 'C4', 'D4', 'D4', 'D4', 'E4', 'F4', 'F4', 'F4', 'G4', 'E4', 'E4', 'D4', 'C4', 'D4'], '8n'),
                // Beat Tracks
                rock: () => new Tone.Sequence((t, n) => { if (n === 'k') synths.drums.kick.triggerAttackRelease('C2', '8n', t); if (n === 's') synths.drums.snare.triggerAttackRelease('8n', t); if (n === 'h') synths.drums.hihat.triggerAttackRelease('C5', '16n', t, 0.3); }, ['k', 'h', 's', 'h', 'k', 'h', 's', 'h'], '8n'),
                jazz: () => new Tone.Sequence((t, n) => synths.piano.triggerAttackRelease(n, '8n', t, 0.5), ['C3', 'E3', 'G3', 'B3', 'C4', 'B3', 'G3', 'E3'], '8n'),
                lullaby: () => new Tone.Sequence((t, n) => synths.piano.triggerAttackRelease(n, '4n', t, 0.3), ['C4', 'E4', 'G4', 'E4'], '4n'),
                party: () => new Tone.Sequence((t, n) => { if (n === 'k') synths.drums.kick.triggerAttackRelease('C2', '8n', t); if (n === 's') synths.drums.snare.triggerAttackRelease('8n', t); if (n === 'h') synths.drums.hihat.triggerAttackRelease('C5', '16n', t, 0.5); if (n === 't') synths.drums.tom.triggerAttackRelease('G2', '8n', t); }, ['k', 'h', 'h', 's', 'k', 'k', 'h', 's', 'h', 't', 'h', 's'], '8n')
            };

            currentLoop = patterns[pattern]();
            return currentLoop;
        }

        // Microphone functions
        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 50;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            for (let i = 0; i < n_samples; ++i) {
                const x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        function createImpulseResponse(duration, decay) {
            const sampleRate = micContext.sampleRate;
            const length = sampleRate * duration;
            const impulse = micContext.createBuffer(2, length, sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);
            for (let i = 0; i < length; i++) {
                const n = i / length;
                left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
                right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
            }
            return impulse;
        }

        async function connectMicrophone() {
            try {
                // Get microphone stream
                micStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // Create audio context
                micContext = new (window.AudioContext || window.webkitAudioContext)();

                // Resume context (required for some browsers)
                if (micContext.state === 'suspended') {
                    await micContext.resume();
                }

                micSource = micContext.createMediaStreamSource(micStream);
                micAnalyser = micContext.createAnalyser();
                micAnalyser.fftSize = 256;

                micGainNode = micContext.createGain();
                micGainNode.gain.value = micEffects.gain;

                lowpassFilter = micContext.createBiquadFilter();
                lowpassFilter.type = 'lowpass';
                lowpassFilter.frequency.value = 20000;

                highpassFilter = micContext.createBiquadFilter();
                highpassFilter.type = 'highpass';
                highpassFilter.frequency.value = 20;

                distortionNode = micContext.createWaveShaper();
                distortionNode.curve = makeDistortionCurve(0);
                distortionNode.oversample = '4x';

                compressorNode = micContext.createDynamicsCompressor();
                compressorNode.threshold.value = -24;
                compressorNode.knee.value = 30;
                compressorNode.ratio.value = 12;

                convolverNode = micContext.createConvolver();
                convolverNode.buffer = createImpulseResponse(2, 2);

                oscillatorLFO = micContext.createOscillator();
                oscillatorLFO.type = 'sine';
                oscillatorLFO.frequency.value = 5;
                lfoGain = micContext.createGain();
                lfoGain.gain.value = 0;
                oscillatorLFO.connect(lfoGain);
                oscillatorLFO.start();

                delayNode = micContext.createDelay(1.0);
                delayNode.delayTime.value = micEffects.delay / 1000;

                feedbackNode = micContext.createGain();
                feedbackNode.gain.value = micEffects.echo / 100 * 0.7;

                dryGainNode = micContext.createGain();
                dryGainNode.gain.value = 1.0;

                wetGainNode = micContext.createGain();
                wetGainNode.gain.value = 0.3;

                const reverbGain = micContext.createGain();
                reverbGain.gain.value = 0;
                window.reverbGainNode = reverbGain;

                outputGainNode = micContext.createGain();
                outputGainNode.gain.value = 0;

                micSource.connect(micAnalyser);
                micSource.connect(micGainNode);
                micGainNode.connect(highpassFilter);
                highpassFilter.connect(lowpassFilter);
                lowpassFilter.connect(distortionNode);
                distortionNode.connect(compressorNode);

                lfoGain.connect(outputGainNode.gain);

                compressorNode.connect(dryGainNode);
                dryGainNode.connect(outputGainNode);

                compressorNode.connect(delayNode);
                delayNode.connect(wetGainNode);
                wetGainNode.connect(outputGainNode);

                delayNode.connect(feedbackNode);
                feedbackNode.connect(delayNode);

                compressorNode.connect(convolverNode);
                convolverNode.connect(reverbGain);
                reverbGain.connect(outputGainNode);

                outputGainNode.connect(micContext.destination);

                document.getElementById('micDot').classList.add('ready');
                document.getElementById('micStatus').textContent = 'Connected';
                document.getElementById('micConnectBtn').disabled = true;
                document.getElementById('micRecordBtn').disabled = false;
                document.getElementById('micStopBtn').disabled = false;

                updateMicLevel();
                showStatus('Microphone connected!');
            } catch (err) {
                console.error('Mic error:', err);

                // Give specific error messages
                if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                    showStatus('âš ï¸ Mic permission denied');
                    alert('Microphone permission was denied.\n\n1. Tap the ðŸ”’ icon in your browser address bar\n2. Allow microphone access\n3. Refresh the page and try again');
                } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                    showStatus('âš ï¸ No microphone found');
                    alert('No microphone found on this device.');
                } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                    showStatus('âš ï¸ Mic in use');
                    alert('Microphone is being used by another app.\n\nClose other apps using the mic and try again.');
                } else {
                    showStatus('âš ï¸ Mic error');
                    alert('Could not access microphone.\n\nError: ' + err.message);
                }

                // Clean up if context was created
                if (micContext) {
                    micContext.close();
                    micContext = null;
                }
            }
        }

        function toggleMonitor() {
            if (!micStream) { showStatus('Connect microphone first!'); return; }
            if (micContext && micContext.state === 'suspended') micContext.resume();

            isMonitoring = !isMonitoring;
            const toggle = document.getElementById('monitorSwitch');
            const dot = document.getElementById('micDot');

            if (isMonitoring) {
                if (outputGainNode) outputGainNode.gain.setValueAtTime(1.0, micContext.currentTime);
                toggle.classList.add('on');
                dot.classList.add('monitoring');
                document.getElementById('micStatus').textContent = 'Monitoring ON';
                showStatus('Use headphones!');
            } else {
                if (outputGainNode) outputGainNode.gain.setValueAtTime(0, micContext.currentTime);
                toggle.classList.remove('on');
                dot.classList.remove('monitoring');
                document.getElementById('micStatus').textContent = 'Connected';
            }
        }

        function setVoiceEffect(effect, btn) {
            micEffects.currentEffect = effect;
            document.querySelectorAll('.effect-chip').forEach(c => c.classList.remove('active'));
            btn.classList.add('active');

            const presets = {
                normal: { pitch: 0, echo: 0, delay: 0, reverb: 0 },
                robot: { pitch: -5, echo: 30, delay: 50, reverb: 20 },
                chipmunk: { pitch: 12, echo: 0, delay: 0, reverb: 10 },
                monster: { pitch: -12, echo: 20, delay: 100, reverb: 30 },
                echo: { pitch: 0, echo: 60, delay: 200, reverb: 40 },
                alien: { pitch: 7, echo: 40, delay: 150, reverb: 50 }
            };

            const preset = presets[effect];
            if (preset) {
                document.getElementById('pitchSlider').value = preset.pitch;
                document.getElementById('echoSlider').value = preset.echo;
                document.getElementById('delaySlider').value = preset.delay;
                document.getElementById('reverbSlider').value = preset.reverb;
                updatePitch(preset.pitch);
                updateEcho(preset.echo);
                updateDelay(preset.delay);
                updateReverb(preset.reverb);
            }
            showStatus(`Voice: ${effect}`);
        }

        function updatePitch(value) { micEffects.pitch = parseInt(value); document.getElementById('pitchValue').textContent = value > 0 ? `+${value}` : value; }
        function updateEcho(value) { micEffects.echo = parseInt(value); document.getElementById('echoValue').textContent = value + '%'; if (feedbackNode) feedbackNode.gain.value = value / 100 * 0.7; if (wetGainNode && dryGainNode) { const wetAmount = Math.min(value / 100, 0.8); wetGainNode.gain.value = wetAmount; dryGainNode.gain.value = 1.0 - (wetAmount * 0.3); } }
        function updateDelay(value) { micEffects.delay = parseInt(value); document.getElementById('delayValue').textContent = value + 'ms'; if (delayNode) delayNode.delayTime.value = value / 1000; }
        function updateReverb(value) { micEffects.reverb = parseInt(value); document.getElementById('reverbValue').textContent = value + '%'; }
        function updateGain(value) { micEffects.gain = value / 100; document.getElementById('gainValue').textContent = value + '%'; if (micGainNode) micGainNode.gain.value = micEffects.gain; }

        function updateMicLevel() {
            if (!micAnalyser) return;
            const data = new Uint8Array(micAnalyser.frequencyBinCount);
            micAnalyser.getByteFrequencyData(data);
            const avg = data.reduce((a, b) => a + b, 0) / data.length;
            document.getElementById('micLevel').style.width = Math.min(100, (avg / 128) * 100) + '%';
            micAnimationFrame = requestAnimationFrame(updateMicLevel);
        }

        function toggleMicRecording() { isMicRecording ? stopMicRecording() : startMicRecording(); }

        function startMicRecording() {
            if (!micStream || !micContext) return;
            micChunks = [];

            const recordingDestination = micContext.createMediaStreamDestination();
            outputGainNode.connect(recordingDestination);

            const wasMonitoring = isMonitoring;
            if (!wasMonitoring) outputGainNode.gain.setValueAtTime(1.0, micContext.currentTime);

            mediaRecorder = new MediaRecorder(recordingDestination.stream, { mimeType: MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4' });

            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) micChunks.push(e.data); };
            mediaRecorder.onstop = () => {
                saveMicRecording(new Blob(micChunks, { type: mediaRecorder.mimeType }));
                try { outputGainNode.disconnect(recordingDestination); } catch(e) {}
                if (!wasMonitoring && !isMonitoring) outputGainNode.gain.setValueAtTime(0, micContext.currentTime);
            };

            mediaRecorder.start();
            isMicRecording = true;

            document.getElementById('micDot').classList.remove('ready', 'monitoring');
            document.getElementById('micDot').classList.add('recording');
            document.getElementById('micRecordBtn').innerHTML = 'â¹ï¸ Stop';
            document.getElementById('micStatus').textContent = 'Recording...';
            showStatus('Recording...');
        }

        function stopMicRecording() {
            if (mediaRecorder?.state === 'recording') mediaRecorder.stop();
            isMicRecording = false;

            document.getElementById('micDot').classList.remove('recording');
            document.getElementById('micDot').classList.add(isMonitoring ? 'monitoring' : 'ready');
            document.getElementById('micRecordBtn').innerHTML = 'âºï¸ Record';
            document.getElementById('micStatus').textContent = isMonitoring ? 'Monitoring' : 'Connected';
            showStatus('Recording saved!');
        }

        function disconnectMicrophone() {
            if (isMonitoring) toggleMonitor();
            if (isMicRecording) stopMicRecording();

            if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
            if (micContext) { micContext.close(); micContext = null; }
            if (micAnimationFrame) cancelAnimationFrame(micAnimationFrame);

            micSource = null; micAnalyser = null; micGainNode = null; delayNode = null; feedbackNode = null; wetGainNode = null; dryGainNode = null; outputGainNode = null;

            document.getElementById('micDot').classList.remove('ready', 'recording', 'monitoring');
            document.getElementById('micStatus').textContent = 'Not connected';
            document.getElementById('micLevel').style.width = '0%';
            document.getElementById('micConnectBtn').disabled = false;
            document.getElementById('micRecordBtn').disabled = true;
            document.getElementById('micStopBtn').disabled = true;
            document.getElementById('monitorSwitch').classList.remove('on');
            showStatus('Disconnected');
        }

        function saveMicRecording(blob) {
            const url = URL.createObjectURL(blob);
            const id = Date.now();
            const container = document.getElementById('micRecordings');
            const item = document.createElement('div');
            item.className = 'mic-recording-item';
            item.id = `mic-${id}`;
            item.innerHTML = `<audio controls src="${url}"></audio><button class="delete-btn" onclick="deleteMicRec('${id}','${url}')">ðŸ—‘ï¸</button>`;
            container.appendChild(item);
        }

        function deleteMicRec(id, url) {
            URL.revokeObjectURL(url);
            document.getElementById(`mic-${id}`)?.remove();
        }

        // UI Generation
        function generateUI() {
            // Piano
            const pianoEl = document.getElementById('piano');
            pianoNotes.forEach((note, i) => {
                const isBlack = note.includes('#');
                const key = document.createElement('button');
                key.className = `piano-key ${isBlack ? 'black' : 'white'}`;
                key.dataset.note = note;
                key.dataset.idx = i;
                key.addEventListener('mousedown', () => playPiano(note, key));
                key.addEventListener('touchstart', e => { e.preventDefault(); playPiano(note, key); }, { passive: false });
                key.addEventListener('mouseup', () => key.classList.remove('active'));
                key.addEventListener('mouseleave', () => key.classList.remove('active'));
                key.addEventListener('touchend', () => key.classList.remove('active'));
                pianoEl.appendChild(key);
            });

            // Drums - with labels
            const drumEl = document.getElementById('drumPads');
            drumPads.forEach((pad, i) => {
                const btn = document.createElement('button');
                btn.className = 'drum-pad';
                btn.style.background = pad.color;
                btn.innerHTML = `${pad.emoji}<span class="pad-label">${pad.name}</span>`;
                btn.dataset.idx = i;
                btn.addEventListener('click', () => playDrum(pad.name.toLowerCase(), btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playDrum(pad.name.toLowerCase(), btn); }, { passive: false });
                drumEl.appendChild(btn);
            });

            // Xylophone - with note labels
            const xyloEl = document.getElementById('xylophone');
            xyloNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'xylo-btn';
                btn.style.background = xyloColors[i];
                btn.innerHTML = `ðŸŽµ<span class="note-label">${note.replace(/[0-9]/g, '')}</span>`;
                btn.dataset.idx = i;
                btn.addEventListener('click', () => playXylo(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playXylo(note, btn); }, { passive: false });
                xyloEl.appendChild(btn);
            });

            // Guitar strings
            const guitarEl = document.getElementById('guitarStrings');
            guitarNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'string-btn';
                btn.style.background = guitarColors[i];
                btn.innerHTML = `ðŸŽ¸<span class="note-label">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playGuitar(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playGuitar(note, btn); }, { passive: false });
                guitarEl.appendChild(btn);
            });

            // Bells
            const bellsEl = document.getElementById('bellsGrid');
            bellNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'bell-btn';
                btn.style.background = bellColors[i];
                btn.innerHTML = `ðŸ””<span class="note-label">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playBells(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playBells(note, btn); }, { passive: false });
                bellsEl.appendChild(btn);
            });

            // Bass
            const bassEl = document.getElementById('bassGrid');
            bassNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'bass-btn';
                btn.style.background = bassColors[i];
                btn.innerHTML = `ðŸŽ»<span class="note-label">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playBass(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playBass(note, btn); }, { passive: false });
                bassEl.appendChild(btn);
            });

            // Synth Pad
            const synthEl = document.getElementById('synthGrid');
            synthNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'synth-btn';
                btn.style.background = synthColors[i];
                btn.innerHTML = `ðŸŽ›ï¸<span class="note-label">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playSynth(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playSynth(note, btn); }, { passive: false });
                synthEl.appendChild(btn);
            });

            // Harp - vertical strings
            const harpEl = document.getElementById('harpStrings');
            harpNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'harp-btn';
                btn.style.background = `linear-gradient(180deg, ${harpColors[i]} 0%, #8B7355 100%)`;
                btn.style.height = (80 + i * 5) + 'px';
                btn.addEventListener('click', () => playHarp(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playHarp(note, btn); }, { passive: false });
                harpEl.appendChild(btn);
            });

            // Kalimba - thumb piano with varying heights
            const kalimbaEl = document.getElementById('kalimbaKeys');
            kalimbaNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'kalimba-btn';
                btn.style.background = `linear-gradient(180deg, #C0C0C0 0%, ${kalimbaColors[i]} 100%)`;
                btn.style.height = kalimbaHeights[i] + 'px';
                btn.innerHTML = `<span class="inst-note-label">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playKalimba(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playKalimba(note, btn); }, { passive: false });
                kalimbaEl.appendChild(btn);
            });

            // Steel Drums - Caribbean circular pads
            const steelEl = document.getElementById('steelDrums');
            steelDrumNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'steeldrum-btn';
                btn.style.background = `radial-gradient(circle at 30% 30%, ${steelDrumColors[i]}, ${steelDrumColors[i]}88)`;
                btn.innerHTML = `ðŸŽ¶<span class="inst-note-label">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playSteelDrum(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playSteelDrum(note, btn); }, { passive: false });
                steelEl.appendChild(btn);
            });

            // Organ - church organ pipes
            const organEl = document.getElementById('organKeys');
            organNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'organ-btn';
                btn.style.background = `linear-gradient(180deg, #D4D4D4 0%, ${organColors[i]} 100%)`;
                btn.style.height = (100 - i * 3) + 'px';
                btn.innerHTML = `<span class="inst-note-label" style="color:#333">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playOrgan(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playOrgan(note, btn); }, { passive: false });
                organEl.appendChild(btn);
            });

            // Marimba - wooden bars
            const marimbaEl = document.getElementById('marimbaKeys');
            marimbaNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'marimba-btn';
                btn.style.background = `linear-gradient(180deg, ${marimbaColors[i]} 0%, #8B4513 100%)`;
                btn.style.height = marimbaHeights[i] + 'px';
                btn.innerHTML = `ðŸªµ<span class="inst-note-label">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playMarimba(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playMarimba(note, btn); }, { passive: false });
                marimbaEl.appendChild(btn);
            });

            // Flute - breathy holes
            const fluteEl = document.getElementById('fluteNotes');
            fluteNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'flute-btn';
                btn.style.background = `radial-gradient(circle, #E8E8E8 0%, ${fluteColors[i]} 100%)`;
                btn.innerHTML = `ðŸŽ<span class="inst-note-label" style="color:#666">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playFlute(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playFlute(note, btn); }, { passive: false });
                fluteEl.appendChild(btn);
            });

            // Music Box - delicate pins
            const chimesEl = document.getElementById('chimesKeys');
            chimesNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'chimes-btn';
                btn.style.background = `linear-gradient(180deg, ${chimesColors[i]} 0%, #FFB6C1 100%)`;
                btn.innerHTML = `âœ¨`;
                btn.addEventListener('click', () => playChimes(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playChimes(note, btn); }, { passive: false });
                chimesEl.appendChild(btn);
            });

            // Trumpet - bold brass
            const trumpetEl = document.getElementById('trumpetNotes');
            trumpetNotes.forEach((note, i) => {
                const btn = document.createElement('button');
                btn.className = 'trumpet-btn';
                btn.style.background = `linear-gradient(135deg, ${trumpetColors[i]} 0%, #B8860B 100%)`;
                btn.innerHTML = `ðŸŽº<span class="inst-note-label">${note.replace(/[0-9]/g, '')}</span>`;
                btn.addEventListener('click', () => playTrumpet(note, btn));
                btn.addEventListener('touchstart', e => { e.preventDefault(); playTrumpet(note, btn); }, { passive: false });
                trumpetEl.appendChild(btn);
            });

            // Sound Effects with Freesound API - Initialize category tabs and grid
            renderCategoryTabs();
            renderSoundGrid();
            renderMixer();

            // Tracks
            const trackEl = document.getElementById('trackList');
            tracks.forEach((t, i) => {
                const row = document.createElement('div');
                row.className = 'track-row';
                row.id = `track-${i}`;
                row.innerHTML = `<button class="track-play-btn" onclick="toggleTrack(${i})">â–¶ï¸</button><span class="track-name">${t.name}</span>`;
                trackEl.appendChild(row);
            });
        }

        // Sound Functions
        function playPiano(note, btn) { initAudio(); synths.piano.triggerAttackRelease(note, '8n'); animateBtn(btn); recordEvent('piano', note); if (state.settings.confetti) spawnConfetti(1); }
        function playXylo(note, btn) { initAudio(); synths.xylophone.triggerAttackRelease(note, '4n'); animateBtn(btn); recordEvent('xylophone', note); if (state.settings.confetti) spawnConfetti(2); }
        function playGuitar(note, btn) { initAudio(); synths.guitar.triggerAttack(note); animateBtn(btn); recordEvent('guitar', note); if (state.settings.confetti) spawnConfetti(2); }
        function playBells(note, btn) { initAudio(); synths.bells.triggerAttackRelease(note, '2n'); animateBtn(btn); recordEvent('bells', note); if (state.settings.confetti) spawnConfetti(3); }
        function playBass(note, btn) { initAudio(); synths.bass.triggerAttackRelease(note, '4n'); animateBtn(btn); recordEvent('bass', note); if (state.settings.confetti) spawnConfetti(1); }
        function playSynth(note, btn) { initAudio(); synths.synthPad.triggerAttackRelease(note, '2n'); animateBtn(btn); recordEvent('synth', note); if (state.settings.confetti) spawnConfetti(2); }

        // New instrument play functions
        function playHarp(note, btn) { initAudio(); synths.harp.triggerAttack(note); animateBtn(btn); recordEvent('harp', note); if (state.settings.confetti) spawnConfetti(2); }
        function playKalimba(note, btn) { initAudio(); synths.kalimba.triggerAttackRelease(note, '2n'); animateBtn(btn); recordEvent('kalimba', note); if (state.settings.confetti) spawnConfetti(2); }
        function playSteelDrum(note, btn) { initAudio(); synths.steelDrum.triggerAttackRelease(note, '4n'); animateBtn(btn); recordEvent('steeldrum', note); if (state.settings.confetti) spawnConfetti(3); }
        function playOrgan(note, btn) { initAudio(); synths.organ.triggerAttackRelease(note, '2n'); animateBtn(btn); recordEvent('organ', note); if (state.settings.confetti) spawnConfetti(1); }
        function playMarimba(note, btn) { initAudio(); synths.marimba.triggerAttackRelease(note, '4n'); animateBtn(btn); recordEvent('marimba', note); if (state.settings.confetti) spawnConfetti(2); }
        function playFlute(note, btn) { initAudio(); synths.flute.triggerAttackRelease(note, '4n'); animateBtn(btn); recordEvent('flute', note); if (state.settings.confetti) spawnConfetti(1); }
        function playChimes(note, btn) { initAudio(); synths.chimes.triggerAttackRelease(note, '2n'); animateBtn(btn); recordEvent('chimes', note); if (state.settings.confetti) spawnConfetti(3); }
        function playTrumpet(note, btn) { initAudio(); synths.trumpet.triggerAttackRelease(note, '4n'); animateBtn(btn); recordEvent('trumpet', note); if (state.settings.confetti) spawnConfetti(2); }

        function playDrum(type, btn) {
            initAudio();
            switch(type) {
                case 'kick': synths.drums.kick.triggerAttackRelease('C2', '8n'); break;
                case 'snare': synths.drums.snare.triggerAttackRelease('8n'); break;
                case 'hi-hat': synths.drums.hihat.triggerAttackRelease('C5', '16n'); break;
                case 'crash': synths.drums.hihat.triggerAttackRelease('C6', '4n'); break;
                case 'tom 1': synths.drums.tom.triggerAttackRelease('G2', '8n'); break;
                case 'tom 2': synths.drums.tom.triggerAttackRelease('D2', '8n'); break;
                case 'tom 3': synths.drums.tom.triggerAttackRelease('A2', '8n'); break;
                case 'clap': synths.drums.clap.triggerAttackRelease('16n'); break;
            }
            animateBtn(btn); recordEvent('drum', type); if (state.settings.confetti) spawnConfetti(3);
        }

        function animateBtn(btn) { if (!btn) return; btn.classList.add('active', 'playing'); setTimeout(() => btn.classList.remove('active', 'playing'), 200); }

        // Keyboard
        document.addEventListener('keydown', e => {
            if (e.repeat) return;
            const key = e.key.toLowerCase();

            if (state.instrument === 'piano') {
                const i = pianoKeys.indexOf(key);
                if (i !== -1) { const el = document.querySelector(`.piano-key[data-idx="${i}"]`); if (el) playPiano(pianoNotes[i], el); }
            } else if (state.instrument === 'xylophone') {
                const keys = ['q','w','e','r','t','y','u','i'];
                const i = keys.indexOf(key);
                if (i !== -1) { const el = document.querySelector(`#xylophone .xylo-btn[data-idx="${i}"]`); if (el) playXylo(xyloNotes[i], el); }
            } else if (state.instrument === 'drums') {
                const i = ['1','2','3','4','5','6','7','8'].indexOf(key);
                if (i !== -1) { const el = document.querySelector(`.drum-pad[data-idx="${i}"]`); if (el) playDrum(drumPads[i].name.toLowerCase(), el); }
            }
        });

        // Instrument Switch
        function switchInstrument(inst, btn) {
            state.instrument = inst;
            document.querySelectorAll('.instrument-chip').forEach(c => c.classList.remove('active'));
            btn.classList.add('active');
            document.querySelectorAll('.instrument-area').forEach(a => a.style.display = 'none');
            document.getElementById(`instrument-${inst}`).style.display = 'block';
        }

        // Tracks
        function toggleTrack(idx) {
            initAudio();
            const track = tracks[idx];
            const row = document.getElementById(`track-${idx}`);
            const btn = row.querySelector('.track-play-btn');

            if (state.currentTrack !== null && state.currentTrack !== idx) stopTrack(state.currentTrack);

            if (state.currentTrack === idx) {
                stopTrack(idx);
                state.currentTrack = null;
            } else {
                const loop = createLoop(track.pattern, track.tempo);
                loop.start(0);
                Tone.Transport.start();
                row.classList.add('playing');
                btn.innerHTML = 'â¹ï¸';
                btn.classList.add('stop');
                state.currentTrack = idx;
                showStatus(`Playing: ${track.name}`);
            }
        }

        function stopTrack(idx) {
            const row = document.getElementById(`track-${idx}`);
            const btn = row.querySelector('.track-play-btn');
            if (currentLoop) { currentLoop.stop(); Tone.Transport.stop(); }
            row.classList.remove('playing');
            btn.innerHTML = 'â–¶ï¸';
            btn.classList.remove('stop');
        }

        document.getElementById('tempoSlider').addEventListener('input', e => {
            document.getElementById('tempoValue').textContent = `${e.target.value} BPM`;
            Tone.Transport.bpm.value = e.target.value;
        });

        // Recording
        function toggleRecording() {
            const btn = document.getElementById('recBtn');
            const status = document.getElementById('recStatus');

            if (state.isRecording) {
                state.isRecording = false;
                btn.innerHTML = 'âºï¸ Record';
                status.classList.remove('active');
                status.querySelector('span').textContent = 'Ready to record your music';
                saveRecordingToStorage();
                showStatus('Recording saved!');
            } else {
                state.isRecording = true;
                state.recording = [];
                state.recordingStart = Date.now();
                btn.innerHTML = 'â¹ï¸ Stop';
                status.classList.add('active');
                status.querySelector('span').textContent = 'Recording...';
                showStatus('Recording...');
            }
        }

        function recordEvent(type, data) {
            if (!state.isRecording) return;
            state.recording.push({ type, data, time: Date.now() - state.recordingStart });
        }

        function playRecording() {
            if (!state.recording.length) { showStatus('Nothing recorded yet!'); return; }
            showStatus('Playing...');
            state.recording.forEach(ev => {
                setTimeout(() => {
                    switch(ev.type) {
                        case 'piano': synths.piano.triggerAttackRelease(ev.data, '8n'); break;
                        case 'xylophone': synths.xylophone.triggerAttackRelease(ev.data, '4n'); break;
                        case 'drum':
                            switch(ev.data) {
                                case 'kick': synths.drums.kick.triggerAttackRelease('C2', '8n'); break;
                                case 'snare': synths.drums.snare.triggerAttackRelease('8n'); break;
                                default: synths.drums.tom.triggerAttackRelease('G2', '8n');
                            }
                            break;
                        case 'effect': if (effectFns[ev.data]) effectFns[ev.data](); break;
                    }
                }, ev.time);
            });
        }

        function clearRecording() { state.recording = []; showStatus('Recording cleared!'); }

        function saveRecordingToStorage() {
            const recs = JSON.parse(localStorage.getItem('juliaRecs') || '[]');
            recs.push({ date: new Date().toLocaleString(), events: state.recording });
            while (recs.length > 5) recs.shift();
            localStorage.setItem('juliaRecs', JSON.stringify(recs));
            updateSavedRecordings();
        }

        function updateSavedRecordings() {
            const recs = JSON.parse(localStorage.getItem('juliaRecs') || '[]');
            const el = document.getElementById('savedRecordings');
            if (!recs.length) { el.innerHTML = '<p style="color:#999;font-size:0.85rem;">No saved recordings</p>'; return; }
            el.innerHTML = recs.map((r, i) => `<div class="saved-item"><button class="play" onclick="playSaved(${i})">â–¶ï¸</button><span style="flex:1">Recording ${i + 1}</span><button class="delete" onclick="deleteSaved(${i})">ðŸ—‘ï¸</button></div>`).join('');
        }

        function playSaved(i) { const recs = JSON.parse(localStorage.getItem('juliaRecs') || '[]'); if (recs[i]) { state.recording = recs[i].events; playRecording(); } }
        function deleteSaved(i) { const recs = JSON.parse(localStorage.getItem('juliaRecs') || '[]'); recs.splice(i, 1); localStorage.setItem('juliaRecs', JSON.stringify(recs)); updateSavedRecordings(); showStatus('Deleted!'); }

        // Settings
        function toggleSettingsPanel() {
            const panel = document.getElementById('settingsPanel');
            const btn = document.getElementById('settingsToggle');
            panel.classList.toggle('show');
            btn.classList.toggle('active');
        }

        function toggleSetting(key, el) {
            state.settings[key] = !state.settings[key];
            el.classList.toggle('on', state.settings[key]);
            if (key === 'bubbles') document.getElementById('bubbles').style.display = state.settings.bubbles ? 'block' : 'none';
            localStorage.setItem('juliaSettings', JSON.stringify(state.settings));
        }

        document.getElementById('volumeSlider').addEventListener('input', e => {
            state.settings.volume = e.target.value;
            Tone.getDestination().volume.value = (state.settings.volume - 80) / 2;
            localStorage.setItem('juliaSettings', JSON.stringify(state.settings));
        });

        function loadSettings() {
            const saved = localStorage.getItem('juliaSettings');
            if (saved) {
                state.settings = { ...state.settings, ...JSON.parse(saved) };
                document.getElementById('volumeSlider').value = state.settings.volume;
                document.getElementById('toggleEffects').classList.toggle('on', state.settings.effects);
                document.getElementById('toggleBubbles').classList.toggle('on', state.settings.bubbles);
                document.getElementById('toggleConfetti').classList.toggle('on', state.settings.confetti);
                document.getElementById('bubbles').style.display = state.settings.bubbles ? 'block' : 'none';
            }
        }

        function toggleMore(btn) {
            const card = btn.closest('.bento-card');
            const more = card.querySelector('.card-more');
            const isOpen = more?.classList.contains('show');
            if (more) { more.classList.toggle('show', !isOpen); btn.classList.toggle('active', !isOpen); }
        }

        // Visualizer
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            canvas.width = canvas.offsetWidth * devicePixelRatio;
            canvas.height = canvas.offsetHeight * devicePixelRatio;
            ctx.scale(devicePixelRatio, devicePixelRatio);
        }

        function drawVisualizer() {
            const w = canvas.offsetWidth, h = canvas.offsetHeight;
            ctx.fillStyle = 'rgba(26,26,46,0.3)';
            ctx.fillRect(0, 0, w, h);

            if (analyser && state.settings.effects) {
                const data = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(data);
                const barW = w / data.length * 2.5;
                let x = 0;
                const grad = ctx.createLinearGradient(0, h, 0, 0);
                grad.addColorStop(0, '#FF6B9D');
                grad.addColorStop(0.5, '#9B59B6');
                grad.addColorStop(1, '#3498DB');
                for (let i = 0; i < data.length; i++) {
                    const barH = (data[i] / 255) * h * 0.8;
                    ctx.fillStyle = grad;
                    ctx.fillRect(x, h - barH, barW - 2, barH);
                    x += barW;
                }
            } else {
                const t = Date.now() / 1000;
                const bars = 30;
                const barW = w / bars;
                for (let i = 0; i < bars; i++) {
                    const barH = Math.sin(t * 2 + i * 0.3) * 20 + 30;
                    ctx.fillStyle = `hsl(${(i / bars) * 360}, 70%, 60%)`;
                    ctx.fillRect(i * barW + 2, h - barH, barW - 4, barH);
                }
            }
            requestAnimationFrame(drawVisualizer);
        }

        // Effects
        function createBubbles() {
            const container = document.getElementById('bubbles');
            const colors = ['#FF6B9D', '#9B59B6', '#3498DB', '#2ECC71', '#F1C40F', '#E67E22'];
            for (let i = 0; i < 15; i++) {
                const b = document.createElement('div');
                b.className = 'bubble';
                b.style.left = Math.random() * 100 + '%';
                b.style.width = b.style.height = (Math.random() * 25 + 10) + 'px';
                b.style.background = colors[Math.floor(Math.random() * colors.length)];
                b.style.animationDuration = (Math.random() * 10 + 10) + 's';
                b.style.animationDelay = (Math.random() * 10) + 's';
                container.appendChild(b);
            }
        }

        function spawnConfetti(n = 5) {
            if (!state.settings.confetti) return;
            const container = document.getElementById('confetti');
            const colors = ['#FF6B9D', '#9B59B6', '#3498DB', '#2ECC71', '#F1C40F', '#E67E22'];
            const shapes = ['â– ', 'â—', 'â–²', 'â˜…'];
            for (let i = 0; i < n; i++) {
                const c = document.createElement('div');
                c.className = 'confetti';
                c.style.left = Math.random() * 100 + '%';
                c.style.top = '-20px';
                c.style.color = colors[Math.floor(Math.random() * colors.length)];
                c.style.fontSize = (Math.random() * 12 + 8) + 'px';
                c.textContent = shapes[Math.floor(Math.random() * shapes.length)];
                c.style.animationDelay = (Math.random() * 0.5) + 's';
                container.appendChild(c);
                setTimeout(() => c.remove(), 3000);
            }
        }

        function showStatus(msg) {
            const el = document.getElementById('statusToast');
            el.textContent = msg;
            el.classList.add('show');
            setTimeout(() => el.classList.remove('show'), 2500);
        }

        // ============================================
        // MAIN TAB SWITCHING
        // ============================================
        function switchMainTab(tabName, btn) {
            // Update tab buttons
            document.querySelectorAll('.main-tab').forEach(t => t.classList.remove('active'));
            btn.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');

            // Show/hide music-specific controls
            const musicControls = document.getElementById('musicControls');
            const settingsToggle = document.getElementById('settingsToggle');
            if (tabName === 'music') {
                musicControls.style.display = 'flex';
                settingsToggle.style.display = 'flex';
            } else {
                musicControls.style.display = 'none';
                settingsToggle.style.display = 'none';
            }

            // Resize appropriate paint canvas when switching to paint tab
            if (tabName === 'paint') {
                if (currentPaintMode === 'freedraw') setTimeout(resizePaintCanvas, 100);
                else if (currentPaintMode === 'colorphoto') setTimeout(resizePhotoCanvas, 100);
                else if (currentPaintMode === 'coloringbook') setTimeout(resizeColoringCanvas, 100);
            }
        }

        // ============================================
        // PAINT MODE SWITCHING
        // ============================================
        let currentPaintMode = 'freedraw';

        function switchPaintMode(mode, btn) {
            currentPaintMode = mode;
            document.querySelectorAll('.paint-sub-tab').forEach(t => t.classList.remove('active'));
            btn.classList.add('active');
            document.querySelectorAll('.paint-mode').forEach(m => m.classList.remove('active'));
            document.getElementById('paintMode-' + mode).classList.add('active');
            if (mode === 'freedraw') setTimeout(resizePaintCanvas, 100);
            else if (mode === 'colorphoto' && document.getElementById('photoEditorArea').style.display !== 'none') setTimeout(resizePhotoCanvas, 100);
            else if (mode === 'coloringbook') {
                if (document.getElementById('coloringEditorArea').style.display !== 'none') setTimeout(resizeColoringCanvas, 100);
                else renderColoringGrid();
            }
        }

        // ============================================
        // PAINT CANVAS
        // ============================================
        let paintCanvas, paintCtx;
        let isDrawing = false;
        let lastX = 0, lastY = 0;
        let currentColor = '#333333';
        let brushSize = 15;
        let isEraser = false;
        let paintHistory = [];
        let historyIndex = -1;

        const paintColors = [
            '#333333', '#FFFFFF', '#E74C3C', '#E67E22', '#F1C40F', '#2ECC71',
            '#1ABC9C', '#3498DB', '#9B59B6', '#FF6B9D', '#8B4513', '#FFD700'
        ];

        function initPaintCanvas() {
            paintCanvas = document.getElementById('paintCanvas');
            paintCtx = paintCanvas.getContext('2d');

            // Generate color buttons
            const colorContainer = document.getElementById('paintColors');
            paintColors.forEach((color, index) => {
                const btn = document.createElement('button');
                btn.className = 'color-btn' + (index === 0 ? ' active' : '');
                btn.style.background = color;
                if (color === '#FFFFFF') {
                    btn.style.border = '2px solid #ddd';
                }
                btn.onclick = () => selectColor(color, btn);
                colorContainer.appendChild(btn);
            });

            // Set up brush size slider
            const brushSlider = document.getElementById('brushSize');
            brushSlider.oninput = () => {
                brushSize = parseInt(brushSlider.value);
                updateBrushPreview();
            };
            updateBrushPreview();

            // Set up canvas
            resizePaintCanvas();

            // Mouse events
            paintCanvas.addEventListener('mousedown', startDrawing);
            paintCanvas.addEventListener('mousemove', draw);
            paintCanvas.addEventListener('mouseup', stopDrawing);
            paintCanvas.addEventListener('mouseout', stopDrawing);

            // Touch events for tablet/mobile
            paintCanvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            paintCanvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            paintCanvas.addEventListener('touchend', stopDrawing);
            paintCanvas.addEventListener('touchcancel', stopDrawing);

            // Prevent scrolling while drawing
            paintCanvas.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

            // Save initial state
            saveToHistory();
        }

        function resizePaintCanvas() {
            if (!paintCanvas) return;
            const wrapper = paintCanvas.parentElement;
            const rect = wrapper.getBoundingClientRect();

            // Save current drawing
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = paintCanvas.width;
            tempCanvas.height = paintCanvas.height;
            tempCanvas.getContext('2d').drawImage(paintCanvas, 0, 0);

            // Resize
            paintCanvas.width = rect.width - 30;
            paintCanvas.height = Math.max(400, window.innerHeight - 280);

            // Restore drawing
            paintCtx.fillStyle = 'white';
            paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            paintCtx.drawImage(tempCanvas, 0, 0);
        }

        function selectColor(color, btn) {
            currentColor = color;
            isEraser = false;
            document.getElementById('eraserBtn').classList.remove('active');
            document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            updateBrushPreview();
        }

        function toggleEraser() {
            isEraser = !isEraser;
            document.getElementById('eraserBtn').classList.toggle('active', isEraser);
            updateBrushPreview();
        }

        function updateBrushPreview() {
            const preview = document.getElementById('brushPreview');
            const size = Math.min(brushSize, 40);
            preview.style.width = size + 'px';
            preview.style.height = size + 'px';
            preview.style.background = isEraser ? '#f0f0f0' : currentColor;
            preview.style.border = isEraser ? '2px dashed #999' : 'none';
        }

        function getCanvasCoords(e) {
            const rect = paintCanvas.getBoundingClientRect();
            const scaleX = paintCanvas.width / rect.width;
            const scaleY = paintCanvas.height / rect.height;

            if (e.touches) {
                return {
                    x: (e.touches[0].clientX - rect.left) * scaleX,
                    y: (e.touches[0].clientY - rect.top) * scaleY
                };
            }
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function startDrawing(e) {
            isDrawing = true;
            const coords = getCanvasCoords(e);
            lastX = coords.x;
            lastY = coords.y;

            // Draw a dot for single clicks/taps
            paintCtx.beginPath();
            paintCtx.arc(lastX, lastY, brushSize / 2, 0, Math.PI * 2);
            paintCtx.fillStyle = isEraser ? 'white' : currentColor;
            paintCtx.fill();
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();

            const coords = getCanvasCoords(e);

            paintCtx.beginPath();
            paintCtx.moveTo(lastX, lastY);
            paintCtx.lineTo(coords.x, coords.y);
            paintCtx.strokeStyle = isEraser ? 'white' : currentColor;
            paintCtx.lineWidth = brushSize;
            paintCtx.lineCap = 'round';
            paintCtx.lineJoin = 'round';
            paintCtx.stroke();

            lastX = coords.x;
            lastY = coords.y;
        }

        function stopDrawing() {
            if (isDrawing) {
                isDrawing = false;
                saveToHistory();
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            startDrawing(e);
        }

        function handleTouchMove(e) {
            e.preventDefault();
            draw(e);
        }

        function saveToHistory() {
            // Remove any redo states
            paintHistory = paintHistory.slice(0, historyIndex + 1);
            // Save current state
            paintHistory.push(paintCanvas.toDataURL());
            historyIndex++;
            // Limit history size
            if (paintHistory.length > 50) {
                paintHistory.shift();
                historyIndex--;
            }
        }

        function undoPaint() {
            if (historyIndex > 0) {
                historyIndex--;
                const img = new Image();
                img.onload = () => {
                    paintCtx.fillStyle = 'white';
                    paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
                    paintCtx.drawImage(img, 0, 0);
                };
                img.src = paintHistory[historyIndex];
                showStatus('Undo!');
            }
        }

        function clearCanvas() {
            paintCtx.fillStyle = 'white';
            paintCtx.fillRect(0, 0, paintCanvas.width, paintCanvas.height);
            saveToHistory();
            showStatus('Canvas cleared!');
        }

        function saveCanvas() {
            const link = document.createElement('a');
            link.download = 'julia-painting-' + Date.now() + '.png';
            link.href = paintCanvas.toDataURL();
            link.click();
            showStatus('Painting saved!');
        }

        // ============================================
        // SHARED DRAWING ENGINE
        // ============================================
        function createDrawingEngine(cfg) {
            let isDrawing = false, lastX = 0, lastY = 0;
            let currentColor = cfg.defaultColor || '#E74C3C';
            let bSize = 15, isEraser = false;
            let history = [], historyIdx = -1;

            const engine = {
                get canvas() { return document.getElementById(cfg.canvasId); },
                get ctx() { const c = engine.canvas; return c ? c.getContext('2d') : null; },
                getCoords(e) {
                    const c = engine.canvas, rect = c.getBoundingClientRect();
                    const sx = c.width / rect.width, sy = c.height / rect.height;
                    if (e.touches) return { x: (e.touches[0].clientX - rect.left) * sx, y: (e.touches[0].clientY - rect.top) * sy };
                    return { x: (e.clientX - rect.left) * sx, y: (e.clientY - rect.top) * sy };
                },
                startDrawing(e) {
                    isDrawing = true;
                    const coords = engine.getCoords(e);
                    lastX = coords.x; lastY = coords.y;
                    engine.ctx.beginPath();
                    engine.ctx.arc(lastX, lastY, bSize / 2, 0, Math.PI * 2);
                    engine.ctx.fillStyle = isEraser ? 'white' : currentColor;
                    engine.ctx.fill();
                },
                draw(e) {
                    if (!isDrawing) return;
                    e.preventDefault();
                    const coords = engine.getCoords(e);
                    const ctx = engine.ctx;
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(coords.x, coords.y);
                    ctx.strokeStyle = isEraser ? 'white' : currentColor;
                    ctx.lineWidth = bSize;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();
                    lastX = coords.x; lastY = coords.y;
                },
                stopDrawing() {
                    if (isDrawing) { isDrawing = false; engine.saveToHistory(); }
                },
                saveToHistory() {
                    history = history.slice(0, historyIdx + 1);
                    history.push(engine.canvas.toDataURL());
                    historyIdx++;
                    if (history.length > 30) { history.shift(); historyIdx--; }
                },
                undo() {
                    if (historyIdx > 0) {
                        historyIdx--;
                        const img = new Image();
                        img.onload = () => { engine.ctx.fillStyle = 'white'; engine.ctx.fillRect(0, 0, engine.canvas.width, engine.canvas.height); engine.ctx.drawImage(img, 0, 0); };
                        img.src = history[historyIdx];
                        showStatus('Undo!');
                    }
                },
                save(prefix) {
                    const link = document.createElement('a');
                    link.download = prefix + Date.now() + '.png';
                    link.href = engine.canvas.toDataURL();
                    link.click();
                    showStatus('Saved!');
                },
                selectColor(color, btn) {
                    currentColor = color;
                    isEraser = false;
                    if (cfg.eraserBtnId) document.getElementById(cfg.eraserBtnId).classList.remove('active');
                    const container = document.getElementById(cfg.colorsId);
                    container.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    engine.updatePreview();
                },
                toggleEraser() {
                    isEraser = !isEraser;
                    if (cfg.eraserBtnId) document.getElementById(cfg.eraserBtnId).classList.toggle('active', isEraser);
                    engine.updatePreview();
                },
                updatePreview() {
                    const preview = document.getElementById(cfg.previewId);
                    if (!preview) return;
                    const size = Math.min(bSize, 40);
                    preview.style.width = size + 'px';
                    preview.style.height = size + 'px';
                    preview.style.background = isEraser ? '#f0f0f0' : currentColor;
                    preview.style.border = isEraser ? '2px dashed #999' : 'none';
                },
                initColors() {
                    const container = document.getElementById(cfg.colorsId);
                    if (!container) return;
                    paintColors.forEach((color, i) => {
                        const btn = document.createElement('button');
                        btn.className = 'color-btn' + (color === (cfg.defaultColor || '#333333') ? ' active' : '');
                        btn.style.background = color;
                        if (color === '#FFFFFF') btn.style.border = '2px solid #ddd';
                        btn.onclick = () => engine.selectColor(color, btn);
                        container.appendChild(btn);
                    });
                },
                initBrushSlider() {
                    const slider = document.getElementById(cfg.brushSliderId);
                    if (!slider) return;
                    slider.oninput = () => { bSize = parseInt(slider.value); engine.updatePreview(); };
                    engine.updatePreview();
                },
                setupEvents() {
                    const c = engine.canvas;
                    if (!c) return;
                    c.addEventListener('mousedown', (e) => engine.startDrawing(e));
                    c.addEventListener('mousemove', (e) => engine.draw(e));
                    c.addEventListener('mouseup', () => engine.stopDrawing());
                    c.addEventListener('mouseout', () => engine.stopDrawing());
                    c.addEventListener('touchstart', (e) => { e.preventDefault(); engine.startDrawing(e); }, { passive: false });
                    c.addEventListener('touchmove', (e) => { e.preventDefault(); engine.draw(e); }, { passive: false });
                    c.addEventListener('touchend', () => engine.stopDrawing());
                    c.addEventListener('touchcancel', () => engine.stopDrawing());
                },
                resize() {
                    const c = engine.canvas;
                    if (!c) return;
                    const wrapper = c.parentElement;
                    const rect = wrapper.getBoundingClientRect();
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = c.width; tempCanvas.height = c.height;
                    tempCanvas.getContext('2d').drawImage(c, 0, 0);
                    c.width = rect.width - 30;
                    c.height = Math.max(400, window.innerHeight - 280);
                    engine.ctx.fillStyle = 'white';
                    engine.ctx.fillRect(0, 0, c.width, c.height);
                    engine.ctx.drawImage(tempCanvas, 0, 0);
                },
                resetHistory() { history = []; historyIdx = -1; },
                clearAndDraw(drawFn) {
                    const c = engine.canvas;
                    engine.ctx.fillStyle = 'white';
                    engine.ctx.fillRect(0, 0, c.width, c.height);
                    if (drawFn) drawFn(engine.ctx, c.width, c.height);
                    history = [c.toDataURL()];
                    historyIdx = 0;
                }
            };
            return engine;
        }

        // ============================================
        // COLOR A PHOTO
        // ============================================
        let photoOriginalImage = null;
        let photoRefVisible = true;
        let photoSensitivity = 80;
        const photoEngine = createDrawingEngine({
            canvasId: 'photoCanvas', colorsId: 'photoPaintColors',
            brushSliderId: 'photoBrushSize', previewId: 'photoBrushPreview',
            eraserBtnId: 'photoEraserBtn', defaultColor: '#E74C3C'
        });

        function initPhotoUpload() {
            const uploadArea = document.getElementById('photoUploadArea');
            const fileInput = document.getElementById('photoFileInput');
            uploadArea.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', (e) => { if (e.target.files.length > 0) processPhotoFile(e.target.files[0]); });
            uploadArea.addEventListener('dragover', (e) => { e.preventDefault(); uploadArea.classList.add('dragover'); });
            uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault(); uploadArea.classList.remove('dragover');
                if (e.dataTransfer.files.length > 0) processPhotoFile(e.dataTransfer.files[0]);
            });
            document.getElementById('sensitivitySlider').addEventListener('input', (e) => {
                photoSensitivity = parseInt(e.target.value);
                if (photoOriginalImage) reprocessPhoto();
            });
            photoEngine.initColors();
            photoEngine.initBrushSlider();
        }

        function processPhotoFile(file) {
            if (!file.type.startsWith('image/')) { showStatus('Please upload an image!'); return; }
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => { photoOriginalImage = img; showPhotoEditor(); processImageToOutline(img); };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function showPhotoEditor() {
            document.getElementById('photoUploadArea').style.display = 'none';
            document.getElementById('photoEditorArea').style.display = 'block';
            resizePhotoCanvas();
            photoEngine.setupEvents();
            showStatus('Photo loaded! Color it! âœ¨');
        }

        function showPhotoUpload() {
            document.getElementById('photoUploadArea').style.display = 'block';
            document.getElementById('photoEditorArea').style.display = 'none';
            photoOriginalImage = null;
            photoEngine.resetHistory();
        }

        function resizePhotoCanvas() {
            const c = document.getElementById('photoCanvas');
            if (!c) return;
            const wrapper = c.parentElement;
            const rect = wrapper.getBoundingClientRect();
            c.width = rect.width - 30;
            c.height = Math.max(400, window.innerHeight - 280);
            if (photoOriginalImage) processImageToOutline(photoOriginalImage);
        }

        function processImageToOutline(img) {
            const c = document.getElementById('photoCanvas');
            const ctx = c.getContext('2d');
            const cw = c.width, ch = c.height;
            // Scale image to fit
            const maxDim = 800;
            let iw = img.width, ih = img.height;
            if (iw > maxDim || ih > maxDim) {
                const r = Math.min(maxDim / iw, maxDim / ih);
                iw = Math.round(iw * r); ih = Math.round(ih * r);
            }
            const scale = Math.min(cw / iw, ch / ih);
            const sw = iw * scale, sh = ih * scale;
            const ox = (cw - sw) / 2, oy = (ch - sh) / 2;

            const hc = document.createElement('canvas');
            hc.width = cw; hc.height = ch;
            const hCtx = hc.getContext('2d');
            hCtx.fillStyle = 'white';
            hCtx.fillRect(0, 0, cw, ch);
            hCtx.drawImage(img, ox, oy, sw, sh);

            const imageData = hCtx.getImageData(0, 0, cw, ch);
            const data = imageData.data;
            const gray = new Float32Array(cw * ch);
            for (let i = 0; i < cw * ch; i++) {
                gray[i] = 0.299 * data[i * 4] + 0.587 * data[i * 4 + 1] + 0.114 * data[i * 4 + 2];
            }

            // Gaussian blur
            const blurred = gaussianBlur(gray, cw, ch);
            // Sobel edge detection
            const edges = sobelEdge(blurred, cw, ch);
            // Threshold
            const threshold = 255 - photoSensitivity;
            const output = hCtx.createImageData(cw, ch);
            for (let i = 0; i < cw * ch; i++) {
                const val = edges[i] > threshold ? 0 : 255;
                output.data[i * 4] = val; output.data[i * 4 + 1] = val; output.data[i * 4 + 2] = val; output.data[i * 4 + 3] = 255;
            }
            ctx.putImageData(output, 0, 0);

            // Reference thumbnail
            const refC = document.getElementById('photoRefCanvas');
            refC.width = 150; refC.height = Math.round(150 * (ch / cw));
            refC.getContext('2d').drawImage(img, 0, 0, refC.width, refC.height);

            photoEngine.resetHistory();
            photoEngine.saveToHistory();
        }

        function gaussianBlur(gray, w, h) {
            const k = [1,2,1,2,4,2,1,2,1], result = new Float32Array(w * h);
            for (let y = 1; y < h - 1; y++) for (let x = 1; x < w - 1; x++) {
                let s = 0, ki = 0;
                for (let ky = -1; ky <= 1; ky++) for (let kx = -1; kx <= 1; kx++) s += gray[(y + ky) * w + (x + kx)] * k[ki++];
                result[y * w + x] = s / 16;
            }
            return result;
        }

        function sobelEdge(gray, w, h) {
            const gxk = [-1,0,1,-2,0,2,-1,0,1], gyk = [-1,-2,-1,0,0,0,1,2,1];
            const edges = new Float32Array(w * h);
            for (let y = 1; y < h - 1; y++) for (let x = 1; x < w - 1; x++) {
                let gx = 0, gy = 0, ki = 0;
                for (let ky = -1; ky <= 1; ky++) for (let kx = -1; kx <= 1; kx++) {
                    const v = gray[(y + ky) * w + (x + kx)];
                    gx += v * gxk[ki]; gy += v * gyk[ki]; ki++;
                }
                edges[y * w + x] = Math.sqrt(gx * gx + gy * gy);
            }
            let max = 0;
            for (let i = 0; i < edges.length; i++) if (edges[i] > max) max = edges[i];
            if (max > 0) for (let i = 0; i < edges.length; i++) edges[i] = (edges[i] / max) * 255;
            return edges;
        }

        function reprocessPhoto() {
            if (photoOriginalImage) { processImageToOutline(photoOriginalImage); showStatus('Outlines redrawn!'); }
        }
        function togglePhotoEraser() { photoEngine.toggleEraser(); }
        function undoPhotoCanvas() { photoEngine.undo(); }
        function savePhotoCanvas() { photoEngine.save('julia-coloring-'); }
        function togglePhotoRef() {
            photoRefVisible = !photoRefVisible;
            document.getElementById('photoRefThumb').style.display = photoRefVisible ? 'block' : 'none';
            document.getElementById('photoRefToggle').textContent = photoRefVisible ? 'ðŸ‘ï¸ Hide Original' : 'ðŸ‘ï¸ Show Original';
        }

        // ============================================
        // COLORING BOOK
        // ============================================
        let currentColoringCategory = 'animals';
        let currentColoringOutline = null;
        let coloringRefVisible = false;

        const coloringEngine = createDrawingEngine({
            canvasId: 'coloringCanvas', colorsId: 'coloringPaintColors',
            brushSliderId: 'coloringBrushSize', previewId: 'coloringBrushPreview',
            eraserBtnId: 'coloringEraserBtn', defaultColor: '#E74C3C'
        });

        const coloringCategories = {
            animals: { name: 'ðŸ¾ Animals', color: '#FF6B9D', items: [
                { id: 'cat', name: 'Cat', emoji: 'ðŸ±', draw: drawCat },
                { id: 'dog', name: 'Dog', emoji: 'ðŸ¶', draw: drawDog },
                { id: 'butterfly', name: 'Butterfly', emoji: 'ðŸ¦‹', draw: drawButterfly },
                { id: 'fish', name: 'Fish', emoji: 'ðŸŸ', draw: drawFish },
                { id: 'rabbit', name: 'Rabbit', emoji: 'ðŸ°', draw: drawRabbit },
                { id: 'bird', name: 'Bird', emoji: 'ðŸ¦', draw: drawBird }
            ]},
            nature: { name: 'ðŸŒ¿ Nature', color: '#2ECC71', items: [
                { id: 'tree', name: 'Tree', emoji: 'ðŸŒ³', draw: drawTree },
                { id: 'flower', name: 'Flower', emoji: 'ðŸŒ¸', draw: drawFlower },
                { id: 'sun', name: 'Sun', emoji: 'â˜€ï¸', draw: drawSun },
                { id: 'cloud', name: 'Cloud', emoji: 'â˜ï¸', draw: drawCloud },
                { id: 'mountain', name: 'Mountain', emoji: 'ðŸ”ï¸', draw: drawMountain },
                { id: 'rainbow', name: 'Rainbow', emoji: 'ðŸŒˆ', draw: drawRainbow }
            ]},
            vehicles: { name: 'ðŸš— Vehicles', color: '#3498DB', items: [
                { id: 'car', name: 'Car', emoji: 'ðŸš—', draw: drawCar },
                { id: 'boat', name: 'Boat', emoji: 'â›µ', draw: drawBoat },
                { id: 'rocket', name: 'Rocket', emoji: 'ðŸš€', draw: drawRocket },
                { id: 'airplane', name: 'Airplane', emoji: 'âœˆï¸', draw: drawAirplane },
                { id: 'train', name: 'Train', emoji: 'ðŸš‚', draw: drawTrain },
                { id: 'bicycle', name: 'Bicycle', emoji: 'ðŸš²', draw: drawBicycle }
            ]},
            fantasy: { name: 'ðŸ° Fantasy', color: '#9B59B6', items: [
                { id: 'castle', name: 'Castle', emoji: 'ðŸ°', draw: drawCastle },
                { id: 'crown', name: 'Crown', emoji: 'ðŸ‘‘', draw: drawCrown },
                { id: 'unicorn', name: 'Unicorn', emoji: 'ðŸ¦„', draw: drawUnicorn },
                { id: 'star', name: 'Star', emoji: 'â­', draw: drawStar },
                { id: 'dragon', name: 'Dragon', emoji: 'ðŸ‰', draw: drawDragon },
                { id: 'fairy', name: 'Fairy', emoji: 'ðŸ§š', draw: drawFairy }
            ]},
            food: { name: 'ðŸ• Food', color: '#E67E22', items: [
                { id: 'icecream', name: 'Ice Cream', emoji: 'ðŸ¦', draw: drawIceCream },
                { id: 'pizza', name: 'Pizza', emoji: 'ðŸ•', draw: drawPizza },
                { id: 'cake', name: 'Cake', emoji: 'ðŸŽ‚', draw: drawCake },
                { id: 'apple', name: 'Apple', emoji: 'ðŸŽ', draw: drawApple },
                { id: 'cupcake', name: 'Cupcake', emoji: 'ðŸ§', draw: drawCupcake },
                { id: 'candy', name: 'Candy', emoji: 'ðŸ¬', draw: drawCandy }
            ]},
            sea: { name: 'ðŸŒŠ Sea', color: '#1ABC9C', items: [
                { id: 'whale', name: 'Whale', emoji: 'ðŸ‹', draw: drawWhale },
                { id: 'octopus', name: 'Octopus', emoji: 'ðŸ™', draw: drawOctopus },
                { id: 'seahorse', name: 'Seahorse', emoji: 'ðŸŒŠ', draw: drawSeahorse },
                { id: 'starfish', name: 'Starfish', emoji: 'â­', draw: drawStarfish },
                { id: 'turtle', name: 'Turtle', emoji: 'ðŸ¢', draw: drawTurtle },
                { id: 'shell', name: 'Shell', emoji: 'ðŸš', draw: drawShell }
            ]},
            space: { name: 'ðŸš€ Space', color: '#34495E', items: [
                { id: 'planet', name: 'Planet', emoji: 'ðŸª', draw: drawPlanet },
                { id: 'astronaut', name: 'Astronaut', emoji: 'ðŸ‘¨â€ðŸš€', draw: drawAstronaut },
                { id: 'ufo', name: 'UFO', emoji: 'ðŸ›¸', draw: drawUfo },
                { id: 'moon', name: 'Moon', emoji: 'ðŸŒ™', draw: drawMoon },
                { id: 'satellite', name: 'Satellite', emoji: 'ðŸ›°ï¸', draw: drawSatellite },
                { id: 'comet', name: 'Comet', emoji: 'â˜„ï¸', draw: drawComet }
            ]},
            fun: { name: 'ðŸŽ€ Fun', color: '#FF6B9D', items: [
                { id: 'balloon', name: 'Balloon', emoji: 'ðŸŽˆ', draw: drawBalloon },
                { id: 'heart', name: 'Heart', emoji: 'â¤ï¸', draw: drawHeart },
                { id: 'guitar', name: 'Guitar', emoji: 'ðŸŽ¸', draw: drawGuitar },
                { id: 'present', name: 'Present', emoji: 'ðŸŽ', draw: drawPresent },
                { id: 'kite', name: 'Kite', emoji: 'ðŸª', draw: drawKite },
                { id: 'teddy', name: 'Teddy Bear', emoji: 'ðŸ§¸', draw: drawTeddy }
            ]}
        };

        function renderColoringCategoryTabs() {
            const container = document.getElementById('coloringCategoryTabs');
            container.innerHTML = Object.keys(coloringCategories).map(key => {
                const cat = coloringCategories[key];
                const label = cat.name.split(' ').slice(1).join(' ');
                return '<button class="coloring-category-tab' + (key === currentColoringCategory ? ' active' : '') +
                    '" onclick="switchColoringCategory(\'' + key + '\', this)">' + cat.name.split(' ')[0] + ' ' + label + '</button>';
            }).join('');
        }

        function switchColoringCategory(key, btn) {
            currentColoringCategory = key;
            document.querySelectorAll('.coloring-category-tab').forEach(t => t.classList.remove('active'));
            btn.classList.add('active');
            renderColoringGrid();
        }

        function renderColoringGrid() {
            const container = document.getElementById('coloringGrid');
            const cat = coloringCategories[currentColoringCategory];
            container.innerHTML = cat.items.map((item, i) =>
                '<div class="coloring-card" onclick="openColoringPage(\'' + currentColoringCategory + '\',' + i + ')">' +
                '<canvas id="thumb-' + item.id + '" width="140" height="140"></canvas>' +
                '<div class="coloring-card-label">' + item.emoji + ' ' + item.name + '</div></div>'
            ).join('');
            // Draw thumbnails
            cat.items.forEach(item => {
                const tc = document.getElementById('thumb-' + item.id);
                if (tc) {
                    const tCtx = tc.getContext('2d');
                    tCtx.fillStyle = 'white';
                    tCtx.fillRect(0, 0, 140, 140);
                    item.draw(tCtx, 140, 140);
                }
            });
        }

        function openColoringPage(catKey, idx) {
            const item = coloringCategories[catKey].items[idx];
            currentColoringOutline = item;
            document.getElementById('coloringGallery').style.display = 'none';
            document.getElementById('coloringEditorArea').style.display = 'block';
            resizeColoringCanvas();
            coloringEngine.setupEvents();
            coloringEngine.clearAndDraw(item.draw);
            showStatus('Color the ' + item.name + '!');
        }

        function resizeColoringCanvas() {
            const c = document.getElementById('coloringCanvas');
            if (!c) return;
            const wrapper = c.parentElement;
            const rect = wrapper.getBoundingClientRect();
            c.width = rect.width - 30;
            c.height = Math.max(400, window.innerHeight - 280);
            if (currentColoringOutline) {
                const ctx = c.getContext('2d');
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, c.width, c.height);
                currentColoringOutline.draw(ctx, c.width, c.height);
            }
        }

        function reloadColoringOutline() {
            if (currentColoringOutline) { coloringEngine.clearAndDraw(currentColoringOutline.draw); showStatus('Starting fresh!'); }
        }

        function backToColoringGallery() {
            document.getElementById('coloringGallery').style.display = 'block';
            document.getElementById('coloringEditorArea').style.display = 'none';
            currentColoringOutline = null;
            coloringEngine.resetHistory();
            renderColoringGrid();
        }

        function toggleColoringEraser() { coloringEngine.toggleEraser(); }
        function undoColoringCanvas() { coloringEngine.undo(); }
        function saveColoringCanvas() { coloringEngine.save('julia-coloring-book-'); }
        function toggleColoringRef() {
            coloringRefVisible = !coloringRefVisible;
            document.getElementById('coloringRefThumb').style.display = coloringRefVisible ? 'block' : 'none';
        }


        // ============================================
        // COLORING BOOK OUTLINES (48 drawings)
        // ============================================
        function drawCat(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Body oval
          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.3, s * 0.5, s * 0.4, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Head
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.35, s * 0.35, 0, Math.PI * 2);
          ctx.stroke();

          // Left ear
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.28, cy - s * 0.6);
          ctx.lineTo(cx - s * 0.4, cy - s * 0.95);
          ctx.lineTo(cx - s * 0.08, cy - s * 0.65);
          ctx.closePath();
          ctx.stroke();

          // Right ear
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.28, cy - s * 0.6);
          ctx.lineTo(cx + s * 0.4, cy - s * 0.95);
          ctx.lineTo(cx + s * 0.08, cy - s * 0.65);
          ctx.closePath();
          ctx.stroke();

          // Eyes
          ctx.beginPath();
          ctx.arc(cx - s * 0.12, cy - s * 0.4, s * 0.045, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(cx + s * 0.12, cy - s * 0.4, s * 0.045, 0, Math.PI * 2);
          ctx.fill();

          // Nose
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.25);
          ctx.lineTo(cx - s * 0.04, cy - s * 0.2);
          ctx.lineTo(cx + s * 0.04, cy - s * 0.2);
          ctx.closePath();
          ctx.stroke();

          // Whiskers
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy - s * 0.22);
          ctx.lineTo(cx - s * 0.45, cy - s * 0.3);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy - s * 0.18);
          ctx.lineTo(cx - s * 0.45, cy - s * 0.15);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.1, cy - s * 0.22);
          ctx.lineTo(cx + s * 0.45, cy - s * 0.3);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.1, cy - s * 0.18);
          ctx.lineTo(cx + s * 0.45, cy - s * 0.15);
          ctx.stroke();

          // Tail
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.45, cy + s * 0.4);
          ctx.bezierCurveTo(cx + s * 0.8, cy + s * 0.1, cx + s * 0.9, cy - s * 0.2, cx + s * 0.65, cy - s * 0.1);
          ctx.stroke();
        }

        function drawDog(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Body
          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.25, s * 0.55, s * 0.4, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Head
          ctx.beginPath();
          ctx.arc(cx - s * 0.05, cy - s * 0.35, s * 0.32, 0, Math.PI * 2);
          ctx.stroke();

          // Snout
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.05, cy - s * 0.15, s * 0.15, s * 0.1, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Nose
          ctx.beginPath();
          ctx.arc(cx - s * 0.05, cy - s * 0.18, s * 0.04, 0, Math.PI * 2);
          ctx.fill();

          // Eyes
          ctx.beginPath();
          ctx.arc(cx - s * 0.15, cy - s * 0.42, s * 0.04, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(cx + s * 0.08, cy - s * 0.42, s * 0.04, 0, Math.PI * 2);
          ctx.fill();

          // Left floppy ear
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.3, cy - s * 0.5);
          ctx.bezierCurveTo(cx - s * 0.55, cy - s * 0.45, cx - s * 0.6, cy - s * 0.1, cx - s * 0.38, cy - s * 0.08);
          ctx.stroke();

          // Right floppy ear
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.22, cy - s * 0.55);
          ctx.bezierCurveTo(cx + s * 0.48, cy - s * 0.5, cx + s * 0.52, cy - s * 0.15, cx + s * 0.32, cy - s * 0.1);
          ctx.stroke();

          // Legs
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.3, cy + s * 0.55);
          ctx.lineTo(cx - s * 0.3, cy + s * 0.85);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy + s * 0.6);
          ctx.lineTo(cx - s * 0.1, cy + s * 0.85);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy + s * 0.6);
          ctx.lineTo(cx + s * 0.15, cy + s * 0.85);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.35, cy + s * 0.55);
          ctx.lineTo(cx + s * 0.35, cy + s * 0.85);
          ctx.stroke();

          // Tail
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy + s * 0.05);
          ctx.bezierCurveTo(cx + s * 0.75, cy - s * 0.2, cx + s * 0.85, cy - s * 0.4, cx + s * 0.7, cy - s * 0.5);
          ctx.stroke();
        }

        function drawButterfly(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Body
          ctx.beginPath();
          ctx.ellipse(cx, cy, s * 0.06, s * 0.45, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Top-left wing
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.15);
          ctx.bezierCurveTo(cx - s * 0.4, cy - s * 0.8, cx - s * 0.9, cy - s * 0.5, cx - s * 0.05, cy - s * 0.05);
          ctx.stroke();

          // Top-right wing
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.15);
          ctx.bezierCurveTo(cx + s * 0.4, cy - s * 0.8, cx + s * 0.9, cy - s * 0.5, cx + s * 0.05, cy - s * 0.05);
          ctx.stroke();

          // Bottom-left wing
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.05);
          ctx.bezierCurveTo(cx - s * 0.35, cy + s * 0.1, cx - s * 0.7, cy + s * 0.5, cx - s * 0.05, cy + s * 0.25);
          ctx.stroke();

          // Bottom-right wing
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.05);
          ctx.bezierCurveTo(cx + s * 0.35, cy + s * 0.1, cx + s * 0.7, cy + s * 0.5, cx + s * 0.05, cy + s * 0.25);
          ctx.stroke();

          // Wing inner circles (decorations)
          ctx.beginPath();
          ctx.arc(cx - s * 0.35, cy - s * 0.3, s * 0.1, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.35, cy - s * 0.3, s * 0.1, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx - s * 0.28, cy + s * 0.2, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.28, cy + s * 0.2, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();

          // Antennae
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.02, cy - s * 0.4);
          ctx.bezierCurveTo(cx - s * 0.15, cy - s * 0.7, cx - s * 0.25, cy - s * 0.8, cx - s * 0.3, cy - s * 0.85);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx - s * 0.3, cy - s * 0.85, s * 0.03, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.02, cy - s * 0.4);
          ctx.bezierCurveTo(cx + s * 0.15, cy - s * 0.7, cx + s * 0.25, cy - s * 0.8, cx + s * 0.3, cy - s * 0.85);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.3, cy - s * 0.85, s * 0.03, 0, Math.PI * 2);
          ctx.stroke();
        }

        function drawFish(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Body oval
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.05, cy, s * 0.6, s * 0.35, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Tail fin
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy - s * 0.1);
          ctx.lineTo(cx + s * 0.85, cy - s * 0.35);
          ctx.lineTo(cx + s * 0.85, cy + s * 0.35);
          ctx.lineTo(cx + s * 0.5, cy + s * 0.1);
          ctx.stroke();

          // Dorsal fin
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.15, cy - s * 0.35);
          ctx.bezierCurveTo(cx - s * 0.05, cy - s * 0.7, cx + s * 0.25, cy - s * 0.65, cx + s * 0.2, cy - s * 0.32);
          ctx.stroke();

          // Eye
          ctx.beginPath();
          ctx.arc(cx - s * 0.3, cy - s * 0.05, s * 0.06, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx - s * 0.3, cy - s * 0.05, s * 0.03, 0, Math.PI * 2);
          ctx.fill();

          // Mouth
          ctx.beginPath();
          ctx.arc(cx - s * 0.58, cy + s * 0.02, s * 0.08, -0.4, 0.4);
          ctx.stroke();

          // Scales pattern
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.arc(cx - s * 0.1 + i * s * 0.18, cy, s * 0.12, 0.3, Math.PI - 0.3);
            ctx.stroke();
          }

          // Bottom fin
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.3);
          ctx.bezierCurveTo(cx + s * 0.05, cy + s * 0.55, cx + s * 0.2, cy + s * 0.5, cx + s * 0.15, cy + s * 0.32);
          ctx.stroke();
        }

        function drawRabbit(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Body
          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.3, s * 0.45, s * 0.4, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Head
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.25, s * 0.3, 0, Math.PI * 2);
          ctx.stroke();

          // Left ear
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.18, cy - s * 0.75, s * 0.08, s * 0.3, -0.15, 0, Math.PI * 2);
          ctx.stroke();

          // Left ear inner
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.18, cy - s * 0.75, s * 0.04, s * 0.2, -0.15, 0, Math.PI * 2);
          ctx.stroke();

          // Right ear
          ctx.beginPath();
          ctx.ellipse(cx + s * 0.18, cy - s * 0.75, s * 0.08, s * 0.3, 0.15, 0, Math.PI * 2);
          ctx.stroke();

          // Right ear inner
          ctx.beginPath();
          ctx.ellipse(cx + s * 0.18, cy - s * 0.75, s * 0.04, s * 0.2, 0.15, 0, Math.PI * 2);
          ctx.stroke();

          // Eyes
          ctx.beginPath();
          ctx.arc(cx - s * 0.1, cy - s * 0.3, s * 0.04, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(cx + s * 0.1, cy - s * 0.3, s * 0.04, 0, Math.PI * 2);
          ctx.fill();

          // Nose
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.15);
          ctx.lineTo(cx - s * 0.04, cy - s * 0.11);
          ctx.lineTo(cx + s * 0.04, cy - s * 0.11);
          ctx.closePath();
          ctx.stroke();

          // Whiskers
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.08, cy - s * 0.12);
          ctx.lineTo(cx - s * 0.4, cy - s * 0.18);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.08, cy - s * 0.08);
          ctx.lineTo(cx - s * 0.4, cy - s * 0.05);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.08, cy - s * 0.12);
          ctx.lineTo(cx + s * 0.4, cy - s * 0.18);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.08, cy - s * 0.08);
          ctx.lineTo(cx + s * 0.4, cy - s * 0.05);
          ctx.stroke();

          // Fluffy tail
          ctx.beginPath();
          ctx.arc(cx + s * 0.4, cy + s * 0.35, s * 0.12, 0, Math.PI * 2);
          ctx.stroke();
        }

        function drawBird(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Body
          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.1, s * 0.45, s * 0.3, -0.15, 0, Math.PI * 2);
          ctx.stroke();

          // Head
          ctx.beginPath();
          ctx.arc(cx - s * 0.35, cy - s * 0.2, s * 0.22, 0, Math.PI * 2);
          ctx.stroke();

          // Eye
          ctx.beginPath();
          ctx.arc(cx - s * 0.4, cy - s * 0.25, s * 0.04, 0, Math.PI * 2);
          ctx.fill();

          // Beak
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, cy - s * 0.2);
          ctx.lineTo(cx - s * 0.75, cy - s * 0.15);
          ctx.lineTo(cx - s * 0.55, cy - s * 0.12);
          ctx.closePath();
          ctx.stroke();

          // Wing
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.05, cy - s * 0.05);
          ctx.bezierCurveTo(cx + s * 0.15, cy - s * 0.35, cx + s * 0.45, cy - s * 0.3, cx + s * 0.35, cy + s * 0.05);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.35, cy + s * 0.05);
          ctx.bezierCurveTo(cx + s * 0.25, cy - s * 0.1, cx + s * 0.1, cy - s * 0.05, cx - s * 0.05, cy + s * 0.1);
          ctx.stroke();

          // Tail feathers
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.4, cy + s * 0.0);
          ctx.lineTo(cx + s * 0.75, cy - s * 0.15);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.42, cy + s * 0.07);
          ctx.lineTo(cx + s * 0.8, cy + s * 0.0);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.4, cy + s * 0.14);
          ctx.lineTo(cx + s * 0.75, cy + s * 0.15);
          ctx.stroke();

          // Legs
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy + s * 0.35);
          ctx.lineTo(cx - s * 0.15, cy + s * 0.65);
          ctx.lineTo(cx - s * 0.28, cy + s * 0.7);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.15, cy + s * 0.65);
          ctx.lineTo(cx - s * 0.05, cy + s * 0.72);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.05, cy + s * 0.37);
          ctx.lineTo(cx + s * 0.0, cy + s * 0.65);
          ctx.lineTo(cx - s * 0.12, cy + s * 0.7);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.0, cy + s * 0.65);
          ctx.lineTo(cx + s * 0.1, cy + s * 0.72);
          ctx.stroke();
        }

        function drawTree(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Trunk
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.12, cy + s * 0.9);
          ctx.lineTo(cx - s * 0.12, cy + s * 0.1);
          ctx.lineTo(cx + s * 0.12, cy + s * 0.1);
          ctx.lineTo(cx + s * 0.12, cy + s * 0.9);
          ctx.closePath();
          ctx.stroke();

          // Canopy - three overlapping circles
          ctx.beginPath();
          ctx.arc(cx - s * 0.35, cy - s * 0.15, s * 0.4, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx + s * 0.35, cy - s * 0.15, s * 0.4, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.5, s * 0.42, 0, Math.PI * 2);
          ctx.stroke();

          // Ground line
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.7, cy + s * 0.9);
          ctx.lineTo(cx + s * 0.7, cy + s * 0.9);
          ctx.stroke();
        }

        function drawFlower(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Stem
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.15);
          ctx.lineTo(cx, cy + s * 0.9);
          ctx.stroke();

          // Left leaf
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.5);
          ctx.bezierCurveTo(cx - s * 0.15, cy + s * 0.35, cx - s * 0.4, cy + s * 0.35, cx - s * 0.35, cy + s * 0.5);
          ctx.bezierCurveTo(cx - s * 0.3, cy + s * 0.6, cx - s * 0.1, cy + s * 0.55, cx, cy + s * 0.5);
          ctx.stroke();

          // Right leaf
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.65);
          ctx.bezierCurveTo(cx + s * 0.15, cy + s * 0.5, cx + s * 0.4, cy + s * 0.5, cx + s * 0.35, cy + s * 0.65);
          ctx.bezierCurveTo(cx + s * 0.3, cy + s * 0.75, cx + s * 0.1, cy + s * 0.7, cx, cy + s * 0.65);
          ctx.stroke();

          // Center circle
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.15, s * 0.15, 0, Math.PI * 2);
          ctx.stroke();

          // 6 petals
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI * 2) / 6 - Math.PI / 2;
            const petalCx = cx + Math.cos(angle) * s * 0.32;
            const petalCy = cy - s * 0.15 + Math.sin(angle) * s * 0.32;
            ctx.beginPath();
            ctx.ellipse(petalCx, petalCy, s * 0.18, s * 0.12, angle, 0, Math.PI * 2);
            ctx.stroke();
          }
        }

        function drawSun(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Center circle
          ctx.beginPath();
          ctx.arc(cx, cy, s * 0.35, 0, Math.PI * 2);
          ctx.stroke();

          // 12 triangular rays
          for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI * 2) / 12;
            const innerR = s * 0.38;
            const outerR = s * 0.7;
            const halfSpread = Math.PI / 24;

            const tipX = cx + Math.cos(angle) * outerR;
            const tipY = cy + Math.sin(angle) * outerR;
            const leftX = cx + Math.cos(angle - halfSpread) * innerR;
            const leftY = cy + Math.sin(angle - halfSpread) * innerR;
            const rightX = cx + Math.cos(angle + halfSpread) * innerR;
            const rightY = cy + Math.sin(angle + halfSpread) * innerR;

            ctx.beginPath();
            ctx.moveTo(leftX, leftY);
            ctx.lineTo(tipX, tipY);
            ctx.lineTo(rightX, rightY);
            ctx.closePath();
            ctx.stroke();
          }
        }

        function drawCloud(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Flat bottom
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.65, cy + s * 0.15);
          ctx.lineTo(cx + s * 0.65, cy + s * 0.15);
          ctx.stroke();

          // Bottom-left bump
          ctx.beginPath();
          ctx.arc(cx - s * 0.45, cy - s * 0.0, s * 0.25, Math.PI * 0.65, Math.PI * 1.85);
          ctx.stroke();

          // Top-left bump
          ctx.beginPath();
          ctx.arc(cx - s * 0.2, cy - s * 0.2, s * 0.3, Math.PI * 0.8, Math.PI * 1.7);
          ctx.stroke();

          // Top-center bump (largest)
          ctx.beginPath();
          ctx.arc(cx + s * 0.1, cy - s * 0.25, s * 0.35, Math.PI * 0.85, Math.PI * 1.9);
          ctx.stroke();

          // Right bump
          ctx.beginPath();
          ctx.arc(cx + s * 0.45, cy - s * 0.05, s * 0.28, Math.PI * 1.1, Math.PI * 1.95);
          ctx.stroke();

          // Connecting arcs on bottom
          ctx.beginPath();
          ctx.arc(cx - s * 0.45, cy + s * 0.05, s * 0.2, Math.PI * 0.0, Math.PI * 0.5);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx + s * 0.45, cy + s * 0.05, s * 0.2, Math.PI * 0.5, Math.PI * 1.0);
          ctx.stroke();
        }

        function drawMountain(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Ground line
          const baseY = cy + s * 0.6;

          // Back mountain (left)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.95, baseY);
          ctx.lineTo(cx - s * 0.4, cy - s * 0.5);
          ctx.lineTo(cx + s * 0.05, baseY);
          ctx.stroke();

          // Snow cap left mountain
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.52, cy - s * 0.25);
          ctx.lineTo(cx - s * 0.4, cy - s * 0.5);
          ctx.lineTo(cx - s * 0.28, cy - s * 0.25);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.52, cy - s * 0.25);
          ctx.lineTo(cx - s * 0.46, cy - s * 0.2);
          ctx.lineTo(cx - s * 0.4, cy - s * 0.27);
          ctx.lineTo(cx - s * 0.34, cy - s * 0.2);
          ctx.lineTo(cx - s * 0.28, cy - s * 0.25);
          ctx.stroke();

          // Center mountain (tallest)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, baseY);
          ctx.lineTo(cx + s * 0.05, cy - s * 0.85);
          ctx.lineTo(cx + s * 0.6, baseY);
          ctx.stroke();

          // Snow cap center mountain
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy - s * 0.55);
          ctx.lineTo(cx + s * 0.05, cy - s * 0.85);
          ctx.lineTo(cx + s * 0.2, cy - s * 0.55);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy - s * 0.55);
          ctx.lineTo(cx - s * 0.03, cy - s * 0.5);
          ctx.lineTo(cx + s * 0.05, cy - s * 0.58);
          ctx.lineTo(cx + s * 0.12, cy - s * 0.5);
          ctx.lineTo(cx + s * 0.2, cy - s * 0.55);
          ctx.stroke();

          // Right mountain (smaller)
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.2, baseY);
          ctx.lineTo(cx + s * 0.6, cy - s * 0.35);
          ctx.lineTo(cx + s * 0.95, baseY);
          ctx.stroke();

          // Snow cap right mountain
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy - s * 0.15);
          ctx.lineTo(cx + s * 0.6, cy - s * 0.35);
          ctx.lineTo(cx + s * 0.7, cy - s * 0.15);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy - s * 0.15);
          ctx.lineTo(cx + s * 0.55, cy - s * 0.1);
          ctx.lineTo(cx + s * 0.6, cy - s * 0.17);
          ctx.lineTo(cx + s * 0.65, cy - s * 0.1);
          ctx.lineTo(cx + s * 0.7, cy - s * 0.15);
          ctx.stroke();

          // Ground line
          ctx.beginPath();
          ctx.moveTo(cx - s * 1.0, baseY);
          ctx.lineTo(cx + s * 1.0, baseY);
          ctx.stroke();
        }

        function drawRainbow(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // 5 concentric arcs
          const bandWidth = s * 0.08;
          for (let i = 0; i < 5; i++) {
            const r = s * 0.5 + i * bandWidth;
            ctx.beginPath();
            ctx.arc(cx, cy + s * 0.3, r, Math.PI, 0);
            ctx.stroke();
          }

          // Left cloud
          const lcx = cx - s * 0.8, lcy = cy + s * 0.3;
          ctx.beginPath();
          ctx.arc(lcx - s * 0.12, lcy, s * 0.15, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(lcx + s * 0.1, lcy - s * 0.05, s * 0.18, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(lcx + s * 0.3, lcy, s * 0.14, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(lcx + s * 0.08, lcy + s * 0.1, s * 0.16, 0, Math.PI * 2);
          ctx.stroke();

          // Right cloud
          const rcx = cx + s * 0.8, rcy = cy + s * 0.3;
          ctx.beginPath();
          ctx.arc(rcx - s * 0.12, rcy, s * 0.15, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(rcx + s * 0.1, rcy - s * 0.05, s * 0.18, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(rcx + s * 0.3, rcy, s * 0.14, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(rcx + s * 0.08, rcy + s * 0.1, s * 0.16, 0, Math.PI * 2);
          ctx.stroke();
        }

        function drawCar(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Body
          ctx.beginPath();
          ctx.moveTo(cx - s, cy + s * 0.2);
          ctx.lineTo(cx + s, cy + s * 0.2);
          ctx.lineTo(cx + s, cy - s * 0.15);
          ctx.lineTo(cx + s * 0.6, cy - s * 0.15);
          ctx.quadraticCurveTo(cx + s * 0.5, cy - s * 0.7, cx + s * 0.2, cy - s * 0.7);
          ctx.lineTo(cx - s * 0.35, cy - s * 0.7);
          ctx.quadraticCurveTo(cx - s * 0.55, cy - s * 0.7, cx - s * 0.65, cy - s * 0.15);
          ctx.lineTo(cx - s, cy - s * 0.15);
          ctx.closePath();
          ctx.stroke();
          // Window divider
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.05, cy - s * 0.7);
          ctx.lineTo(cx + s * 0.05, cy - s * 0.15);
          ctx.stroke();
          // Windshield line
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.65, cy - s * 0.15);
          ctx.lineTo(cx + s * 0.6, cy - s * 0.15);
          ctx.stroke();
          // Door line
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.05, cy - s * 0.15);
          ctx.lineTo(cx + s * 0.05, cy + s * 0.2);
          ctx.stroke();
          // Wheels
          ctx.beginPath();
          ctx.arc(cx - s * 0.55, cy + s * 0.2, s * 0.22, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.55, cy + s * 0.2, s * 0.22, 0, Math.PI * 2);
          ctx.stroke();
          // Inner wheels
          ctx.beginPath();
          ctx.arc(cx - s * 0.55, cy + s * 0.2, s * 0.1, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.55, cy + s * 0.2, s * 0.1, 0, Math.PI * 2);
          ctx.stroke();
          // Headlights
          ctx.beginPath();
          ctx.arc(cx + s * 0.92, cy - s * 0.02, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx - s * 0.92, cy - s * 0.02, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();
        }

        function drawBoat(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Hull
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.9, cy + s * 0.15);
          ctx.lineTo(cx - s * 0.7, cy + s * 0.55);
          ctx.lineTo(cx + s * 0.7, cy + s * 0.55);
          ctx.lineTo(cx + s * 0.9, cy + s * 0.15);
          ctx.closePath();
          ctx.stroke();
          // Hull stripe
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.82, cy + s * 0.3);
          ctx.lineTo(cx + s * 0.82, cy + s * 0.3);
          ctx.stroke();
          // Mast
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.15);
          ctx.lineTo(cx, cy - s * 0.9);
          ctx.stroke();
          // Main sail
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.85);
          ctx.lineTo(cx + s * 0.6, cy + s * 0.1);
          ctx.lineTo(cx, cy + s * 0.1);
          ctx.closePath();
          ctx.stroke();
          // Small sail
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.7);
          ctx.lineTo(cx - s * 0.35, cy + s * 0.05);
          ctx.lineTo(cx, cy + s * 0.05);
          ctx.closePath();
          ctx.stroke();
          // Flag
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.9);
          ctx.lineTo(cx + s * 0.2, cy - s * 0.98);
          ctx.lineTo(cx, cy - s * 1.05);
          ctx.stroke();
          // Water waves
          for (let i = -1; i <= 1; i++) {
            ctx.beginPath();
            ctx.moveTo(cx - s * 1.1, cy + s * 0.7 + i * s * 0.15);
            ctx.quadraticCurveTo(cx - s * 0.7, cy + s * 0.6 + i * s * 0.15, cx - s * 0.35, cy + s * 0.7 + i * s * 0.15);
            ctx.quadraticCurveTo(cx, cy + s * 0.8 + i * s * 0.15, cx + s * 0.35, cy + s * 0.7 + i * s * 0.15);
            ctx.quadraticCurveTo(cx + s * 0.7, cy + s * 0.6 + i * s * 0.15, cx + s * 1.1, cy + s * 0.7 + i * s * 0.15);
            ctx.stroke();
          }
        }

        function drawRocket(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Body
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.3, cy + s * 0.6);
          ctx.lineTo(cx - s * 0.3, cy - s * 0.4);
          ctx.quadraticCurveTo(cx - s * 0.3, cy - s * 0.8, cx, cy - s * 1.1);
          ctx.quadraticCurveTo(cx + s * 0.3, cy - s * 0.8, cx + s * 0.3, cy - s * 0.4);
          ctx.lineTo(cx + s * 0.3, cy + s * 0.6);
          ctx.stroke();
          // Nose cone line
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.3, cy - s * 0.4);
          ctx.lineTo(cx + s * 0.3, cy - s * 0.4);
          ctx.stroke();
          // Window
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.15, s * 0.15, 0, Math.PI * 2);
          ctx.stroke();
          // Body stripe
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.3, cy + s * 0.3);
          ctx.lineTo(cx + s * 0.3, cy + s * 0.3);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.3, cy + s * 0.45);
          ctx.lineTo(cx + s * 0.3, cy + s * 0.45);
          ctx.stroke();
          // Left fin
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.3, cy + s * 0.35);
          ctx.lineTo(cx - s * 0.6, cy + s * 0.75);
          ctx.lineTo(cx - s * 0.3, cy + s * 0.6);
          ctx.stroke();
          // Right fin
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.3, cy + s * 0.35);
          ctx.lineTo(cx + s * 0.6, cy + s * 0.75);
          ctx.lineTo(cx + s * 0.3, cy + s * 0.6);
          ctx.stroke();
          // Bottom fin
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.08, cy + s * 0.6);
          ctx.lineTo(cx, cy + s * 0.8);
          ctx.lineTo(cx + s * 0.08, cy + s * 0.6);
          ctx.stroke();
          // Flame
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.2, cy + s * 0.6);
          ctx.quadraticCurveTo(cx - s * 0.15, cy + s * 0.9, cx, cy + s * 1.1);
          ctx.quadraticCurveTo(cx + s * 0.15, cy + s * 0.9, cx + s * 0.2, cy + s * 0.6);
          ctx.stroke();
          // Inner flame
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy + s * 0.6);
          ctx.quadraticCurveTo(cx - s * 0.05, cy + s * 0.8, cx, cy + s * 0.95);
          ctx.quadraticCurveTo(cx + s * 0.05, cy + s * 0.8, cx + s * 0.1, cy + s * 0.6);
          ctx.stroke();
        }

        function drawAirplane(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Fuselage
          ctx.beginPath();
          ctx.moveTo(cx - s * 1.0, cy);
          ctx.quadraticCurveTo(cx - s * 1.1, cy - s * 0.12, cx - s * 0.9, cy - s * 0.15);
          ctx.lineTo(cx + s * 0.6, cy - s * 0.15);
          ctx.quadraticCurveTo(cx + s * 1.1, cy - s * 0.1, cx + s * 1.1, cy);
          ctx.quadraticCurveTo(cx + s * 1.1, cy + s * 0.1, cx + s * 0.6, cy + s * 0.15);
          ctx.lineTo(cx - s * 0.9, cy + s * 0.15);
          ctx.quadraticCurveTo(cx - s * 1.1, cy + s * 0.12, cx - s * 1.0, cy);
          ctx.closePath();
          ctx.stroke();
          // Top wing
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.15, cy - s * 0.15);
          ctx.lineTo(cx - s * 0.35, cy - s * 0.65);
          ctx.lineTo(cx + s * 0.25, cy - s * 0.65);
          ctx.lineTo(cx + s * 0.15, cy - s * 0.15);
          ctx.stroke();
          // Bottom wing
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.15, cy + s * 0.15);
          ctx.lineTo(cx - s * 0.35, cy + s * 0.65);
          ctx.lineTo(cx + s * 0.25, cy + s * 0.65);
          ctx.lineTo(cx + s * 0.15, cy + s * 0.15);
          ctx.stroke();
          // Tail top
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.8, cy - s * 0.15);
          ctx.lineTo(cx - s * 1.0, cy - s * 0.5);
          ctx.lineTo(cx - s * 0.6, cy - s * 0.5);
          ctx.lineTo(cx - s * 0.55, cy - s * 0.15);
          ctx.stroke();
          // Tail bottom
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.8, cy + s * 0.15);
          ctx.lineTo(cx - s * 0.95, cy + s * 0.35);
          ctx.lineTo(cx - s * 0.6, cy + s * 0.35);
          ctx.lineTo(cx - s * 0.55, cy + s * 0.15);
          ctx.stroke();
          // Windows
          for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.arc(cx - s * 0.3 + i * s * 0.22, cy - s * 0.02, s * 0.05, 0, Math.PI * 2);
            ctx.stroke();
          }
          // Propeller hub
          ctx.beginPath();
          ctx.arc(cx + s * 1.1, cy, s * 0.05, 0, Math.PI * 2);
          ctx.stroke();
          // Propeller blades
          ctx.beginPath();
          ctx.moveTo(cx + s * 1.1, cy - s * 0.35);
          ctx.quadraticCurveTo(cx + s * 1.15, cy, cx + s * 1.1, cy + s * 0.35);
          ctx.stroke();
        }

        function drawTrain(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Main body
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.9, cy - s * 0.3);
          ctx.lineTo(cx + s * 0.5, cy - s * 0.3);
          ctx.lineTo(cx + s * 0.5, cy + s * 0.35);
          ctx.lineTo(cx - s * 0.9, cy + s * 0.35);
          ctx.closePath();
          ctx.stroke();
          // Cabin (taller back section)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.9, cy - s * 0.3);
          ctx.lineTo(cx - s * 0.9, cy - s * 0.7);
          ctx.lineTo(cx - s * 0.4, cy - s * 0.7);
          ctx.lineTo(cx - s * 0.4, cy - s * 0.3);
          ctx.stroke();
          // Cabin window
          ctx.beginPath();
          ctx.rect(cx - s * 0.8, cy - s * 0.6, s * 0.3, s * 0.2);
          ctx.stroke();
          // Smokestack
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy - s * 0.3);
          ctx.lineTo(cx + s * 0.15, cy - s * 0.6);
          ctx.lineTo(cx + s * 0.3, cy - s * 0.6);
          ctx.lineTo(cx + s * 0.3, cy - s * 0.3);
          ctx.stroke();
          // Smokestack top
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.1, cy - s * 0.6);
          ctx.lineTo(cx + s * 0.35, cy - s * 0.6);
          ctx.stroke();
          // Smoke puffs
          ctx.beginPath();
          ctx.arc(cx + s * 0.22, cy - s * 0.75, s * 0.1, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.08, cy - s * 0.9, s * 0.12, 0, Math.PI * 2);
          ctx.stroke();
          // Body windows
          ctx.beginPath();
          ctx.rect(cx - s * 0.25, cy - s * 0.2, s * 0.2, s * 0.18);
          ctx.stroke();
          ctx.beginPath();
          ctx.rect(cx + s * 0.05, cy - s * 0.2, s * 0.2, s * 0.18);
          ctx.stroke();
          // Cow catcher
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy + s * 0.15);
          ctx.lineTo(cx + s * 0.75, cy + s * 0.45);
          ctx.lineTo(cx + s * 0.5, cy + s * 0.35);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.55, cy + s * 0.45);
          ctx.lineTo(cx + s * 0.75, cy + s * 0.45);
          ctx.stroke();
          // Wheels
          ctx.beginPath();
          ctx.arc(cx - s * 0.6, cy + s * 0.45, s * 0.18, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx - s * 0.1, cy + s * 0.45, s * 0.18, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.35, cy + s * 0.45, s * 0.14, 0, Math.PI * 2);
          ctx.stroke();
          // Rail
          ctx.beginPath();
          ctx.moveTo(cx - s * 1.1, cy + s * 0.63);
          ctx.lineTo(cx + s * 0.9, cy + s * 0.63);
          ctx.stroke();
        }

        function drawBicycle(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          const wheelR = s * 0.35;
          const lwx = cx - s * 0.55, rwx = cx + s * 0.55;
          const wy = cy + s * 0.25;
          // Back wheel
          ctx.beginPath();
          ctx.arc(lwx, wy, wheelR, 0, Math.PI * 2);
          ctx.stroke();
          // Front wheel
          ctx.beginPath();
          ctx.arc(rwx, wy, wheelR, 0, Math.PI * 2);
          ctx.stroke();
          // Hub back
          ctx.beginPath();
          ctx.arc(lwx, wy, s * 0.05, 0, Math.PI * 2);
          ctx.stroke();
          // Hub front
          ctx.beginPath();
          ctx.arc(rwx, wy, s * 0.05, 0, Math.PI * 2);
          ctx.stroke();
          // Spokes back
          for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(lwx, wy);
            ctx.lineTo(lwx + Math.cos(a) * wheelR, wy + Math.sin(a) * wheelR);
            ctx.stroke();
          }
          // Spokes front
          for (let i = 0; i < 6; i++) {
            const a = (i / 6) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(rwx, wy);
            ctx.lineTo(rwx + Math.cos(a) * wheelR, wy + Math.sin(a) * wheelR);
            ctx.stroke();
          }
          // Frame: seat tube to pedal area
          const pedalX = cx - s * 0.1, pedalY = wy;
          const seatX = cx - s * 0.25, seatY = cy - s * 0.35;
          ctx.beginPath();
          ctx.moveTo(seatX, seatY);
          ctx.lineTo(pedalX, pedalY);
          ctx.stroke();
          // Chain stay (pedal to back wheel)
          ctx.beginPath();
          ctx.moveTo(pedalX, pedalY);
          ctx.lineTo(lwx, wy);
          ctx.stroke();
          // Seat stay (seat to back wheel)
          ctx.beginPath();
          ctx.moveTo(seatX, seatY);
          ctx.lineTo(lwx, wy);
          ctx.stroke();
          // Top tube (seat to head tube)
          const headX = cx + s * 0.3, headY = cy - s * 0.3;
          ctx.beginPath();
          ctx.moveTo(seatX, seatY);
          ctx.lineTo(headX, headY);
          ctx.stroke();
          // Down tube (head to pedal)
          ctx.beginPath();
          ctx.moveTo(headX, headY);
          ctx.lineTo(pedalX, pedalY);
          ctx.stroke();
          // Fork (head to front wheel)
          ctx.beginPath();
          ctx.moveTo(headX, headY);
          ctx.lineTo(rwx, wy);
          ctx.stroke();
          // Handlebars
          ctx.beginPath();
          ctx.moveTo(headX - s * 0.1, headY - s * 0.15);
          ctx.lineTo(headX, headY);
          ctx.lineTo(headX + s * 0.15, headY - s * 0.12);
          ctx.stroke();
          // Seat
          ctx.beginPath();
          ctx.moveTo(seatX - s * 0.12, seatY - s * 0.05);
          ctx.lineTo(seatX + s * 0.12, seatY - s * 0.05);
          ctx.stroke();
          // Pedal circle
          ctx.beginPath();
          ctx.arc(pedalX, pedalY, s * 0.08, 0, Math.PI * 2);
          ctx.stroke();
          // Pedal arms
          ctx.beginPath();
          ctx.moveTo(pedalX - s * 0.12, pedalY + s * 0.06);
          ctx.lineTo(pedalX + s * 0.12, pedalY - s * 0.06);
          ctx.stroke();
        }

        function drawCastle(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Main wall
          ctx.beginPath();
          ctx.rect(cx - s * 0.7, cy - s * 0.2, s * 1.4, s * 0.9);
          ctx.stroke();
          // Battlements on main wall
          const bw = s * 0.14, bh = s * 0.12;
          for (let i = 0; i < 5; i++) {
            const bx = cx - s * 0.7 + i * s * 0.28 + s * 0.07;
            ctx.beginPath();
            ctx.rect(bx, cy - s * 0.32, bw, bh);
            ctx.stroke();
          }
          // Left tower
          ctx.beginPath();
          ctx.rect(cx - s * 0.85, cy - s * 0.55, s * 0.35, s * 1.25);
          ctx.stroke();
          // Left tower roof
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.9, cy - s * 0.55);
          ctx.lineTo(cx - s * 0.675, cy - s * 0.85);
          ctx.lineTo(cx - s * 0.45, cy - s * 0.55);
          ctx.stroke();
          // Center tower
          ctx.beginPath();
          ctx.rect(cx - s * 0.2, cy - s * 0.6, s * 0.4, s * 0.4);
          ctx.stroke();
          // Center tower roof
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.25, cy - s * 0.6);
          ctx.lineTo(cx, cy - s * 0.95);
          ctx.lineTo(cx + s * 0.25, cy - s * 0.6);
          ctx.stroke();
          // Right tower
          ctx.beginPath();
          ctx.rect(cx + s * 0.5, cy - s * 0.55, s * 0.35, s * 1.25);
          ctx.stroke();
          // Right tower roof
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.45, cy - s * 0.55);
          ctx.lineTo(cx + s * 0.675, cy - s * 0.85);
          ctx.lineTo(cx + s * 0.9, cy - s * 0.55);
          ctx.stroke();
          // Door arch
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.12, cy + s * 0.7);
          ctx.lineTo(cx - s * 0.12, cy + s * 0.3);
          ctx.arc(cx, cy + s * 0.3, s * 0.12, Math.PI, 0);
          ctx.lineTo(cx + s * 0.12, cy + s * 0.7);
          ctx.stroke();
          // Tower windows
          ctx.beginPath();
          ctx.arc(cx - s * 0.675, cy - s * 0.2, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.675, cy - s * 0.2, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.45, s * 0.06, 0, Math.PI * 2);
          ctx.stroke();
          // Flag on center tower
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.95);
          ctx.lineTo(cx, cy - s * 1.15);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 1.15);
          ctx.lineTo(cx + s * 0.18, cy - s * 1.08);
          ctx.lineTo(cx, cy - s * 1.0);
          ctx.stroke();
        }

        function drawCrown(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Crown outline with 5 peaks
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.9, cy + s * 0.4);
          ctx.lineTo(cx - s * 0.9, cy + s * 0.05);
          ctx.lineTo(cx - s * 0.7, cy - s * 0.5);
          ctx.lineTo(cx - s * 0.5, cy + s * 0.05);
          ctx.lineTo(cx - s * 0.35, cy - s * 0.55);
          ctx.lineTo(cx - s * 0.15, cy + s * 0.05);
          ctx.lineTo(cx, cy - s * 0.65);
          ctx.lineTo(cx + s * 0.15, cy + s * 0.05);
          ctx.lineTo(cx + s * 0.35, cy - s * 0.55);
          ctx.lineTo(cx + s * 0.5, cy + s * 0.05);
          ctx.lineTo(cx + s * 0.7, cy - s * 0.5);
          ctx.lineTo(cx + s * 0.9, cy + s * 0.05);
          ctx.lineTo(cx + s * 0.9, cy + s * 0.4);
          ctx.closePath();
          ctx.stroke();
          // Base band top
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.9, cy + s * 0.15);
          ctx.lineTo(cx + s * 0.9, cy + s * 0.15);
          ctx.stroke();
          // Base band bottom decorative line
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.9, cy + s * 0.28);
          ctx.lineTo(cx + s * 0.9, cy + s * 0.28);
          ctx.stroke();
          // Jewel circles on peaks
          const peaks = [
            [cx - s * 0.7, cy - s * 0.5],
            [cx - s * 0.35, cy - s * 0.55],
            [cx, cy - s * 0.65],
            [cx + s * 0.35, cy - s * 0.55],
            [cx + s * 0.7, cy - s * 0.5]
          ];
          for (const [px, py] of peaks) {
            ctx.beginPath();
            ctx.arc(px, py, s * 0.08, 0, Math.PI * 2);
            ctx.stroke();
          }
          // Band jewels (between peaks at band level)
          const bandJewels = [cx - s * 0.6, cx - s * 0.2, cx + s * 0.2, cx + s * 0.6];
          for (const bx of bandJewels) {
            ctx.beginPath();
            ctx.arc(bx, cy + s * 0.21, s * 0.05, 0, Math.PI * 2);
            ctx.stroke();
          }
          // Cross-hatching on band
          for (let i = -3; i <= 3; i++) {
            ctx.beginPath();
            ctx.moveTo(cx + i * s * 0.25, cy + s * 0.15);
            ctx.lineTo(cx + i * s * 0.25, cy + s * 0.28);
            ctx.stroke();
          }
        }

        function drawUnicorn(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Body (ellipse)
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.05, cy + s * 0.15, s * 0.55, s * 0.35, 0, 0, Math.PI * 2);
          ctx.stroke();
          // Neck
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.35, cy - s * 0.05);
          ctx.quadraticCurveTo(cx + s * 0.55, cy - s * 0.4, cx + s * 0.5, cy - s * 0.65);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy - s * 0.1);
          ctx.quadraticCurveTo(cx + s * 0.3, cy - s * 0.45, cx + s * 0.3, cy - s * 0.65);
          ctx.stroke();
          // Head
          ctx.beginPath();
          ctx.ellipse(cx + s * 0.55, cy - s * 0.72, s * 0.22, s * 0.16, 0.3, 0, Math.PI * 2);
          ctx.stroke();
          // Muzzle
          ctx.beginPath();
          ctx.ellipse(cx + s * 0.75, cy - s * 0.65, s * 0.1, s * 0.08, 0.2, 0, Math.PI * 2);
          ctx.stroke();
          // Eye
          ctx.beginPath();
          ctx.arc(cx + s * 0.58, cy - s * 0.76, s * 0.04, 0, Math.PI * 2);
          ctx.fill();
          // Horn (spiral)
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy - s * 0.85);
          ctx.lineTo(cx + s * 0.55, cy - s * 1.2);
          ctx.lineTo(cx + s * 0.42, cy - s * 0.85);
          ctx.stroke();
          // Horn spiral lines
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.49, cy - s * 0.95);
          ctx.lineTo(cx + s * 0.52, cy - s * 0.95);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy - s * 1.05);
          ctx.lineTo(cx + s * 0.54, cy - s * 1.05);
          ctx.stroke();
          // Ear
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.42, cy - s * 0.82);
          ctx.lineTo(cx + s * 0.38, cy - s * 0.98);
          ctx.lineTo(cx + s * 0.48, cy - s * 0.86);
          ctx.stroke();
          // Mane (flowing curves)
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.35, cy - s * 0.8);
          ctx.bezierCurveTo(cx + s * 0.15, cy - s * 0.9, cx + s * 0.1, cy - s * 0.6, cx + s * 0.2, cy - s * 0.4);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.3, cy - s * 0.75);
          ctx.bezierCurveTo(cx + s * 0.05, cy - s * 0.8, cx, cy - s * 0.5, cx + s * 0.1, cy - s * 0.25);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.25, cy - s * 0.65);
          ctx.bezierCurveTo(cx, cy - s * 0.7, cx - s * 0.05, cy - s * 0.4, cx + s * 0.05, cy - s * 0.15);
          ctx.stroke();
          // Legs
          const legs = [
            [cx + s * 0.25, cy + s * 0.4],
            [cx + s * 0.1, cy + s * 0.4],
            [cx - s * 0.25, cy + s * 0.4],
            [cx - s * 0.4, cy + s * 0.4]
          ];
          for (const [lx, ly] of legs) {
            ctx.beginPath();
            ctx.moveTo(lx, ly);
            ctx.lineTo(lx, ly + s * 0.45);
            ctx.lineTo(lx + s * 0.06, ly + s * 0.48);
            ctx.stroke();
          }
          // Tail
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, cy + s * 0.05);
          ctx.bezierCurveTo(cx - s * 0.85, cy - s * 0.15, cx - s * 0.95, cy + s * 0.3, cx - s * 0.75, cy + s * 0.55);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, cy + s * 0.1);
          ctx.bezierCurveTo(cx - s * 0.8, cy - s * 0.05, cx - s * 0.9, cy + s * 0.35, cx - s * 0.65, cy + s * 0.55);
          ctx.stroke();
        }

        function drawStar(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Large 5-pointed star
          const outerR = s * 0.95, innerR = s * 0.4;
          const starPoints = [];
          for (let i = 0; i < 10; i++) {
            const angle = (i * Math.PI / 5) - Math.PI / 2;
            const r = i % 2 === 0 ? outerR : innerR;
            starPoints.push([cx + Math.cos(angle) * r, cy + Math.sin(angle) * r]);
          }
          ctx.beginPath();
          ctx.moveTo(starPoints[0][0], starPoints[0][1]);
          for (let i = 1; i < starPoints.length; i++) {
            ctx.lineTo(starPoints[i][0], starPoints[i][1]);
          }
          ctx.closePath();
          ctx.stroke();
          // Inner facet lines (from center to inner points)
          for (let i = 0; i < 5; i++) {
            const angle = (i * 2 + 1) * Math.PI / 5 - Math.PI / 2;
            const ix = cx + Math.cos(angle) * innerR;
            const iy = cy + Math.sin(angle) * innerR;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(ix, iy);
            ctx.stroke();
          }
          // Facet lines from center to outer points
          for (let i = 0; i < 5; i++) {
            const angle = (i * 2) * Math.PI / 5 - Math.PI / 2;
            const ox = cx + Math.cos(angle) * outerR;
            const oy = cy + Math.sin(angle) * outerR;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(ox, oy);
            ctx.stroke();
          }
          // Small stars around
          const smallStarAngles = [0.3, 1.2, 2.5, 3.8, 5.1];
          for (const a of smallStarAngles) {
            const sx = cx + Math.cos(a) * s * 1.3;
            const sy = cy + Math.sin(a) * s * 1.3;
            const sr = s * 0.1, sir = s * 0.04;
            ctx.beginPath();
            for (let i = 0; i < 10; i++) {
              const sa = (i * Math.PI / 5) - Math.PI / 2;
              const r = i % 2 === 0 ? sr : sir;
              const px = sx + Math.cos(sa) * r;
              const py = sy + Math.sin(sa) * r;
              if (i === 0) ctx.moveTo(px, py);
              else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();
          }
        }

        function drawDragon(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Round body
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.1, cy + s * 0.15, s * 0.5, s * 0.45, 0, 0, Math.PI * 2);
          ctx.stroke();
          // Belly line
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.1, cy + s * 0.25, s * 0.3, s * 0.3, 0, 0.3, Math.PI - 0.3);
          ctx.stroke();
          // Head
          ctx.beginPath();
          ctx.arc(cx + s * 0.45, cy - s * 0.35, s * 0.3, 0, Math.PI * 2);
          ctx.stroke();
          // Snout
          ctx.beginPath();
          ctx.ellipse(cx + s * 0.72, cy - s * 0.3, s * 0.14, s * 0.1, 0.1, 0, Math.PI * 2);
          ctx.stroke();
          // Nostrils
          ctx.beginPath();
          ctx.arc(cx + s * 0.8, cy - s * 0.33, s * 0.025, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(cx + s * 0.78, cy - s * 0.27, s * 0.025, 0, Math.PI * 2);
          ctx.fill();
          // Big eyes
          ctx.beginPath();
          ctx.arc(cx + s * 0.5, cy - s * 0.42, s * 0.1, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.52, cy - s * 0.43, s * 0.05, 0, Math.PI * 2);
          ctx.fill();
          // Horns
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.32, cy - s * 0.58);
          ctx.lineTo(cx + s * 0.2, cy - s * 0.8);
          ctx.lineTo(cx + s * 0.38, cy - s * 0.62);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy - s * 0.62);
          ctx.lineTo(cx + s * 0.45, cy - s * 0.85);
          ctx.lineTo(cx + s * 0.55, cy - s * 0.65);
          ctx.stroke();
          // Spiky back
          const spikes = [
            [cx + s * 0.2, cy - s * 0.15],
            [cx + s * 0.05, cy - s * 0.1],
            [cx - s * 0.1, cy - s * 0.12],
            [cx - s * 0.25, cy - s * 0.15],
            [cx - s * 0.4, cy - s * 0.1]
          ];
          for (const [spx, spy] of spikes) {
            ctx.beginPath();
            ctx.moveTo(spx - s * 0.06, spy + s * 0.1);
            ctx.lineTo(spx, spy - s * 0.12);
            ctx.lineTo(spx + s * 0.06, spy + s * 0.1);
            ctx.stroke();
          }
          // Small wings
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.1, cy - s * 0.05);
          ctx.bezierCurveTo(cx + s * 0.4, cy - s * 0.5, cx + s * 0.7, cy - s * 0.3, cx + s * 0.3, cy + s * 0.05);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy - s * 0.02);
          ctx.bezierCurveTo(cx + s * 0.35, cy - s * 0.35, cx + s * 0.55, cy - s * 0.2, cx + s * 0.25, cy + s * 0.05);
          ctx.stroke();
          // Legs
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy + s * 0.5);
          ctx.lineTo(cx + s * 0.2, cy + s * 0.75);
          ctx.lineTo(cx + s * 0.3, cy + s * 0.72);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.25, cy + s * 0.5);
          ctx.lineTo(cx - s * 0.3, cy + s * 0.75);
          ctx.lineTo(cx - s * 0.2, cy + s * 0.72);
          ctx.stroke();
          // Arms
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.3, cy + s * 0.2);
          ctx.lineTo(cx + s * 0.45, cy + s * 0.35);
          ctx.lineTo(cx + s * 0.5, cy + s * 0.3);
          ctx.stroke();
          // Curled tail
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, cy + s * 0.25);
          ctx.bezierCurveTo(cx - s * 0.85, cy + s * 0.2, cx - s * 1.0, cy + s * 0.5, cx - s * 0.8, cy + s * 0.65);
          ctx.bezierCurveTo(cx - s * 0.65, cy + s * 0.75, cx - s * 0.55, cy + s * 0.6, cx - s * 0.65, cy + s * 0.5);
          ctx.stroke();
          // Smile
          ctx.beginPath();
          ctx.arc(cx + s * 0.65, cy - s * 0.25, s * 0.1, 0.2, Math.PI - 0.2);
          ctx.stroke();
        }

        function drawFairy(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          // Head
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.55, s * 0.22, 0, Math.PI * 2);
          ctx.stroke();
          // Eyes
          ctx.beginPath();
          ctx.arc(cx - s * 0.07, cy - s * 0.58, s * 0.03, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(cx + s * 0.07, cy - s * 0.58, s * 0.03, 0, Math.PI * 2);
          ctx.fill();
          // Smile
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.5, s * 0.07, 0.2, Math.PI - 0.2);
          ctx.stroke();
          // Hair
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.22, cy - s * 0.6);
          ctx.bezierCurveTo(cx - s * 0.35, cy - s * 0.85, cx - s * 0.1, cy - s * 0.9, cx, cy - s * 0.77);
          ctx.bezierCurveTo(cx + s * 0.1, cy - s * 0.9, cx + s * 0.35, cy - s * 0.85, cx + s * 0.22, cy - s * 0.6);
          ctx.stroke();
          // Hair sides flowing down
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.22, cy - s * 0.6);
          ctx.bezierCurveTo(cx - s * 0.35, cy - s * 0.4, cx - s * 0.3, cy - s * 0.15, cx - s * 0.25, cy - s * 0.05);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.22, cy - s * 0.6);
          ctx.bezierCurveTo(cx + s * 0.35, cy - s * 0.4, cx + s * 0.3, cy - s * 0.15, cx + s * 0.25, cy - s * 0.05);
          ctx.stroke();
          // Body / dress (triangle shape)
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.33);
          ctx.lineTo(cx - s * 0.35, cy + s * 0.45);
          ctx.quadraticCurveTo(cx, cy + s * 0.55, cx + s * 0.35, cy + s * 0.45);
          ctx.closePath();
          ctx.stroke();
          // Dress waist line
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.15, cy - s * 0.05);
          ctx.quadraticCurveTo(cx, cy + s * 0.02, cx + s * 0.15, cy - s * 0.05);
          ctx.stroke();
          // Left wing (upper)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy - s * 0.2);
          ctx.bezierCurveTo(cx - s * 0.65, cy - s * 0.65, cx - s * 0.85, cy - s * 0.2, cx - s * 0.15, cy + s * 0.05);
          ctx.stroke();
          // Left wing (lower)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.12, cy + s * 0.0);
          ctx.bezierCurveTo(cx - s * 0.55, cy - s * 0.05, cx - s * 0.65, cy + s * 0.25, cx - s * 0.15, cy + s * 0.2);
          ctx.stroke();
          // Right wing (upper)
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.1, cy - s * 0.2);
          ctx.bezierCurveTo(cx + s * 0.65, cy - s * 0.65, cx + s * 0.85, cy - s * 0.2, cx + s * 0.15, cy + s * 0.05);
          ctx.stroke();
          // Right wing (lower)
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.12, cy + s * 0.0);
          ctx.bezierCurveTo(cx + s * 0.55, cy - s * 0.05, cx + s * 0.65, cy + s * 0.25, cx + s * 0.15, cy + s * 0.2);
          ctx.stroke();
          // Wing details (vein lines)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.12, cy - s * 0.1);
          ctx.quadraticCurveTo(cx - s * 0.45, cy - s * 0.3, cx - s * 0.55, cy - s * 0.15);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.12, cy - s * 0.1);
          ctx.quadraticCurveTo(cx + s * 0.45, cy - s * 0.3, cx + s * 0.55, cy - s * 0.15);
          ctx.stroke();
          // Right arm with wand
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.1, cy - s * 0.2);
          ctx.lineTo(cx + s * 0.4, cy - s * 0.4);
          ctx.stroke();
          // Wand
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.4, cy - s * 0.4);
          ctx.lineTo(cx + s * 0.55, cy - s * 0.7);
          ctx.stroke();
          // Wand star
          const wsx = cx + s * 0.55, wsy = cy - s * 0.75;
          const wsr = s * 0.08, wsir = s * 0.035;
          ctx.beginPath();
          for (let i = 0; i < 10; i++) {
            const a = (i * Math.PI / 5) - Math.PI / 2;
            const r = i % 2 === 0 ? wsr : wsir;
            const px = wsx + Math.cos(a) * r;
            const py = wsy + Math.sin(a) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
          }
          ctx.closePath();
          ctx.stroke();
          // Left arm
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy - s * 0.2);
          ctx.lineTo(cx - s * 0.35, cy - s * 0.05);
          ctx.stroke();
          // Legs/feet peeking from dress
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.15, cy + s * 0.45);
          ctx.lineTo(cx - s * 0.15, cy + s * 0.65);
          ctx.lineTo(cx - s * 0.05, cy + s * 0.65);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy + s * 0.45);
          ctx.lineTo(cx + s * 0.15, cy + s * 0.65);
          ctx.lineTo(cx + s * 0.25, cy + s * 0.65);
          ctx.stroke();
        }

        function drawIceCream(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Waffle cone (triangle)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.45, cy - s * 0.1);
          ctx.lineTo(cx, cy + s * 1.1);
          ctx.lineTo(cx + s * 0.45, cy - s * 0.1);
          ctx.closePath();
          ctx.stroke();

          // Cross-hatch lines on cone
          for (let i = 1; i <= 4; i++) {
            const t = i / 5;
            const lx = cx - s * 0.45 * (1 - t);
            const rx = cx + s * 0.45 * (1 - t);
            const ly = cy - s * 0.1 + (cy + s * 1.1 - (cy - s * 0.1)) * t;
            ctx.beginPath();
            ctx.moveTo(lx, ly);
            ctx.lineTo(rx, ly);
            ctx.stroke();
          }
          // Diagonal lines
          for (let i = 0; i < 3; i++) {
            const offset = (i - 1) * s * 0.2;
            ctx.beginPath();
            ctx.moveTo(cx + offset - s * 0.2, cy - s * 0.1);
            ctx.lineTo(cx + offset + s * 0.1, cy + s * 0.7);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + offset + s * 0.2, cy - s * 0.1);
            ctx.lineTo(cx + offset - s * 0.1, cy + s * 0.7);
            ctx.stroke();
          }

          // Three scoops
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.3, s * 0.35, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx - s * 0.3, cy - s * 0.55, s * 0.3, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.3, cy - s * 0.55, s * 0.3, 0, Math.PI * 2);
          ctx.stroke();
        }

        function drawPizza(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Pizza slice triangle
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.9);
          ctx.lineTo(cx - s * 0.65, cy - s * 0.7);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.9);
          ctx.lineTo(cx + s * 0.65, cy - s * 0.7);
          ctx.stroke();

          // Curved crust edge
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.65, cy - s * 0.7);
          ctx.quadraticCurveTo(cx, cy - s * 1.05, cx + s * 0.65, cy - s * 0.7);
          ctx.stroke();

          // Inner crust line
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, cy - s * 0.55);
          ctx.quadraticCurveTo(cx, cy - s * 0.85, cx + s * 0.55, cy - s * 0.55);
          ctx.stroke();

          // Pepperoni circles
          ctx.beginPath();
          ctx.arc(cx - s * 0.15, cy - s * 0.1, s * 0.12, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.2, cy - s * 0.25, s * 0.1, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx - s * 0.05, cy + s * 0.35, s * 0.1, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.1, cy - s * 0.45, s * 0.08, 0, Math.PI * 2);
          ctx.stroke();

          // Cheese drip from crust
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.3, cy - s * 0.55);
          ctx.quadraticCurveTo(cx - s * 0.32, cy - s * 0.4, cx - s * 0.28, cy - s * 0.35);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy - s * 0.6);
          ctx.quadraticCurveTo(cx + s * 0.13, cy - s * 0.45, cx + s * 0.17, cy - s * 0.38);
          ctx.stroke();
        }

        function drawCake(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Plate
          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.85, s * 0.95, s * 0.12, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Bottom tier
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.8, cy + s * 0.75);
          ctx.lineTo(cx - s * 0.8, cy + s * 0.15);
          ctx.lineTo(cx + s * 0.8, cy + s * 0.15);
          ctx.lineTo(cx + s * 0.8, cy + s * 0.75);
          ctx.closePath();
          ctx.stroke();

          // Top tier
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, cy + s * 0.15);
          ctx.lineTo(cx - s * 0.55, cy - s * 0.45);
          ctx.lineTo(cx + s * 0.55, cy - s * 0.45);
          ctx.lineTo(cx + s * 0.55, cy + s * 0.15);
          ctx.stroke();

          // Frosting drips on bottom tier
          for (let i = -3; i <= 3; i++) {
            const dx = i * s * 0.2;
            const drip = s * (0.1 + Math.abs(i % 2) * 0.08);
            ctx.beginPath();
            ctx.moveTo(cx + dx - s * 0.1, cy + s * 0.15);
            ctx.quadraticCurveTo(cx + dx, cy + s * 0.15 + drip, cx + dx + s * 0.1, cy + s * 0.15);
            ctx.stroke();
          }

          // Frosting drips on top tier
          for (let i = -2; i <= 2; i++) {
            const dx = i * s * 0.2;
            const drip = s * (0.08 + Math.abs(i % 2) * 0.06);
            ctx.beginPath();
            ctx.moveTo(cx + dx - s * 0.08, cy - s * 0.45);
            ctx.quadraticCurveTo(cx + dx, cy - s * 0.45 + drip, cx + dx + s * 0.08, cy - s * 0.45);
            ctx.stroke();
          }

          // Candles
          const candlePositions = [-s * 0.3, 0, s * 0.3];
          for (const px of candlePositions) {
            ctx.beginPath();
            ctx.moveTo(cx + px - s * 0.04, cy - s * 0.45);
            ctx.lineTo(cx + px - s * 0.04, cy - s * 0.7);
            ctx.lineTo(cx + px + s * 0.04, cy - s * 0.7);
            ctx.lineTo(cx + px + s * 0.04, cy - s * 0.45);
            ctx.stroke();

            // Flame
            ctx.beginPath();
            ctx.moveTo(cx + px, cy - s * 0.7);
            ctx.bezierCurveTo(cx + px - s * 0.06, cy - s * 0.8, cx + px + s * 0.06, cy - s * 0.85, cx + px, cy - s * 0.92);
            ctx.bezierCurveTo(cx + px - s * 0.06, cy - s * 0.85, cx + px + s * 0.06, cy - s * 0.8, cx + px, cy - s * 0.7);
            ctx.stroke();
          }
        }

        function drawApple(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Apple body (slightly heart-shaped top)
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.55);
          ctx.bezierCurveTo(cx - s * 0.6, cy - s * 0.75, cx - s * 1.0, cy - s * 0.1, cx - s * 0.55, cy + s * 0.45);
          ctx.bezierCurveTo(cx - s * 0.3, cy + s * 0.85, cx - s * 0.05, cy + s * 0.9, cx, cy + s * 0.85);
          ctx.bezierCurveTo(cx + s * 0.05, cy + s * 0.9, cx + s * 0.3, cy + s * 0.85, cx + s * 0.55, cy + s * 0.45);
          ctx.bezierCurveTo(cx + s * 1.0, cy - s * 0.1, cx + s * 0.6, cy - s * 0.75, cx, cy - s * 0.55);
          ctx.closePath();
          ctx.stroke();

          // Stem
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.55);
          ctx.quadraticCurveTo(cx + s * 0.08, cy - s * 0.75, cx + s * 0.05, cy - s * 0.9);
          ctx.stroke();

          // Leaf
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.05, cy - s * 0.78);
          ctx.bezierCurveTo(cx + s * 0.3, cy - s * 1.0, cx + s * 0.55, cy - s * 0.85, cx + s * 0.4, cy - s * 0.65);
          ctx.bezierCurveTo(cx + s * 0.3, cy - s * 0.7, cx + s * 0.15, cy - s * 0.7, cx + s * 0.05, cy - s * 0.78);
          ctx.stroke();

          // Leaf vein
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.08, cy - s * 0.78);
          ctx.quadraticCurveTo(cx + s * 0.3, cy - s * 0.82, cx + s * 0.38, cy - s * 0.7);
          ctx.stroke();

          // Small highlight arc
          ctx.beginPath();
          ctx.arc(cx - s * 0.3, cy - s * 0.15, s * 0.15, -Math.PI * 0.6, -Math.PI * 0.1);
          ctx.stroke();
        }

        function drawCupcake(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Ribbed wrapper/cup (trapezoid shape)
          const topW = s * 0.6;
          const botW = s * 0.4;
          const cupTop = cy + s * 0.05;
          const cupBot = cy + s * 0.75;

          ctx.beginPath();
          ctx.moveTo(cx - topW, cupTop);
          ctx.lineTo(cx - botW, cupBot);
          ctx.lineTo(cx + botW, cupBot);
          ctx.lineTo(cx + topW, cupTop);
          ctx.closePath();
          ctx.stroke();

          // Ribs on wrapper
          for (let i = -4; i <= 4; i++) {
            const tTop = (i + 5) / 10;
            const tBot = (i + 5) / 10;
            const x1 = cx - topW + tTop * topW * 2;
            const x2 = cx - botW + tBot * botW * 2;
            ctx.beginPath();
            ctx.moveTo(x1, cupTop);
            ctx.lineTo(x2, cupBot);
            ctx.stroke();
          }

          // Swirled frosting
          ctx.beginPath();
          ctx.moveTo(cx - topW - s * 0.05, cupTop);
          ctx.bezierCurveTo(cx - topW - s * 0.1, cupTop - s * 0.3, cx - s * 0.15, cupTop - s * 0.15, cx - s * 0.1, cupTop - s * 0.4);
          ctx.bezierCurveTo(cx - s * 0.05, cupTop - s * 0.55, cx + s * 0.15, cupTop - s * 0.25, cx + s * 0.1, cupTop - s * 0.5);
          ctx.bezierCurveTo(cx + s * 0.05, cupTop - s * 0.65, cx + s * 0.35, cupTop - s * 0.4, cx + s * 0.2, cupTop - s * 0.6);
          ctx.bezierCurveTo(cx + s * 0.1, cupTop - s * 0.75, cx + s * 0.05, cupTop - s * 0.7, cx, cupTop - s * 0.85);
          ctx.stroke();

          // Other side of frosting
          ctx.beginPath();
          ctx.moveTo(cx + topW + s * 0.05, cupTop);
          ctx.bezierCurveTo(cx + topW + s * 0.1, cupTop - s * 0.3, cx + s * 0.3, cupTop - s * 0.2, cx + s * 0.2, cupTop - s * 0.6);
          ctx.stroke();

          // Cherry on top
          ctx.beginPath();
          ctx.arc(cx, cupTop - s * 0.95, s * 0.12, 0, Math.PI * 2);
          ctx.stroke();

          // Cherry stem
          ctx.beginPath();
          ctx.moveTo(cx, cupTop - s * 1.07);
          ctx.quadraticCurveTo(cx + s * 0.08, cupTop - s * 1.2, cx + s * 0.15, cupTop - s * 1.15);
          ctx.stroke();
        }

        function drawCandy(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Candy body (oval)
          ctx.beginPath();
          ctx.ellipse(cx, cy, s * 0.55, s * 0.4, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Left twisted wrapper
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, cy - s * 0.15);
          ctx.bezierCurveTo(cx - s * 0.75, cy - s * 0.35, cx - s * 0.95, cy - s * 0.25, cx - s * 1.1, cy - s * 0.4);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, cy + s * 0.15);
          ctx.bezierCurveTo(cx - s * 0.75, cy + s * 0.05, cx - s * 0.95, cy - s * 0.05, cx - s * 1.1, cy - s * 0.15);
          ctx.stroke();
          // Wrapper twist lines left
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.7, cy - s * 0.28);
          ctx.lineTo(cx - s * 0.7, cy + s * 0.08);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.85, cy - s * 0.32);
          ctx.lineTo(cx - s * 0.85, cy);
          ctx.stroke();

          // Right twisted wrapper
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.55, cy - s * 0.15);
          ctx.bezierCurveTo(cx + s * 0.75, cy - s * 0.35, cx + s * 0.95, cy - s * 0.25, cx + s * 1.1, cy - s * 0.4);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.55, cy + s * 0.15);
          ctx.bezierCurveTo(cx + s * 0.75, cy + s * 0.05, cx + s * 0.95, cy - s * 0.05, cx + s * 1.1, cy - s * 0.15);
          ctx.stroke();
          // Wrapper twist lines right
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.7, cy - s * 0.28);
          ctx.lineTo(cx + s * 0.7, cy + s * 0.08);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.85, cy - s * 0.32);
          ctx.lineTo(cx + s * 0.85, cy);
          ctx.stroke();

          // Stripes on candy body
          for (let i = -2; i <= 2; i++) {
            const dx = i * s * 0.2;
            ctx.beginPath();
            ctx.moveTo(cx + dx, cy - s * 0.38);
            ctx.quadraticCurveTo(cx + dx + s * 0.05, cy, cx + dx, cy + s * 0.38);
            ctx.stroke();
          }
        }

        function drawWhale(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Large round body
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.6, cy + s * 0.1);
          ctx.bezierCurveTo(cx + s * 0.8, cy - s * 0.5, cx - s * 0.2, cy - s * 0.7, cx - s * 0.7, cy - s * 0.35);
          ctx.bezierCurveTo(cx - s * 1.0, cy - s * 0.15, cx - s * 1.0, cy + s * 0.3, cx - s * 0.7, cy + s * 0.5);
          ctx.bezierCurveTo(cx - s * 0.3, cy + s * 0.7, cx + s * 0.3, cy + s * 0.6, cx + s * 0.6, cy + s * 0.1);
          ctx.stroke();

          // Tail connection
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.6, cy + s * 0.1);
          ctx.bezierCurveTo(cx + s * 0.85, cy - s * 0.05, cx + s * 0.9, cy + s * 0.05, cx + s * 1.0, cy - s * 0.15);
          ctx.stroke();

          // Tail flukes
          ctx.beginPath();
          ctx.moveTo(cx + s * 1.0, cy - s * 0.15);
          ctx.bezierCurveTo(cx + s * 1.15, cy - s * 0.45, cx + s * 0.85, cy - s * 0.5, cx + s * 1.0, cy - s * 0.15);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx + s * 1.0, cy - s * 0.15);
          ctx.bezierCurveTo(cx + s * 1.2, cy - s * 0.05, cx + s * 1.15, cy + s * 0.2, cx + s * 1.0, cy - s * 0.15);
          ctx.stroke();

          // Eye (small filled circle)
          ctx.beginPath();
          ctx.arc(cx - s * 0.55, cy - s * 0.15, s * 0.06, 0, Math.PI * 2);
          ctx.fill();

          // Smile / mouth
          ctx.beginPath();
          ctx.arc(cx - s * 0.7, cy + s * 0.05, s * 0.15, 0, Math.PI * 0.6);
          ctx.stroke();

          // Belly line
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.65, cy + s * 0.2);
          ctx.bezierCurveTo(cx - s * 0.3, cy + s * 0.45, cx + s * 0.1, cy + s * 0.4, cx + s * 0.45, cy + s * 0.15);
          ctx.stroke();

          // Water spout
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.35, cy - s * 0.55);
          ctx.quadraticCurveTo(cx - s * 0.4, cy - s * 0.8, cx - s * 0.55, cy - s * 0.9);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.35, cy - s * 0.55);
          ctx.lineTo(cx - s * 0.35, cy - s * 0.75);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.35, cy - s * 0.55);
          ctx.quadraticCurveTo(cx - s * 0.3, cy - s * 0.8, cx - s * 0.15, cy - s * 0.9);
          ctx.stroke();
        }

        function drawOctopus(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Round head/mantle
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.3, s * 0.6, Math.PI * 0.85, Math.PI * 0.15, true);
          ctx.stroke();

          // Top of head dome
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.35, s * 0.58, Math.PI * 1.15, Math.PI * 1.85);
          ctx.stroke();

          // 8 curling tentacles
          const tentacleAngles = [-0.85, -0.6, -0.35, -0.15, 0.15, 0.35, 0.6, 0.85];
          for (let i = 0; i < tentacleAngles.length; i++) {
            const angle = tentacleAngles[i];
            const startX = cx + Math.sin(angle * Math.PI) * s * 0.55;
            const startY = cy + s * 0.15;
            const dir = angle > 0 ? 1 : -1;
            const spread = Math.abs(angle);

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.bezierCurveTo(
              startX + dir * s * 0.15, startY + s * 0.4,
              startX + dir * s * spread * 0.6, startY + s * 0.7,
              startX + dir * s * spread * 0.4, startY + s * 0.85
            );
            ctx.bezierCurveTo(
              startX + dir * s * spread * 0.2, startY + s * 0.95,
              startX + dir * s * spread * 0.05, startY + s * 0.85,
              startX + dir * s * spread * 0.15, startY + s * 0.75
            );
            ctx.stroke();
          }

          // Big cute eyes (circles with filled pupils)
          ctx.beginPath();
          ctx.arc(cx - s * 0.22, cy - s * 0.35, s * 0.16, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.22, cy - s * 0.35, s * 0.16, 0, Math.PI * 2);
          ctx.stroke();

          // Pupils
          ctx.beginPath();
          ctx.arc(cx - s * 0.2, cy - s * 0.33, s * 0.07, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(cx + s * 0.24, cy - s * 0.33, s * 0.07, 0, Math.PI * 2);
          ctx.fill();

          // Smile
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.1, s * 0.2, Math.PI * 0.15, Math.PI * 0.85);
          ctx.stroke();
        }

        function drawSeahorse(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // S-shaped body - front curve
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy - s * 0.85);
          ctx.bezierCurveTo(cx - s * 0.4, cy - s * 0.9, cx - s * 0.55, cy - s * 0.55, cx - s * 0.35, cy - s * 0.3);
          ctx.bezierCurveTo(cx - s * 0.15, cy - s * 0.05, cx - s * 0.05, cy + s * 0.2, cx - s * 0.1, cy + s * 0.45);
          ctx.bezierCurveTo(cx - s * 0.15, cy + s * 0.7, cx - s * 0.05, cy + s * 0.9, cx + s * 0.15, cy + s * 1.0);
          ctx.bezierCurveTo(cx + s * 0.3, cy + s * 1.05, cx + s * 0.35, cy + s * 0.9, cx + s * 0.25, cy + s * 0.8);
          ctx.stroke();

          // S-shaped body - back curve
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy - s * 0.85);
          ctx.bezierCurveTo(cx + s * 0.35, cy - s * 0.8, cx + s * 0.3, cy - s * 0.55, cx + s * 0.15, cy - s * 0.3);
          ctx.bezierCurveTo(cx + s * 0.05, cy - s * 0.05, cx + s * 0.15, cy + s * 0.2, cx + s * 0.2, cy + s * 0.45);
          ctx.bezierCurveTo(cx + s * 0.25, cy + s * 0.65, cx + s * 0.3, cy + s * 0.75, cx + s * 0.25, cy + s * 0.8);
          ctx.stroke();

          // Snout
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.35, cy - s * 0.3);
          ctx.bezierCurveTo(cx - s * 0.55, cy - s * 0.35, cx - s * 0.65, cy - s * 0.45, cx - s * 0.7, cy - s * 0.5);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.4, cy - s * 0.4);
          ctx.bezierCurveTo(cx - s * 0.55, cy - s * 0.42, cx - s * 0.65, cy - s * 0.48, cx - s * 0.7, cy - s * 0.5);
          ctx.stroke();

          // Eye
          ctx.beginPath();
          ctx.arc(cx - s * 0.22, cy - s * 0.5, s * 0.06, 0, Math.PI * 2);
          ctx.fill();

          // Dorsal fin ridge (spiky bumps along back)
          const finPoints = [
            { x: 0.25, y: -0.65 }, { x: 0.4, y: -0.6 },
            { x: 0.28, y: -0.5 }, { x: 0.42, y: -0.45 },
            { x: 0.25, y: -0.35 }, { x: 0.38, y: -0.25 },
            { x: 0.2, y: -0.15 }
          ];
          ctx.beginPath();
          ctx.moveTo(cx + s * finPoints[0].x, cy + s * finPoints[0].y);
          for (let i = 1; i < finPoints.length; i++) {
            ctx.lineTo(cx + s * finPoints[i].x, cy + s * finPoints[i].y);
          }
          ctx.stroke();

          // Belly ridges (horizontal lines)
          for (let i = 0; i < 5; i++) {
            const yy = cy - s * 0.15 + i * s * 0.15;
            ctx.beginPath();
            ctx.moveTo(cx - s * 0.08, yy);
            ctx.lineTo(cx + s * 0.1, yy);
            ctx.stroke();
          }
        }

        function drawStarfish(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // 5-armed starfish with slightly curved arms
          const arms = 5;
          const outerR = s * 1.0;
          const innerR = s * 0.4;

          ctx.beginPath();
          for (let i = 0; i < arms; i++) {
            const outerAngle = (i * 2 * Math.PI / arms) - Math.PI / 2;
            const innerAngle = ((i + 0.5) * 2 * Math.PI / arms) - Math.PI / 2;
            const nextOuterAngle = ((i + 1) * 2 * Math.PI / arms) - Math.PI / 2;

            const ox = cx + Math.cos(outerAngle) * outerR;
            const oy = cy + Math.sin(outerAngle) * outerR;
            const ix = cx + Math.cos(innerAngle) * innerR;
            const iy = cy + Math.sin(innerAngle) * innerR;

            if (i === 0) {
              ctx.moveTo(ox, oy);
            }

            // Curve from outer point to inner valley
            const midAngle1 = (outerAngle + innerAngle) / 2;
            const cp1x = cx + Math.cos(midAngle1) * outerR * 0.65;
            const cp1y = cy + Math.sin(midAngle1) * outerR * 0.65;
            ctx.quadraticCurveTo(cp1x, cp1y, ix, iy);

            // Curve from inner valley to next outer point
            const nox = cx + Math.cos(nextOuterAngle) * outerR;
            const noy = cy + Math.sin(nextOuterAngle) * outerR;
            const midAngle2 = (innerAngle + nextOuterAngle) / 2;
            const cp2x = cx + Math.cos(midAngle2) * outerR * 0.65;
            const cp2y = cy + Math.sin(midAngle2) * outerR * 0.65;
            ctx.quadraticCurveTo(cp2x, cp2y, nox, noy);
          }
          ctx.closePath();
          ctx.stroke();

          // Center circle
          ctx.beginPath();
          ctx.arc(cx, cy, s * 0.15, 0, Math.PI * 2);
          ctx.stroke();

          // Dots/circles pattern on each arm
          for (let i = 0; i < arms; i++) {
            const angle = (i * 2 * Math.PI / arms) - Math.PI / 2;
            for (let j = 1; j <= 3; j++) {
              const r = s * (0.2 + j * 0.2);
              const dotX = cx + Math.cos(angle) * r;
              const dotY = cy + Math.sin(angle) * r;
              const dotR = s * (0.06 - j * 0.01);
              ctx.beginPath();
              ctx.arc(dotX, dotY, dotR, 0, Math.PI * 2);
              ctx.stroke();
            }
          }
        }

        function drawTurtle(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Dome shell (large ellipse)
          ctx.beginPath();
          ctx.ellipse(cx, cy - s * 0.05, s * 0.7, s * 0.55, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Hexagonal pattern on shell - center hex
          ctx.beginPath();
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI * 2 / 6) - Math.PI / 6;
            const hx = cx + Math.cos(angle) * s * 0.22;
            const hy = cy - s * 0.05 + Math.sin(angle) * s * 0.18;
            if (i === 0) ctx.moveTo(hx, hy);
            else ctx.lineTo(hx, hy);
          }
          ctx.closePath();
          ctx.stroke();

          // Lines from hex corners to shell edge
          for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI * 2 / 6) - Math.PI / 6;
            const hx = cx + Math.cos(angle) * s * 0.22;
            const hy = cy - s * 0.05 + Math.sin(angle) * s * 0.18;
            const ex = cx + Math.cos(angle) * s * 0.65;
            const ey = cy - s * 0.05 + Math.sin(angle) * s * 0.5;
            ctx.beginPath();
            ctx.moveTo(hx, hy);
            ctx.lineTo(ex, ey);
            ctx.stroke();
          }

          // Head
          ctx.beginPath();
          ctx.arc(cx + s * 0.9, cy + s * 0.05, s * 0.22, 0, Math.PI * 2);
          ctx.stroke();

          // Eye on head
          ctx.beginPath();
          ctx.arc(cx + s * 0.95, cy - s * 0.02, s * 0.04, 0, Math.PI * 2);
          ctx.fill();

          // Front right leg
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy + s * 0.35);
          ctx.bezierCurveTo(cx + s * 0.6, cy + s * 0.65, cx + s * 0.75, cy + s * 0.7, cx + s * 0.65, cy + s * 0.75);
          ctx.bezierCurveTo(cx + s * 0.55, cy + s * 0.8, cx + s * 0.45, cy + s * 0.6, cx + s * 0.35, cy + s * 0.45);
          ctx.stroke();

          // Front left leg
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.5, cy - s * 0.35);
          ctx.bezierCurveTo(cx + s * 0.6, cy - s * 0.65, cx + s * 0.75, cy - s * 0.7, cx + s * 0.65, cy - s * 0.75);
          ctx.bezierCurveTo(cx + s * 0.55, cy - s * 0.8, cx + s * 0.45, cy - s * 0.6, cx + s * 0.35, cy - s * 0.45);
          ctx.stroke();

          // Back right leg
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.45, cy + s * 0.35);
          ctx.bezierCurveTo(cx - s * 0.55, cy + s * 0.6, cx - s * 0.65, cy + s * 0.65, cx - s * 0.55, cy + s * 0.7);
          ctx.bezierCurveTo(cx - s * 0.45, cy + s * 0.75, cx - s * 0.4, cy + s * 0.55, cx - s * 0.35, cy + s * 0.42);
          ctx.stroke();

          // Back left leg
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.45, cy - s * 0.35);
          ctx.bezierCurveTo(cx - s * 0.55, cy - s * 0.6, cx - s * 0.65, cy - s * 0.65, cx - s * 0.55, cy - s * 0.7);
          ctx.bezierCurveTo(cx - s * 0.45, cy - s * 0.75, cx - s * 0.4, cy - s * 0.55, cx - s * 0.35, cy - s * 0.42);
          ctx.stroke();

          // Small tail
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.65, cy + s * 0.05);
          ctx.bezierCurveTo(cx - s * 0.85, cy + s * 0.08, cx - s * 0.9, cy + s * 0.02, cx - s * 0.85, cy - s * 0.02);
          ctx.stroke();
        }

        function drawShell(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Outer shell shape (nautilus-like)
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.8, cy + s * 0.6);
          ctx.bezierCurveTo(cx + s * 1.0, cy + s * 0.2, cx + s * 0.9, cy - s * 0.4, cx + s * 0.5, cy - s * 0.7);
          ctx.bezierCurveTo(cx + s * 0.1, cy - s * 0.9, cx - s * 0.4, cy - s * 0.8, cx - s * 0.7, cy - s * 0.45);
          ctx.bezierCurveTo(cx - s * 0.95, cy - s * 0.1, cx - s * 0.85, cy + s * 0.35, cx - s * 0.5, cy + s * 0.6);
          ctx.bezierCurveTo(cx - s * 0.2, cy + s * 0.8, cx + s * 0.3, cy + s * 0.85, cx + s * 0.8, cy + s * 0.6);
          ctx.closePath();
          ctx.stroke();

          // Concentric spiral
          // First spiral turn
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.55, cy + s * 0.4);
          ctx.bezierCurveTo(cx + s * 0.65, cy + s * 0.1, cx + s * 0.55, cy - s * 0.2, cx + s * 0.3, cy - s * 0.4);
          ctx.bezierCurveTo(cx + s * 0.05, cy - s * 0.55, cx - s * 0.25, cy - s * 0.45, cx - s * 0.4, cy - s * 0.2);
          ctx.bezierCurveTo(cx - s * 0.55, cy + s * 0.05, cx - s * 0.4, cy + s * 0.35, cx - s * 0.15, cy + s * 0.45);
          ctx.bezierCurveTo(cx + s * 0.05, cy + s * 0.55, cx + s * 0.3, cy + s * 0.5, cx + s * 0.55, cy + s * 0.4);
          ctx.stroke();

          // Second spiral turn (tighter)
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.3, cy + s * 0.2);
          ctx.bezierCurveTo(cx + s * 0.35, cy + s * 0.05, cx + s * 0.3, cy - s * 0.1, cx + s * 0.15, cy - s * 0.2);
          ctx.bezierCurveTo(cx, cy - s * 0.3, cx - s * 0.15, cy - s * 0.2, cx - s * 0.2, cy - s * 0.05);
          ctx.bezierCurveTo(cx - s * 0.25, cy + s * 0.1, cx - s * 0.15, cy + s * 0.22, cx, cy + s * 0.25);
          ctx.bezierCurveTo(cx + s * 0.1, cy + s * 0.28, cx + s * 0.2, cy + s * 0.25, cx + s * 0.3, cy + s * 0.2);
          ctx.stroke();

          // Innermost spiral
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.1, cy + s * 0.08);
          ctx.bezierCurveTo(cx + s * 0.12, cy, cx + s * 0.08, cy - s * 0.06, cx, cy - s * 0.08);
          ctx.bezierCurveTo(cx - s * 0.06, cy - s * 0.1, cx - s * 0.1, cy - s * 0.04, cx - s * 0.08, cy + s * 0.02);
          ctx.bezierCurveTo(cx - s * 0.05, cy + s * 0.08, cx + s * 0.02, cy + s * 0.1, cx + s * 0.1, cy + s * 0.08);
          ctx.stroke();

          // Ridged lines radiating from spiral center outward
          const ridgeAngles = [0.3, 0.8, 1.3, 1.8, 2.3, 2.8, 3.3, 3.8, 4.3, 4.8, 5.3, 5.8];
          for (const angle of ridgeAngles) {
            const innerDist = s * 0.25;
            const outerDist = s * 0.7;
            const rx1 = cx + Math.cos(angle) * innerDist;
            const ry1 = cy + Math.sin(angle) * innerDist * 0.75;
            const rx2 = cx + Math.cos(angle) * outerDist;
            const ry2 = cy + Math.sin(angle) * outerDist * 0.75;
            ctx.beginPath();
            ctx.moveTo(rx1, ry1);
            ctx.lineTo(rx2, ry2);
            ctx.stroke();
          }
        }

        function drawPlanet(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Main planet circle
          ctx.beginPath();
          ctx.arc(cx, cy, s * 0.6, 0, Math.PI * 2);
          ctx.stroke();

          // Ring (angled ellipse)
          ctx.beginPath();
          ctx.ellipse(cx, cy, s * 1.1, s * 0.25, -0.3, 0, Math.PI * 2);
          ctx.stroke();

          // Surface band lines
          ctx.beginPath();
          ctx.ellipse(cx, cy - s * 0.15, s * 0.58, s * 0.08, 0, 0, Math.PI);
          ctx.stroke();

          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.1, s * 0.55, s * 0.07, 0, 0, Math.PI);
          ctx.stroke();

          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.3, s * 0.45, s * 0.06, 0, 0, Math.PI);
          ctx.stroke();

          // Craters
          ctx.beginPath();
          ctx.arc(cx - s * 0.2, cy - s * 0.3, s * 0.08, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx + s * 0.25, cy + s * 0.05, s * 0.1, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx - s * 0.05, cy + s * 0.35, s * 0.06, 0, Math.PI * 2);
          ctx.stroke();
        }

        function drawAstronaut(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Helmet (round)
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.45, s * 0.4, 0, Math.PI * 2);
          ctx.stroke();

          // Visor
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.42, s * 0.28, 0, Math.PI * 2);
          ctx.stroke();

          // Visor reflection line
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.15, cy - s * 0.55);
          ctx.quadraticCurveTo(cx - s * 0.05, cy - s * 0.5, cx + s * 0.05, cy - s * 0.55);
          ctx.stroke();

          // Body (boxy suit)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.35, cy - s * 0.08);
          ctx.lineTo(cx + s * 0.35, cy - s * 0.08);
          ctx.lineTo(cx + s * 0.35, cy + s * 0.45);
          ctx.lineTo(cx - s * 0.35, cy + s * 0.45);
          ctx.closePath();
          ctx.stroke();

          // Backpack (round)
          ctx.beginPath();
          ctx.arc(cx + s * 0.5, cy + s * 0.15, s * 0.18, 0, Math.PI * 2);
          ctx.stroke();

          // Left arm
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.35, cy + s * 0.0);
          ctx.lineTo(cx - s * 0.6, cy + s * 0.15);
          ctx.lineTo(cx - s * 0.65, cy + s * 0.35);
          ctx.stroke();

          // Right arm
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.35, cy + s * 0.0);
          ctx.lineTo(cx + s * 0.55, cy + s * 0.3);
          ctx.stroke();

          // Left leg and boot
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.2, cy + s * 0.45);
          ctx.lineTo(cx - s * 0.25, cy + s * 0.75);
          ctx.lineTo(cx - s * 0.4, cy + s * 0.78);
          ctx.lineTo(cx - s * 0.4, cy + s * 0.88);
          ctx.lineTo(cx - s * 0.1, cy + s * 0.88);
          ctx.lineTo(cx - s * 0.1, cy + s * 0.75);
          ctx.stroke();

          // Right leg and boot
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.2, cy + s * 0.45);
          ctx.lineTo(cx + s * 0.25, cy + s * 0.75);
          ctx.lineTo(cx + s * 0.1, cy + s * 0.78);
          ctx.lineTo(cx + s * 0.1, cy + s * 0.88);
          ctx.lineTo(cx + s * 0.4, cy + s * 0.88);
          ctx.lineTo(cx + s * 0.4, cy + s * 0.75);
          ctx.stroke();
        }

        function drawUfo(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Dome on top
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.2, s * 0.35, Math.PI, 0);
          ctx.stroke();

          // Disc body (ellipse)
          ctx.beginPath();
          ctx.ellipse(cx, cy - s * 0.05, s * 0.85, s * 0.2, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Disc rim line
          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.05, s * 0.75, s * 0.12, 0, 0, Math.PI);
          ctx.stroke();

          // Landing lights (circles underneath)
          ctx.beginPath();
          ctx.arc(cx - s * 0.4, cy + s * 0.15, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx, cy + s * 0.18, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx + s * 0.4, cy + s * 0.15, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();

          // Beam lines below
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.3, cy + s * 0.25);
          ctx.lineTo(cx - s * 0.55, cy + s * 0.9);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.25);
          ctx.lineTo(cx, cy + s * 0.9);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(cx + s * 0.3, cy + s * 0.25);
          ctx.lineTo(cx + s * 0.55, cy + s * 0.9);
          ctx.stroke();

          // Bottom beam line
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.5, cy + s * 0.85);
          ctx.lineTo(cx + s * 0.5, cy + s * 0.85);
          ctx.stroke();
        }

        function drawMoon(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Crescent moon - outer arc
          ctx.beginPath();
          ctx.arc(cx - s * 0.1, cy, s * 0.7, 0, Math.PI * 2);
          ctx.stroke();

          // Inner arc to create crescent effect
          ctx.beginPath();
          ctx.arc(cx + s * 0.25, cy - s * 0.1, s * 0.55, 0, Math.PI * 2);
          ctx.stroke();

          // Craters on the visible crescent
          ctx.beginPath();
          ctx.arc(cx - s * 0.45, cy - s * 0.2, s * 0.08, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx - s * 0.55, cy + s * 0.15, s * 0.06, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx - s * 0.3, cy + s * 0.4, s * 0.07, 0, Math.PI * 2);
          ctx.stroke();

          // Sleeping face - closed eye (curved line)
          ctx.beginPath();
          ctx.arc(cx - s * 0.35, cy - s * 0.05, s * 0.08, 0, Math.PI);
          ctx.stroke();

          // Smile
          ctx.beginPath();
          ctx.arc(cx - s * 0.35, cy + s * 0.15, s * 0.1, 0.2, Math.PI - 0.2);
          ctx.stroke();

          // Small stars around
          const drawStar = (x, y, r) => {
            ctx.beginPath();
            ctx.moveTo(x, y - r);
            ctx.lineTo(x, y + r);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x - r, y);
            ctx.lineTo(x + r, y);
            ctx.stroke();
          };

          drawStar(cx + s * 0.7, cy - s * 0.6, s * 0.08);
          drawStar(cx + s * 0.9, cy - s * 0.2, s * 0.06);
          drawStar(cx + s * 0.6, cy + s * 0.5, s * 0.07);
          drawStar(cx - s * 0.1, cy - s * 0.85, s * 0.05);
          drawStar(cx + s * 0.3, cy + s * 0.8, s * 0.06);
        }

        function drawSatellite(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Boxy body
          ctx.beginPath();
          ctx.rect(cx - s * 0.2, cy - s * 0.2, s * 0.4, s * 0.4);
          ctx.stroke();

          // Body detail lines
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.2, cy);
          ctx.lineTo(cx + s * 0.2, cy);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.2);
          ctx.lineTo(cx, cy + s * 0.2);
          ctx.stroke();

          // Left solar panel
          ctx.beginPath();
          ctx.rect(cx - s * 0.85, cy - s * 0.25, s * 0.55, s * 0.5);
          ctx.stroke();

          // Left panel grid lines (vertical)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.575, cy - s * 0.25);
          ctx.lineTo(cx - s * 0.575, cy + s * 0.25);
          ctx.stroke();

          // Left panel grid lines (horizontal)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.85, cy);
          ctx.lineTo(cx - s * 0.3, cy);
          ctx.stroke();

          // Right solar panel
          ctx.beginPath();
          ctx.rect(cx + s * 0.3, cy - s * 0.25, s * 0.55, s * 0.5);
          ctx.stroke();

          // Right panel grid lines (vertical)
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.575, cy - s * 0.25);
          ctx.lineTo(cx + s * 0.575, cy + s * 0.25);
          ctx.stroke();

          // Right panel grid lines (horizontal)
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.3, cy);
          ctx.lineTo(cx + s * 0.85, cy);
          ctx.stroke();

          // Antenna dish on top
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.45, s * 0.15, Math.PI, 0);
          ctx.stroke();

          // Antenna rod
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.2);
          ctx.lineTo(cx, cy - s * 0.45);
          ctx.stroke();

          // Small antenna tip
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.6);
          ctx.lineTo(cx, cy - s * 0.75);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.77, s * 0.03, 0, Math.PI * 2);
          ctx.stroke();
        }

        function drawComet(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Comet head/nucleus
          ctx.beginPath();
          ctx.arc(cx + s * 0.35, cy - s * 0.1, s * 0.22, 0, Math.PI * 2);
          ctx.stroke();

          // Streaming tail - upper curve
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy - s * 0.2);
          ctx.bezierCurveTo(cx - s * 0.2, cy - s * 0.35, cx - s * 0.6, cy - s * 0.5, cx - s * 1.0, cy - s * 0.3);
          ctx.stroke();

          // Streaming tail - lower curve
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.15, cy + s * 0.05);
          ctx.bezierCurveTo(cx - s * 0.2, cy + s * 0.15, cx - s * 0.6, cy + s * 0.35, cx - s * 1.0, cy + s * 0.2);
          ctx.stroke();

          // Middle tail line
          ctx.beginPath();
          ctx.moveTo(cx + s * 0.13, cy - s * 0.08);
          ctx.bezierCurveTo(cx - s * 0.3, cy - s * 0.1, cx - s * 0.65, cy - s * 0.05, cx - s * 0.95, cy - s * 0.05);
          ctx.stroke();

          // Sparkle dots around head
          ctx.beginPath();
          ctx.arc(cx + s * 0.65, cy - s * 0.3, s * 0.03, 0, Math.PI * 2);
          ctx.fill();

          ctx.beginPath();
          ctx.arc(cx + s * 0.6, cy + s * 0.15, s * 0.025, 0, Math.PI * 2);
          ctx.fill();

          ctx.beginPath();
          ctx.arc(cx + s * 0.2, cy - s * 0.35, s * 0.03, 0, Math.PI * 2);
          ctx.fill();

          ctx.beginPath();
          ctx.arc(cx + s * 0.5, cy - s * 0.4, s * 0.02, 0, Math.PI * 2);
          ctx.fill();

          ctx.beginPath();
          ctx.arc(cx + s * 0.7, cy + s * 0.0, s * 0.025, 0, Math.PI * 2);
          ctx.fill();
        }

        function drawBalloon(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Balloon body (oval)
          ctx.beginPath();
          ctx.ellipse(cx, cy - s * 0.25, s * 0.45, s * 0.6, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Tied knot at bottom (small triangle)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.06, cy + s * 0.35);
          ctx.lineTo(cx, cy + s * 0.45);
          ctx.lineTo(cx + s * 0.06, cy + s * 0.35);
          ctx.closePath();
          ctx.stroke();

          // Long curving string
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.45);
          ctx.quadraticCurveTo(cx + s * 0.2, cy + s * 0.65, cx - s * 0.1, cy + s * 0.8);
          ctx.quadraticCurveTo(cx - s * 0.25, cy + s * 0.9, cx + s * 0.05, cy + s * 1.1);
          ctx.stroke();

          // Highlight oval on balloon
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.15, cy - s * 0.4, s * 0.08, s * 0.18, -0.3, 0, Math.PI * 2);
          ctx.stroke();
        }

        function drawHeart(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Large heart shape
          const drawHeartShape = (ox, oy, scale) => {
            ctx.beginPath();
            ctx.moveTo(cx + ox, cy + s * 0.2 * scale + oy);
            ctx.bezierCurveTo(cx + ox, cy - s * 0.1 * scale + oy, cx - s * 0.5 * scale + ox, cy - s * 0.4 * scale + oy, cx - s * 0.5 * scale + ox, cy - s * 0.1 * scale + oy);
            ctx.bezierCurveTo(cx - s * 0.5 * scale + ox, cy + s * 0.15 * scale + oy, cx + ox, cy + s * 0.35 * scale + oy, cx + ox, cy + s * 0.7 * scale + oy);
            ctx.bezierCurveTo(cx + ox, cy + s * 0.35 * scale + oy, cx + s * 0.5 * scale + ox, cy + s * 0.15 * scale + oy, cx + s * 0.5 * scale + ox, cy - s * 0.1 * scale + oy);
            ctx.bezierCurveTo(cx + s * 0.5 * scale + ox, cy - s * 0.4 * scale + oy, cx + ox, cy - s * 0.1 * scale + oy, cx + ox, cy + s * 0.2 * scale + oy);
            ctx.stroke();
          };

          drawHeartShape(0, 0, 1.4);

          // Decorative inner heart outline
          drawHeartShape(0, 0, 0.85);

          // Small floating hearts
          drawHeartShape(-s * 0.75, -s * 0.5, 0.25);
          drawHeartShape(s * 0.8, -s * 0.45, 0.2);
          drawHeartShape(-s * 0.6, s * 0.55, 0.18);
          drawHeartShape(s * 0.7, s * 0.5, 0.22);
        }

        function drawGuitar(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Lower body (larger circle of figure-8)
          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.35, s * 0.45, s * 0.45, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Upper body (smaller circle of figure-8)
          ctx.beginPath();
          ctx.ellipse(cx, cy - s * 0.05, s * 0.32, s * 0.3, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Waist curves (connecting the two)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.32, cy - s * 0.05);
          ctx.quadraticCurveTo(cx - s * 0.22, cy + s * 0.12, cx - s * 0.45, cy + s * 0.35);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(cx + s * 0.32, cy - s * 0.05);
          ctx.quadraticCurveTo(cx + s * 0.22, cy + s * 0.12, cx + s * 0.45, cy + s * 0.35);
          ctx.stroke();

          // Sound hole
          ctx.beginPath();
          ctx.arc(cx, cy + s * 0.3, s * 0.12, 0, Math.PI * 2);
          ctx.stroke();

          // Neck
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.1, cy - s * 0.3);
          ctx.lineTo(cx - s * 0.1, cy - s * 0.85);
          ctx.lineTo(cx + s * 0.1, cy - s * 0.85);
          ctx.lineTo(cx + s * 0.1, cy - s * 0.3);
          ctx.stroke();

          // Frets
          for (let i = 1; i <= 4; i++) {
            const fy = cy - s * 0.3 - (s * 0.55 * i / 5);
            ctx.beginPath();
            ctx.moveTo(cx - s * 0.1, fy);
            ctx.lineTo(cx + s * 0.1, fy);
            ctx.stroke();
          }

          // Headstock
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.12, cy - s * 0.85);
          ctx.lineTo(cx - s * 0.14, cy - s * 1.05);
          ctx.lineTo(cx + s * 0.14, cy - s * 1.05);
          ctx.lineTo(cx + s * 0.12, cy - s * 0.85);
          ctx.stroke();

          // Tuning pegs (small circles)
          ctx.beginPath();
          ctx.arc(cx - s * 0.18, cy - s * 0.9, s * 0.03, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx - s * 0.18, cy - s * 0.96, s * 0.03, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.18, cy - s * 0.9, s * 0.03, 0, Math.PI * 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(cx + s * 0.18, cy - s * 0.96, s * 0.03, 0, Math.PI * 2);
          ctx.stroke();

          // Strings (simplified - 2 lines)
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.03, cy - s * 0.85);
          ctx.lineTo(cx - s * 0.03, cy + s * 0.6);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(cx + s * 0.03, cy - s * 0.85);
          ctx.lineTo(cx + s * 0.03, cy + s * 0.6);
          ctx.stroke();
        }

        function drawPresent(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Main box
          ctx.beginPath();
          ctx.rect(cx - s * 0.55, cy - s * 0.15, s * 1.1, s * 0.8);
          ctx.stroke();

          // Lid (slightly wider, offset up)
          ctx.beginPath();
          ctx.rect(cx - s * 0.6, cy - s * 0.35, s * 1.2, s * 0.25);
          ctx.stroke();

          // Vertical ribbon
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.08, cy - s * 0.35);
          ctx.lineTo(cx - s * 0.08, cy + s * 0.65);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(cx + s * 0.08, cy - s * 0.35);
          ctx.lineTo(cx + s * 0.08, cy + s * 0.65);
          ctx.stroke();

          // Horizontal ribbon
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.55, cy + s * 0.2);
          ctx.lineTo(cx - s * 0.08, cy + s * 0.2);
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(cx + s * 0.08, cy + s * 0.2);
          ctx.lineTo(cx + s * 0.55, cy + s * 0.2);
          ctx.stroke();

          // Bow - left loop
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.35);
          ctx.bezierCurveTo(cx - s * 0.35, cy - s * 0.5, cx - s * 0.4, cy - s * 0.75, cx, cy - s * 0.55);
          ctx.stroke();

          // Bow - right loop
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.35);
          ctx.bezierCurveTo(cx + s * 0.35, cy - s * 0.5, cx + s * 0.4, cy - s * 0.75, cx, cy - s * 0.55);
          ctx.stroke();

          // Bow center knot
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.4, s * 0.06, 0, Math.PI * 2);
          ctx.stroke();

          // Decorative dots/circles on box
          ctx.beginPath();
          ctx.arc(cx - s * 0.3, cy + s * 0.0, s * 0.04, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx + s * 0.3, cy + s * 0.45, s * 0.04, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx - s * 0.35, cy + s * 0.5, s * 0.04, 0, Math.PI * 2);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx + s * 0.35, cy + s * 0.05, s * 0.04, 0, Math.PI * 2);
          ctx.stroke();
        }

        function drawKite(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Diamond-shaped kite
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.8);
          ctx.lineTo(cx + s * 0.45, cy - s * 0.15);
          ctx.lineTo(cx, cy + s * 0.5);
          ctx.lineTo(cx - s * 0.45, cy - s * 0.15);
          ctx.closePath();
          ctx.stroke();

          // Cross frame - vertical
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.8);
          ctx.lineTo(cx, cy + s * 0.5);
          ctx.stroke();

          // Cross frame - horizontal
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.45, cy - s * 0.15);
          ctx.lineTo(cx + s * 0.45, cy - s * 0.15);
          ctx.stroke();

          // Decorative pattern inside - top triangle
          ctx.beginPath();
          ctx.moveTo(cx - s * 0.2, cy - s * 0.15);
          ctx.lineTo(cx, cy - s * 0.5);
          ctx.lineTo(cx + s * 0.2, cy - s * 0.15);
          ctx.stroke();

          // Decorative pattern inside - small diamond
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.35);
          ctx.lineTo(cx + s * 0.12, cy - s * 0.15);
          ctx.lineTo(cx, cy + s * 0.05);
          ctx.lineTo(cx - s * 0.12, cy - s * 0.15);
          ctx.closePath();
          ctx.stroke();

          // Long tail
          ctx.beginPath();
          ctx.moveTo(cx, cy + s * 0.5);
          ctx.quadraticCurveTo(cx + s * 0.3, cy + s * 0.7, cx - s * 0.1, cy + s * 0.9);
          ctx.quadraticCurveTo(cx - s * 0.35, cy + s * 1.05, cx + s * 0.1, cy + s * 1.2);
          ctx.stroke();

          // Bows on tail
          const drawBow = (x, y) => {
            ctx.beginPath();
            ctx.moveTo(x - s * 0.1, y - s * 0.04);
            ctx.lineTo(x, y + s * 0.02);
            ctx.lineTo(x + s * 0.1, y - s * 0.04);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x - s * 0.1, y + s * 0.04);
            ctx.lineTo(x, y - s * 0.02);
            ctx.lineTo(x + s * 0.1, y + s * 0.04);
            ctx.stroke();
          };

          drawBow(cx + s * 0.1, cy + s * 0.68);
          drawBow(cx - s * 0.2, cy + s * 0.95);
          drawBow(cx + s * 0.0, cy + s * 1.15);
        }

        function drawTeddy(ctx, w, h) {
          const s = Math.min(w, h) * 0.35;
          const cx = w / 2, cy = h / 2;
          ctx.strokeStyle = '#333';
          ctx.lineWidth = Math.max(2, s * 0.04);
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          // Round body
          ctx.beginPath();
          ctx.ellipse(cx, cy + s * 0.3, s * 0.5, s * 0.55, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Round head
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.35, s * 0.38, 0, Math.PI * 2);
          ctx.stroke();

          // Left ear
          ctx.beginPath();
          ctx.arc(cx - s * 0.32, cy - s * 0.65, s * 0.15, 0, Math.PI * 2);
          ctx.stroke();

          // Left inner ear
          ctx.beginPath();
          ctx.arc(cx - s * 0.32, cy - s * 0.65, s * 0.08, 0, Math.PI * 2);
          ctx.stroke();

          // Right ear
          ctx.beginPath();
          ctx.arc(cx + s * 0.32, cy - s * 0.65, s * 0.15, 0, Math.PI * 2);
          ctx.stroke();

          // Right inner ear
          ctx.beginPath();
          ctx.arc(cx + s * 0.32, cy - s * 0.65, s * 0.08, 0, Math.PI * 2);
          ctx.stroke();

          // Left arm
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.55, cy + s * 0.15, s * 0.15, s * 0.3, 0.3, 0, Math.PI * 2);
          ctx.stroke();

          // Right arm
          ctx.beginPath();
          ctx.ellipse(cx + s * 0.55, cy + s * 0.15, s * 0.15, s * 0.3, -0.3, 0, Math.PI * 2);
          ctx.stroke();

          // Left leg
          ctx.beginPath();
          ctx.ellipse(cx - s * 0.28, cy + s * 0.8, s * 0.2, s * 0.15, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Right leg
          ctx.beginPath();
          ctx.ellipse(cx + s * 0.28, cy + s * 0.8, s * 0.2, s * 0.15, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Snout circle
          ctx.beginPath();
          ctx.ellipse(cx, cy - s * 0.25, s * 0.15, s * 0.12, 0, 0, Math.PI * 2);
          ctx.stroke();

          // Eyes (small filled dots)
          ctx.beginPath();
          ctx.arc(cx - s * 0.12, cy - s * 0.4, s * 0.04, 0, Math.PI * 2);
          ctx.fill();

          ctx.beginPath();
          ctx.arc(cx + s * 0.12, cy - s * 0.4, s * 0.04, 0, Math.PI * 2);
          ctx.fill();

          // Nose (small filled triangle)
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.28);
          ctx.lineTo(cx - s * 0.05, cy - s * 0.22);
          ctx.lineTo(cx + s * 0.05, cy - s * 0.22);
          ctx.closePath();
          ctx.fill();

          // Mouth
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.22);
          ctx.lineTo(cx, cy - s * 0.17);
          ctx.stroke();

          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.17, s * 0.06, 0, Math.PI);
          ctx.stroke();

          // Bow tie
          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.02);
          ctx.lineTo(cx - s * 0.15, cy - s * 0.1);
          ctx.lineTo(cx - s * 0.15, cy + s * 0.06);
          ctx.closePath();
          ctx.stroke();

          ctx.beginPath();
          ctx.moveTo(cx, cy - s * 0.02);
          ctx.lineTo(cx + s * 0.15, cy - s * 0.1);
          ctx.lineTo(cx + s * 0.15, cy + s * 0.06);
          ctx.closePath();
          ctx.stroke();

          // Bow tie center knot
          ctx.beginPath();
          ctx.arc(cx, cy - s * 0.02, s * 0.04, 0, Math.PI * 2);
          ctx.stroke();
        }


        // Init
        window.addEventListener('load', () => {
            generateUI();
            createBubbles();
            loadSettings();
            updateSavedRecordings();
            resizeCanvas();
            drawVisualizer();

            // Initialize new features
            initSequencer();
            renderFavorites();

            // Initialize paint canvas
            initPaintCanvas();

            // Initialize new paint features
            initPhotoUpload();
            coloringEngine.initColors();
            coloringEngine.initBrushSlider();
            renderColoringCategoryTabs();
            renderColoringGrid();
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
            resizePaintCanvas();
            if (currentPaintMode === 'colorphoto') resizePhotoCanvas();
            if (currentPaintMode === 'coloringbook') resizeColoringCanvas();
        });
    </script>
</body>
</html>
